{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.DuplicatePolyfillsConformanceCheck = void 0;\n\nvar _constants = require(\"../constants\");\n\nvar _TestInterface = require(\"../TestInterface\");\n\nvar _astUtils = require(\"../utils/ast-utils\");\n\nvar _fileUtils = require(\"../utils/file-utils\"); // eslint-disable-next-line import/no-extraneous-dependencies\n// eslint-disable-next-line import/no-extraneous-dependencies\n\n\nfunction getMessage(property, request, isWarning = false) {\n  if (isWarning) {\n    return `${_constants.CONFORMANCE_WARNING_PREFIX}: Found a ${property} polyfill in ${(0, _fileUtils.getLocalFileName)(request)}.`;\n  }\n\n  return `${_constants.CONFORMANCE_ERROR_PREFIX}: Found a ${property} polyfill in ${(0, _fileUtils.getLocalFileName)(request)}.`;\n}\n\nconst BANNED_LEFT_OBJECT_TYPES = ['Identifier', 'ThisExpression'];\n\nclass DuplicatePolyfillsConformanceCheck {\n  constructor(options = {}) {\n    this.BlockedAPIs = [];\n    this.BlockedAPIs = options.BlockedAPIToBePolyfilled || [];\n  }\n\n  getAstNode() {\n    const EARLY_EXIT_SUCCESS_RESULT = {\n      result: _TestInterface.IConformanceTestStatus.SUCCESS\n    };\n    return [{\n      visitor: 'visitAssignmentExpression',\n      inspectNode: (path, {\n        request\n      }) => {\n        const {\n          node\n        } = path;\n        const left = node.left;\n        /**\n        * We're only interested in code like `foo.fetch = bar;`.\n        * For anything else we exit with a success.\n        * Also foo in foo.bar needs to be either Identifier or `this` and not someFunction().fetch;\n        */\n\n        if (left.type !== 'MemberExpression' || !BANNED_LEFT_OBJECT_TYPES.includes(left.object.type) || left.property.type !== 'Identifier') {\n          return EARLY_EXIT_SUCCESS_RESULT;\n        }\n\n        if (!this.BlockedAPIs.includes(left.property.name)) {\n          return EARLY_EXIT_SUCCESS_RESULT;\n        }\n        /**\n        * Here we know the code is `foo.(fetch/URL) = something.\n        * If foo === this/self, fail it immediately.\n        * check for this.[fetch|URL(...BlockedAPIs)]/ self.[fetch|URL(...BlockedAPIs)]\n        **/\n\n\n        if (isNodeThisOrSelf(left.object)) {\n          return {\n            result: _TestInterface.IConformanceTestStatus.FAILED,\n            warnings: [{\n              message: getMessage(left.property.name, request)\n            }]\n          };\n        }\n        /**\n        * we now are sure the code under examination is\n        * `globalVar.[fetch|URL(...BlockedAPIs)] = something`\n        **/\n\n\n        const objectName = left.object.name;\n        const allBindings = path.scope.lookup(objectName);\n\n        if (!allBindings) {\n          /**\n          * we have absolutely no idea where globalVar came from,\n          * so lets just exit\n          **/\n          return EARLY_EXIT_SUCCESS_RESULT;\n        }\n\n        try {\n          const sourcePath = allBindings.bindings[objectName][0];\n          const originPath = sourcePath.parentPath;\n          const {\n            node: originNode\n          } = originPath;\n\n          if (originNode.type === 'VariableDeclarator' && isNodeThisOrSelf(originNode.init)) {\n            return {\n              result: _TestInterface.IConformanceTestStatus.FAILED,\n              warnings: [{\n                message: getMessage(left.property.name, request)\n              }]\n            };\n          }\n\n          if (originPath.name === 'params' && originPath.parentPath.firstInStatement()) {\n            /**\n            * We do not know what will be the value of this param at runtime so we just throw a warning.\n            * ```\n            * (function(scope){\n            *  ....\n            *  scope.fetch = new Fetch();\n            * })(.....)\n            * ```\n            */\n            return {\n              result: _TestInterface.IConformanceTestStatus.FAILED,\n              warnings: [{\n                message: getMessage(left.property.name, request, true)\n              }]\n            };\n          }\n        } catch (e) {\n          return EARLY_EXIT_SUCCESS_RESULT;\n        }\n\n        return EARLY_EXIT_SUCCESS_RESULT;\n      }\n    }, {\n      visitor: 'visitCallExpression',\n      inspectNode: path => {\n        const {\n          node\n        } = path;\n\n        if (!node.arguments || node.arguments.length < 2) {\n          return EARLY_EXIT_SUCCESS_RESULT;\n        }\n\n        if ((0, _astUtils.isNodeCreatingScriptElement)(node)) {\n          const propsNode = node.arguments[1];\n\n          if (!propsNode.properties) {\n            return EARLY_EXIT_SUCCESS_RESULT;\n          }\n\n          const props = (0, _astUtils.reducePropsToObject)(propsNode);\n\n          if (!('src' in props)) {\n            return EARLY_EXIT_SUCCESS_RESULT;\n          }\n\n          const foundBannedPolyfill = doesScriptLoadBannedAPIfromPolyfillIO(props.src, this.BlockedAPIs);\n\n          if (foundBannedPolyfill) {\n            return {\n              result: _TestInterface.IConformanceTestStatus.FAILED,\n              warnings: [{\n                message: `${_constants.CONFORMANCE_WARNING_PREFIX}: Found polyfill.io loading polyfill for ${foundBannedPolyfill}.`\n              }]\n            };\n          }\n        }\n\n        return EARLY_EXIT_SUCCESS_RESULT;\n      }\n    }];\n  }\n\n}\n\nexports.DuplicatePolyfillsConformanceCheck = DuplicatePolyfillsConformanceCheck;\n\nfunction isNodeThisOrSelf(node) {\n  return node.type === 'ThisExpression' || node.type === 'Identifier' && node.name === 'self';\n}\n\nfunction doesScriptLoadBannedAPIfromPolyfillIO(source, blockedAPIs) {\n  const url = new URL(source);\n\n  if (url.hostname === 'polyfill.io' && url.searchParams.has('features')) {\n    const requestedAPIs = (url.searchParams.get('features') || '').split(',');\n    return blockedAPIs.find(api => requestedAPIs.includes(api));\n  }\n}","map":{"version":3,"sources":["../../../../../../build/webpack/plugins/webpack-conformance-plugin/checks/duplicate-polyfills-conformance-check.ts"],"names":["isWarning","CONFORMANCE_WARNING_PREFIX","property","CONFORMANCE_ERROR_PREFIX","BANNED_LEFT_OBJECT_TYPES","DuplicatePolyfillsConformanceCheck","BlockedAPIs","constructor","options","getAstNode","EARLY_EXIT_SUCCESS_RESULT","result","IConformanceTestStatus","visitor","inspectNode","left","node","isNodeThisOrSelf","warnings","message","getMessage","objectName","allBindings","path","sourcePath","originPath","originNode","propsNode","props","foundBannedPolyfill","doesScriptLoadBannedAPIfromPolyfillIO","url","requestedAPIs","blockedAPIs","api"],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nimport { namedTypes } from 'ast-types'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { NodePath } from 'ast-types/lib/node-path'\nimport { types } from 'next/dist/compiled/recast'\nimport {\n  CONFORMANCE_ERROR_PREFIX,\n  CONFORMANCE_WARNING_PREFIX,\n} from '../constants'\nimport {\n  IConformanceTestResult,\n  IConformanceTestStatus,\n  IGetAstNodeResult,\n  IParsedModuleDetails,\n  IWebpackConformanceTest,\n} from '../TestInterface'\nimport {\n  isNodeCreatingScriptElement,\n  reducePropsToObject,\n} from '../utils/ast-utils'\nimport { getLocalFileName } from '../utils/file-utils'\n\nfunction getMessage(\n  property: string,\n  request: string,\n  isWarning: Boolean = false\n): string {\n  if (isWarning) {\n    return `${CONFORMANCE_WARNING_PREFIX}: Found a ${property} polyfill in ${getLocalFileName(\n      request\n    )}.`\n  }\n  return `${CONFORMANCE_ERROR_PREFIX}: Found a ${property} polyfill in ${getLocalFileName(\n    request\n  )}.`\n}\n\nexport interface DuplicatePolyfillsConformanceTestSettings {\n  BlockedAPIToBePolyfilled?: string[]\n}\n\nconst BANNED_LEFT_OBJECT_TYPES = ['Identifier', 'ThisExpression']\n\nexport class DuplicatePolyfillsConformanceCheck\n  implements IWebpackConformanceTest {\n  private BlockedAPIs: string[] = []\n  constructor(options: DuplicatePolyfillsConformanceTestSettings = {}) {\n    this.BlockedAPIs = options.BlockedAPIToBePolyfilled || []\n  }\n  public getAstNode(): IGetAstNodeResult[] {\n    const EARLY_EXIT_SUCCESS_RESULT: IConformanceTestResult = {\n      result: IConformanceTestStatus.SUCCESS,\n    }\n    return [\n      {\n        visitor: 'visitAssignmentExpression',\n        inspectNode: (\n          path: NodePath<namedTypes.AssignmentExpression>,\n          { request }: IParsedModuleDetails\n        ): IConformanceTestResult => {\n          const { node } = path\n          const left = node.left as namedTypes.MemberExpression\n          /**\n           * We're only interested in code like `foo.fetch = bar;`.\n           * For anything else we exit with a success.\n           * Also foo in foo.bar needs to be either Identifier or `this` and not someFunction().fetch;\n           */\n          if (\n            left.type !== 'MemberExpression' ||\n            !BANNED_LEFT_OBJECT_TYPES.includes(left.object.type) ||\n            left.property.type !== 'Identifier'\n          ) {\n            return EARLY_EXIT_SUCCESS_RESULT\n          }\n          if (!this.BlockedAPIs.includes(left.property.name)) {\n            return EARLY_EXIT_SUCCESS_RESULT\n          }\n          /**\n           * Here we know the code is `foo.(fetch/URL) = something.\n           * If foo === this/self, fail it immediately.\n           * check for this.[fetch|URL(...BlockedAPIs)]/ self.[fetch|URL(...BlockedAPIs)]\n           **/\n          if (isNodeThisOrSelf(left.object)) {\n            return {\n              result: IConformanceTestStatus.FAILED,\n              warnings: [\n                {\n                  message: getMessage(left.property.name, request),\n                },\n              ],\n            }\n          }\n          /**\n           * we now are sure the code under examination is\n           * `globalVar.[fetch|URL(...BlockedAPIs)] = something`\n           **/\n          const objectName = (left.object as namedTypes.Identifier).name\n          const allBindings = path.scope.lookup(objectName)\n          if (!allBindings) {\n            /**\n             * we have absolutely no idea where globalVar came from,\n             * so lets just exit\n             **/\n            return EARLY_EXIT_SUCCESS_RESULT\n          }\n\n          try {\n            const sourcePath = allBindings.bindings[objectName][0]\n            const originPath = sourcePath.parentPath\n            const {\n              node: originNode,\n            }: { node: namedTypes.VariableDeclarator } = originPath\n            if (\n              originNode.type === 'VariableDeclarator' &&\n              isNodeThisOrSelf(originNode.init)\n            ) {\n              return {\n                result: IConformanceTestStatus.FAILED,\n                warnings: [\n                  {\n                    message: getMessage(left.property.name, request),\n                  },\n                ],\n              }\n            }\n            if (\n              originPath.name === 'params' &&\n              originPath.parentPath.firstInStatement()\n            ) {\n              /**\n               * We do not know what will be the value of this param at runtime so we just throw a warning.\n               * ```\n               * (function(scope){\n               *  ....\n               *  scope.fetch = new Fetch();\n               * })(.....)\n               * ```\n               */\n              return {\n                result: IConformanceTestStatus.FAILED,\n                warnings: [\n                  {\n                    message: getMessage(left.property.name, request, true),\n                  },\n                ],\n              }\n            }\n          } catch (e) {\n            return EARLY_EXIT_SUCCESS_RESULT\n          }\n\n          return EARLY_EXIT_SUCCESS_RESULT\n        },\n      },\n      {\n        visitor: 'visitCallExpression',\n        inspectNode: (path: NodePath) => {\n          const { node }: { node: types.namedTypes.CallExpression } = path\n          if (!node.arguments || node.arguments.length < 2) {\n            return EARLY_EXIT_SUCCESS_RESULT\n          }\n          if (isNodeCreatingScriptElement(node)) {\n            const propsNode = node\n              .arguments[1] as types.namedTypes.ObjectExpression\n            if (!propsNode.properties) {\n              return EARLY_EXIT_SUCCESS_RESULT\n            }\n            const props: {\n              [key: string]: string\n            } = reducePropsToObject(propsNode)\n            if (!('src' in props)) {\n              return EARLY_EXIT_SUCCESS_RESULT\n            }\n            const foundBannedPolyfill = doesScriptLoadBannedAPIfromPolyfillIO(\n              props.src,\n              this.BlockedAPIs\n            )\n            if (foundBannedPolyfill) {\n              return {\n                result: IConformanceTestStatus.FAILED,\n                warnings: [\n                  {\n                    message: `${CONFORMANCE_WARNING_PREFIX}: Found polyfill.io loading polyfill for ${foundBannedPolyfill}.`,\n                  },\n                ],\n              }\n            }\n          }\n          return EARLY_EXIT_SUCCESS_RESULT\n        },\n      },\n    ]\n  }\n}\n\nfunction isNodeThisOrSelf(node: any): boolean {\n  return (\n    node.type === 'ThisExpression' ||\n    (node.type === 'Identifier' && node.name === 'self')\n  )\n}\n\nfunction doesScriptLoadBannedAPIfromPolyfillIO(\n  source: string,\n  blockedAPIs: string[]\n): string | undefined {\n  const url = new URL(source)\n  if (url.hostname === 'polyfill.io' && url.searchParams.has('features')) {\n    const requestedAPIs = (url.searchParams.get('features') || '').split(',')\n    return blockedAPIs.find((api) => requestedAPIs.includes(api))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}