{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport * as ast from \"./ast.js\";\nimport { make_node } from \"./utils/index.js\";\nimport { AST_Accessor, AST_Array, AST_Arrow, AST_Assign, AST_Atom, AST_Await, AST_BigInt, AST_Binary, AST_Block, AST_BlockStatement, AST_Boolean, AST_Break, AST_Call, AST_Case, AST_Catch, AST_Chain, AST_Class, AST_ClassExpression, AST_ClassProperty, AST_ConciseMethod, AST_Conditional, AST_Const, AST_Constant, AST_Continue, AST_Debugger, AST_Default, AST_DefaultAssign, AST_DefClass, AST_Definitions, AST_Defun, AST_Destructuring, AST_Directive, AST_Do, AST_Dot, AST_EmptyStatement, AST_Expansion, AST_Export, AST_False, AST_Finally, AST_For, AST_ForIn, AST_ForOf, AST_Function, AST_Hole, AST_If, AST_Import, AST_ImportMeta, AST_Label, AST_LabeledStatement, AST_LabelRef, AST_Lambda, AST_Let, AST_NameMapping, AST_New, AST_NewTarget, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrefixedTemplateString, AST_PropAccess, AST_RegExp, AST_Return, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Super, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_SymbolCatch, AST_SymbolClass, AST_SymbolClassProperty, AST_SymbolConst, AST_SymbolDefClass, AST_SymbolDefun, AST_SymbolExport, AST_SymbolExportForeign, AST_SymbolFunarg, AST_SymbolImport, AST_SymbolImportForeign, AST_SymbolLambda, AST_SymbolLet, AST_SymbolMethod, AST_SymbolRef, AST_SymbolVar, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Throw, AST_Token, AST_Toplevel, AST_True, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Var, AST_VarDef, AST_While, AST_With, AST_Yield } from \"./ast.js\";\n\n(function () {\n  var normalize_directives = function (body) {\n    var in_directive = true;\n\n    for (var i = 0; i < body.length; i++) {\n      if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n        body[i] = new AST_Directive({\n          start: body[i].start,\n          end: body[i].end,\n          value: body[i].body.value\n        });\n      } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n        in_directive = false;\n      }\n    }\n\n    return body;\n  };\n\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrayPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.elements.map(function (elm) {\n          if (elm === null) {\n            return new AST_Hole();\n          }\n\n          return from_moz(elm);\n        }),\n        is_array: true\n      });\n    },\n    ObjectPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.properties.map(from_moz),\n        is_array: false\n      });\n    },\n    AssignmentPattern: function (M) {\n      return new AST_DefaultAssign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        left: from_moz(M.left),\n        operator: \"=\",\n        right: from_moz(M.right)\n      });\n    },\n    SpreadElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    RestElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    TemplateElement: function (M) {\n      return new AST_TemplateSegment({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value.cooked,\n        raw: M.value.raw\n      });\n    },\n    TemplateLiteral: function (M) {\n      var segments = [];\n\n      for (var i = 0; i < M.quasis.length; i++) {\n        segments.push(from_moz(M.quasis[i]));\n\n        if (M.expressions[i]) {\n          segments.push(from_moz(M.expressions[i]));\n        }\n      }\n\n      return new AST_TemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        segments: segments\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      return new AST_PrefixedTemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        template_string: from_moz(M.quasi),\n        prefix: from_moz(M.tag)\n      });\n    },\n    FunctionDeclaration: function (M) {\n      return new AST_Defun({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      return new AST_Function({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      const body = M.body.type === \"BlockStatement\" ? from_moz(M.body).body : [make_node(AST_Return, {}, {\n        value: from_moz(M.body)\n      })];\n      return new AST_Arrow({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: M.params.map(from_moz),\n        body,\n        async: M.async\n      });\n    },\n    ExpressionStatement: function (M) {\n      return new AST_SimpleStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.expression)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.key;\n      var args = {\n        start: my_start_token(key || M.value),\n        end: my_end_token(M.value),\n        key: key.type == \"Identifier\" ? key.name : key.value,\n        value: from_moz(M.value)\n      };\n\n      if (M.computed) {\n        args.key = from_moz(M.key);\n      }\n\n      if (M.method) {\n        args.is_generator = M.value.generator;\n        args.async = M.value.async;\n\n        if (!M.computed) {\n          args.key = new AST_SymbolMethod({\n            name: args.key\n          });\n        } else {\n          args.key = from_moz(M.key);\n        }\n\n        return new AST_ConciseMethod(args);\n      }\n\n      if (M.kind == \"init\") {\n        if (key.type != \"Identifier\" && key.type != \"Literal\") {\n          args.key = from_moz(key);\n        }\n\n        return new AST_ObjectKeyVal(args);\n      }\n\n      if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n        args.key = new AST_SymbolMethod({\n          name: args.key\n        });\n      }\n\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n\n      if (M.kind == \"method\") {\n        args.async = M.value.async;\n        args.is_generator = M.value.generator;\n        args.quote = M.computed ? \"\\\"\" : null;\n        return new AST_ConciseMethod(args);\n      }\n    },\n    MethodDefinition: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: M.computed ? from_moz(M.key) : new AST_SymbolMethod({\n          name: M.key.name || M.key.value\n        }),\n        value: from_moz(M.value),\n        static: M.static\n      };\n\n      if (M.kind == \"get\") {\n        return new AST_ObjectGetter(args);\n      }\n\n      if (M.kind == \"set\") {\n        return new AST_ObjectSetter(args);\n      }\n\n      args.is_generator = M.value.generator;\n      args.async = M.value.async;\n      return new AST_ConciseMethod(args);\n    },\n    FieldDefinition: function (M) {\n      let key;\n\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n        key = from_moz(M.key);\n      }\n\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ObjectExpression: function (M) {\n      return new AST_Object({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.properties.map(function (prop) {\n          if (prop.type === \"SpreadElement\") {\n            return from_moz(prop);\n          }\n\n          prop.type = \"Property\";\n          return from_moz(prop);\n        })\n      });\n    },\n    SequenceExpression: function (M) {\n      return new AST_Sequence({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz)\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        property: M.computed ? from_moz(M.property) : M.property.name,\n        expression: from_moz(M.object),\n        optional: M.optional || false\n      });\n    },\n    ChainExpression: function (M) {\n      return new AST_Chain({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.expression)\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new (M.kind === \"const\" ? AST_Const : M.kind === \"let\" ? AST_Let : AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    ImportDeclaration: function (M) {\n      var imported_name = null;\n      var imported_names = null;\n      M.specifiers.forEach(function (specifier) {\n        if (specifier.type === \"ImportSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: from_moz(specifier.imported),\n            name: from_moz(specifier.local)\n          }));\n        } else if (specifier.type === \"ImportDefaultSpecifier\") {\n          imported_name = from_moz(specifier.local);\n        } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: new AST_SymbolImportForeign({\n              name: \"*\"\n            }),\n            name: from_moz(specifier.local)\n          }));\n        }\n      });\n      return new AST_Import({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        imported_name: imported_name,\n        imported_names: imported_names,\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_names: [new AST_NameMapping({\n          name: new AST_SymbolExportForeign({\n            name: \"*\"\n          }),\n          foreign_name: new AST_SymbolExportForeign({\n            name: \"*\"\n          })\n        })],\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_definition: from_moz(M.declaration),\n        exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n          return new AST_NameMapping({\n            foreign_name: from_moz(specifier.exported),\n            name: from_moz(specifier.local)\n          });\n        }) : null,\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_value: from_moz(M.declaration),\n        is_default: true\n      });\n    },\n    Literal: function (M) {\n      var val = M.value,\n          args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n      var rx = M.regex;\n\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = {\n          source: rx.pattern,\n          flags: rx.flags\n        };\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        const rx_source = M.raw || val;\n        const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n        if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n        const [_, source, flags] = match;\n        args.value = {\n          source,\n          flags\n        };\n        return new AST_RegExp(args);\n      }\n\n      if (val === null) return new AST_Null(args);\n\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n\n        case \"number\":\n          args.value = val;\n          args.raw = M.raw || val.toString();\n          return new AST_Number(args);\n\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    MetaProperty: function (M) {\n      if (M.meta.name === \"new\" && M.property.name === \"target\") {\n        return new AST_NewTarget({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n        return new AST_ImportMeta({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      }\n    },\n    Identifier: function (M) {\n      var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n      return new (p.type == \"LabeledStatement\" ? AST_Label : p.type == \"VariableDeclarator\" && p.id === M ? p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar : /Import.*Specifier/.test(p.type) ? p.local === M ? AST_SymbolImport : AST_SymbolImportForeign : p.type == \"ExportSpecifier\" ? p.local === M ? AST_SymbolExport : AST_SymbolExportForeign : p.type == \"FunctionExpression\" ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == \"FunctionDeclaration\" ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == \"ArrowFunctionExpression\" ? p.params.includes(M) ? AST_SymbolFunarg : AST_SymbolRef : p.type == \"ClassExpression\" ? p.id === M ? AST_SymbolClass : AST_SymbolRef : p.type == \"Property\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod : p.type == \"FieldDefinition\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty : p.type == \"ClassDeclaration\" ? p.id === M ? AST_SymbolDefClass : AST_SymbolRef : p.type == \"MethodDefinition\" ? p.computed ? AST_SymbolRef : AST_SymbolMethod : p.type == \"CatchClause\" ? AST_SymbolCatch : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef : AST_SymbolRef)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n\n    BigIntLiteral(M) {\n      return new AST_BigInt({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value\n      });\n    }\n\n  };\n\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n\n  MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n    return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      name: from_moz(M.id),\n      extends: from_moz(M.superClass),\n      properties: M.body.body.map(from_moz)\n    });\n  };\n\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"ForOfStatement\", AST_ForOf, \"left>init, right>object, body>body, await=await\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=is_star\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"ThisExpression\", AST_This);\n  map(\"Super\", AST_Super);\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n  map(\"CallExpression\", AST_Call, \"callee>expression, optional=optional, arguments@args\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n    return {\n      type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.prefix),\n      quasi: to_moz(M.template_string)\n    };\n  });\n  def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n    var quasis = [];\n    var expressions = [];\n\n    for (var i = 0; i < M.segments.length; i++) {\n      if (i % 2 !== 0) {\n        expressions.push(to_moz(M.segments[i]));\n      } else {\n        quasis.push({\n          type: \"TemplateElement\",\n          value: {\n            raw: M.segments[i].raw,\n            cooked: M.segments[i].value\n          },\n          tail: i === M.segments.length - 1\n        });\n      }\n    }\n\n    return {\n      type: \"TemplateLiteral\",\n      quasis: quasis,\n      expressions: expressions\n    };\n  });\n  def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: M.is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n    var is_generator = parent.is_generator !== undefined ? parent.is_generator : M.is_generator;\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n    var body = {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n    return {\n      type: \"ArrowFunctionExpression\",\n      params: M.argnames.map(to_moz),\n      async: M.async,\n      body: body\n    };\n  });\n  def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n    if (M.is_array) {\n      return {\n        type: \"ArrayPattern\",\n        elements: M.names.map(to_moz)\n      };\n    }\n\n    return {\n      type: \"ObjectPattern\",\n      properties: M.names.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: M.value,\n        raw: M.print_to_string()\n      },\n      directive: M.value\n    };\n  });\n  def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M instanceof AST_Const ? \"const\" : M instanceof AST_Let ? \"let\" : \"var\",\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n    if (M.exported_names) {\n      if (M.exported_names[0].name.name === \"*\") {\n        return {\n          type: \"ExportAllDeclaration\",\n          source: to_moz(M.module_name)\n        };\n      }\n\n      return {\n        type: \"ExportNamedDeclaration\",\n        specifiers: M.exported_names.map(function (name_mapping) {\n          return {\n            type: \"ExportSpecifier\",\n            exported: to_moz(name_mapping.foreign_name),\n            local: to_moz(name_mapping.name)\n          };\n        }),\n        declaration: to_moz(M.exported_definition),\n        source: to_moz(M.module_name)\n      };\n    }\n\n    return {\n      type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n      declaration: to_moz(M.exported_value || M.exported_definition)\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = [];\n\n    if (M.imported_name) {\n      specifiers.push({\n        type: \"ImportDefaultSpecifier\",\n        local: to_moz(M.imported_name)\n      });\n    }\n\n    if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n      specifiers.push({\n        type: \"ImportNamespaceSpecifier\",\n        local: to_moz(M.imported_names[0].name)\n      });\n    } else if (M.imported_names) {\n      M.imported_names.forEach(function (name_mapping) {\n        specifiers.push({\n          type: \"ImportSpecifier\",\n          local: to_moz(name_mapping.name),\n          imported: to_moz(name_mapping.foreign_name)\n        });\n      });\n    }\n\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.module_name)\n    };\n  });\n  def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"import\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"meta\"\n      }\n    };\n  });\n  def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n    return {\n      type: \"SequenceExpression\",\n      expressions: M.expressions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var isComputed = M instanceof AST_Sub;\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: isComputed,\n      property: isComputed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n    return {\n      type: \"ChainExpression\",\n      expression: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    if (M.operator == \"=\" && to_moz_in_destructuring()) {\n      return {\n        type: \"AssignmentPattern\",\n        left: to_moz(M.left),\n        right: to_moz(M.right)\n      };\n    }\n\n    const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\" ? \"LogicalExpression\" : \"BinaryExpression\";\n    return {\n      type,\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n    return {\n      type: \"ObjectExpression\",\n      properties: M.properties.map(to_moz)\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n    var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n      type: \"Identifier\",\n      value: M.key\n    };\n\n    if (typeof M.key === \"number\") {\n      key = {\n        type: \"Literal\",\n        value: Number(M.key)\n      };\n    }\n\n    if (typeof M.key === \"string\") {\n      key = {\n        type: \"Identifier\",\n        name: M.key\n      };\n    }\n\n    var kind;\n    var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n    var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n      computed = !string_or_num;\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n\n    if (M instanceof AST_ClassProperty) {\n      return {\n        type: \"FieldDefinition\",\n        computed,\n        key,\n        value: to_moz(M.value),\n        static: M.static\n      };\n    }\n\n    if (parent instanceof AST_Class) {\n      return {\n        type: \"MethodDefinition\",\n        computed: computed,\n        kind: kind,\n        static: M.static,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    return {\n      type: \"Property\",\n      computed: computed,\n      kind: kind,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n    if (parent instanceof AST_Object) {\n      return {\n        type: \"Property\",\n        computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n        kind: \"init\",\n        method: true,\n        shorthand: false,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    return {\n      type: \"MethodDefinition\",\n      computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n      kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n      static: M.static,\n      key: to_moz(M.key),\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Class, function To_Moz_Class(M) {\n    var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n    return {\n      type: type,\n      superClass: to_moz(M.extends),\n      id: M.name ? to_moz(M.name) : null,\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n    if (M instanceof AST_SymbolMethod && parent.quote) {\n      return {\n        type: \"Literal\",\n        value: M.name\n      };\n    }\n\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def ? def.mangled_name || def.name : M.name\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    const pattern = M.value.source;\n    const flags = M.value.flags;\n    return {\n      type: \"Literal\",\n      value: null,\n      raw: M.print_to_string(),\n      regex: {\n        pattern,\n        flags\n      }\n    };\n  });\n  def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.raw || M.print_to_string()\n    };\n  });\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_BigInt, M => ({\n    type: \"BigIntLiteral\",\n    value: M.value\n  }));\n  AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() {\n    return null;\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n  /* -----[ tools ]----- */\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n        start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);\n  }\n\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n        end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);\n  }\n\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n    moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" + \"start: my_start_token(M),\\n\" + \"end: my_end_token(M)\";\n    var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n    me_to_moz += \"return {\\n\" + \"type: \" + JSON.stringify(moztype);\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n          how = m[2],\n          my = m[3];\n      moz_to_me += \",\\n\" + my + \": \";\n      me_to_moz += \",\\n\" + moz + \": \";\n\n      switch (how) {\n        case \"@\":\n          moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n          me_to_moz += \"M.\" + my + \".map(to_moz)\";\n          break;\n\n        case \">\":\n          moz_to_me += \"from_moz(M.\" + moz + \")\";\n          me_to_moz += \"to_moz(M.\" + my + \")\";\n          break;\n\n        case \"=\":\n          moz_to_me += \"M.\" + moz;\n          me_to_moz += \"M.\" + my;\n          break;\n\n        case \"%\":\n          moz_to_me += \"from_moz(M.\" + moz + \").body\";\n          me_to_moz += \"to_moz_block(M)\";\n          break;\n\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    moz_to_me += \"\\n})\\n}\";\n    me_to_moz += \"\\n}\\n}\";\n    moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(ast, my_start_token, my_end_token, from_moz);\n    me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(to_moz, to_moz_block, to_moz_scope);\n    MOZ_TO_ME[moztype] = moz_to_me;\n    def_to_moz(mytype, me_to_moz);\n  }\n\n  var FROM_MOZ_STACK = null;\n\n  function from_moz(node) {\n    FROM_MOZ_STACK.push(node);\n    var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n    FROM_MOZ_STACK.pop();\n    return ret;\n  }\n\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    return ast;\n  };\n\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n\n    if (!(start && end)) {\n      return moznode;\n    }\n\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n\n    return moznode;\n  }\n\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function (parent) {\n      return set_moz_loc(this, handler(this, parent));\n    });\n  }\n\n  var TO_MOZ_STACK = null;\n\n  function to_moz(node) {\n    if (TO_MOZ_STACK === null) {\n      TO_MOZ_STACK = [];\n    }\n\n    TO_MOZ_STACK.push(node);\n    var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n    TO_MOZ_STACK.pop();\n\n    if (TO_MOZ_STACK.length === 0) {\n      TO_MOZ_STACK = null;\n    }\n\n    return ast;\n  }\n\n  function to_moz_in_destructuring() {\n    var i = TO_MOZ_STACK.length;\n\n    while (i--) {\n      if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/node_modules/terser/lib/mozilla-ast.js"],"names":["ast","make_node","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassExpression","AST_ClassProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_EmptyStatement","AST_Expansion","AST_Export","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","normalize_directives","body","in_directive","i","length","start","end","value","MOZ_TO_ME","Program","M","my_start_token","my_end_token","map","from_moz","ArrayPattern","names","elements","elm","is_array","ObjectPattern","properties","AssignmentPattern","left","operator","right","SpreadElement","expression","argument","RestElement","TemplateElement","cooked","raw","TemplateLiteral","segments","quasis","push","expressions","TaggedTemplateExpression","template_string","quasi","prefix","tag","FunctionDeclaration","name","id","argnames","params","is_generator","generator","async","FunctionExpression","ArrowFunctionExpression","type","ExpressionStatement","TryStatement","handlers","handler","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","key","args","computed","method","kind","quote","MethodDefinition","static","FieldDefinition","ArrayExpression","elem","ObjectExpression","prop","SequenceExpression","MemberExpression","property","object","optional","ChainExpression","SwitchCase","test","consequent","VariableDeclaration","definitions","declarations","ImportDeclaration","imported_name","imported_names","specifiers","forEach","specifier","foreign_name","imported","local","module_name","source","ExportAllDeclaration","exported_names","ExportNamedDeclaration","exported_definition","declaration","exported","ExportDefaultDeclaration","exported_value","is_default","Literal","val","rx","regex","pattern","flags","rx_source","match","_","toString","MetaProperty","meta","Identifier","p","FROM_MOZ_STACK","includes","BigIntLiteral","UpdateExpression","UnaryExpression","To_Moz_Unary","ClassDeclaration","ClassExpression","From_Moz_Class","extends","superClass","def_to_moz","To_Moz_Program","to_moz_scope","To_Moz_Spread","to_moz_in_destructuring","to_moz","To_Moz_TaggedTemplateExpression","To_Moz_TemplateLiteral","tail","To_Moz_FunctionDeclaration","To_Moz_FunctionExpression","parent","undefined","To_Moz_ArrowFunctionExpression","To_Moz_ObjectPattern","To_Moz_Directive","print_to_string","directive","To_Moz_ExpressionStatement","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","param","argname","guard","To_Moz_VariableDeclaration","To_Moz_ExportDeclaration","name_mapping","To_Moz_ImportDeclaration","To_Moz_MetaProperty","To_Moz_SequenceExpression","To_Moz_MemberExpression","isComputed","To_Moz_ChainExpression","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ObjectExpression","To_Moz_Property","Number","string_or_num","To_Moz_MethodDefinition","shorthand","To_Moz_Class","To_Moz_Identifier","def","definition","mangled_name","To_Moz_RegExpLiteral","To_Moz_Literal","To_Moz_Atom","String","DEFMETHOD","prototype","to_mozilla_ast","To_Moz_ArrayHole","moznode","loc","range","line","column","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","node","ret","pop","from_mozilla_ast","save_stack","set_moz_loc","mynode","pos","endpos","col","endline","endcol","file","TO_MOZ_STACK","unshift"],"mappings":"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","sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport * as ast from \"./ast.js\";\nimport { make_node } from \"./utils/index.js\";\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Arrow,\n    AST_Assign,\n    AST_Atom,\n    AST_Await,\n    AST_BigInt,\n    AST_Binary,\n    AST_Block,\n    AST_BlockStatement,\n    AST_Boolean,\n    AST_Break,\n    AST_Call,\n    AST_Case,\n    AST_Catch,\n    AST_Chain,\n    AST_Class,\n    AST_ClassExpression,\n    AST_ClassProperty,\n    AST_ConciseMethod,\n    AST_Conditional,\n    AST_Const,\n    AST_Constant,\n    AST_Continue,\n    AST_Debugger,\n    AST_Default,\n    AST_DefaultAssign,\n    AST_DefClass,\n    AST_Definitions,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Directive,\n    AST_Do,\n    AST_Dot,\n    AST_EmptyStatement,\n    AST_Expansion,\n    AST_Export,\n    AST_False,\n    AST_Finally,\n    AST_For,\n    AST_ForIn,\n    AST_ForOf,\n    AST_Function,\n    AST_Hole,\n    AST_If,\n    AST_Import,\n    AST_ImportMeta,\n    AST_Label,\n    AST_LabeledStatement,\n    AST_LabelRef,\n    AST_Lambda,\n    AST_Let,\n    AST_NameMapping,\n    AST_New,\n    AST_NewTarget,\n    AST_Node,\n    AST_Null,\n    AST_Number,\n    AST_Object,\n    AST_ObjectGetter,\n    AST_ObjectKeyVal,\n    AST_ObjectProperty,\n    AST_ObjectSetter,\n    AST_PrefixedTemplateString,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Return,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Statement,\n    AST_String,\n    AST_Sub,\n    AST_Super,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolClass,\n    AST_SymbolClassProperty,\n    AST_SymbolConst,\n    AST_SymbolDefClass,\n    AST_SymbolDefun,\n    AST_SymbolExport,\n    AST_SymbolExportForeign,\n    AST_SymbolFunarg,\n    AST_SymbolImport,\n    AST_SymbolImportForeign,\n    AST_SymbolLambda,\n    AST_SymbolLet,\n    AST_SymbolMethod,\n    AST_SymbolRef,\n    AST_SymbolVar,\n    AST_TemplateSegment,\n    AST_TemplateString,\n    AST_This,\n    AST_Throw,\n    AST_Token,\n    AST_Toplevel,\n    AST_True,\n    AST_Try,\n    AST_Unary,\n    AST_UnaryPostfix,\n    AST_UnaryPrefix,\n    AST_Var,\n    AST_VarDef,\n    AST_While,\n    AST_With,\n    AST_Yield,\n} from \"./ast.js\";\n\n(function() {\n\n    var normalize_directives = function(body) {\n        var in_directive = true;\n\n        for (var i = 0; i < body.length; i++) {\n            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    value: body[i].body.value\n                });\n            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n                in_directive = false;\n            }\n        }\n\n        return body;\n    };\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        FunctionExpression: function(M) {\n            return new AST_Function({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(from_moz),\n                body,\n                async: M.async,\n            });\n        },\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n        Property: function(M) {\n            var key = M.key;\n            var args = {\n                start    : my_start_token(key || M.value),\n                end      : my_end_token(M.value),\n                key      : key.type == \"Identifier\" ? key.name : key.value,\n                value    : from_moz(M.value)\n            };\n            if (M.computed) {\n                args.key = from_moz(M.key);\n            }\n            if (M.method) {\n                args.is_generator = M.value.generator;\n                args.async = M.value.async;\n                if (!M.computed) {\n                    args.key = new AST_SymbolMethod({ name: args.key });\n                } else {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ConciseMethod(args);\n            }\n            if (M.kind == \"init\") {\n                if (key.type != \"Identifier\" && key.type != \"Literal\") {\n                    args.key = from_moz(key);\n                }\n                return new AST_ObjectKeyVal(args);\n            }\n            if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n                args.key = new AST_SymbolMethod({\n                    name: args.key\n                });\n            }\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            if (M.kind == \"method\") {\n                args.async = M.value.async;\n                args.is_generator = M.value.generator;\n                args.quote = M.computed ? \"\\\"\" : null;\n                return new AST_ConciseMethod(args);\n            }\n        },\n        MethodDefinition: function(M) {\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key      : M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value }),\n                value    : from_moz(M.value),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new AST_ObjectGetter(args);\n            }\n            if (M.kind == \"set\") {\n                return new AST_ObjectSetter(args);\n            }\n            args.is_generator = M.value.generator;\n            args.async = M.value.async;\n            return new AST_ConciseMethod(args);\n        },\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new (M.kind === \"const\" ? AST_Const :\n                        M.kind === \"let\" ? AST_Let : AST_Var)({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : M.declarations.map(from_moz)\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: from_moz(specifier.imported),\n                        name: from_moz(specifier.local)\n                    }));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier.local);\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                        name: from_moz(specifier.local)\n                    }));\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source)\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        name: new AST_SymbolExportForeign({ name: \"*\" }),\n                        foreign_name: new AST_SymbolExportForeign({ name: \"*\" })\n                    })\n                ],\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_definition: from_moz(M.declaration),\n                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n                    return new AST_NameMapping({\n                        foreign_name: from_moz(specifier.exported),\n                        name: from_moz(specifier.local)\n                    });\n                }) : null,\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n        Identifier: function(M) {\n            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n            return new (  p.type == \"LabeledStatement\" ? AST_Label\n                        : p.type == \"VariableDeclarator\" && p.id === M ? (p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar)\n                        : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)\n                        : p.type == \"ExportSpecifier\" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)\n                        : p.type == \"FunctionExpression\" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)\n                        : p.type == \"FunctionDeclaration\" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)\n                        : p.type == \"ArrowFunctionExpression\" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef\n                        : p.type == \"ClassExpression\" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)\n                        : p.type == \"Property\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"FieldDefinition\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)\n                        : p.type == \"ClassDeclaration\" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)\n                        : p.type == \"MethodDefinition\" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"CatchClause\" ? AST_SymbolCatch\n                        : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef\n                        : AST_SymbolRef)({\n                            start : my_start_token(M),\n                            end   : my_end_token(M),\n                            name  : M.name\n                        });\n        },\n        BigIntLiteral(M) {\n            return new AST_BigInt({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                value : M.value\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : from_moz(M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"ForOfStatement\", AST_ForOf, \"left>init, right>object, body>body, await=await\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=is_star\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"ThisExpression\", AST_This);\n    map(\"Super\", AST_Super);\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, optional=optional, arguments@args\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n        var is_generator = parent.is_generator !== undefined ?\n            parent.is_generator : M.is_generator;\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz),\n            async: M.async,\n            body: body\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(to_moz)\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" : \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            if (M.exported_names[0].name.name === \"*\") {\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name)\n            };\n        }\n        return {\n            type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n            declaration: to_moz(M.exported_value || M.exported_definition)\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n            specifiers.push({\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.imported_names[0].name)\n            });\n        } else if (M.imported_names) {\n            M.imported_names.forEach(function(name_mapping) {\n                specifiers.push({\n                    type: \"ImportSpecifier\",\n                    local: to_moz(name_mapping.name),\n                    imported: to_moz(name_mapping.foreign_name)\n                });\n            });\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n            type: \"Identifier\",\n            value: M.key\n        };\n        if (typeof M.key === \"number\") {\n            key = {\n                type: \"Literal\",\n                value: Number(M.key)\n            };\n        }\n        if (typeof M.key === \"string\") {\n            key = {\n                type: \"Identifier\",\n                name: M.key\n            };\n        }\n        var kind;\n        var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n        var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n            computed = !string_or_num;\n        } else\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"FieldDefinition\",\n                computed,\n                key,\n                value: to_moz(M.value),\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n                kind: \"init\",\n                method: true,\n                shorthand: false,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"MethodDefinition\",\n            computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n            kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n            static: M.static,\n            key: to_moz(M.key),\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (M instanceof AST_SymbolMethod && parent.quote) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"BigIntLiteral\",\n        value: M.value\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n        moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" +\n            \"start: my_start_token(M),\\n\" +\n            \"end: my_end_token(M)\";\n\n        var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n        me_to_moz += \"return {\\n\" +\n            \"type: \" + JSON.stringify(moztype);\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            moz_to_me += \",\\n\" + my + \": \";\n            me_to_moz += \",\\n\" + moz + \": \";\n            switch (how) {\n                case \"@\":\n                    moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n                    me_to_moz += \"M.\" +  my + \".map(to_moz)\";\n                    break;\n                case \">\":\n                    moz_to_me += \"from_moz(M.\" + moz + \")\";\n                    me_to_moz += \"to_moz(M.\" + my + \")\";\n                    break;\n                case \"=\":\n                    moz_to_me += \"M.\" + moz;\n                    me_to_moz += \"M.\" + my;\n                    break;\n                case \"%\":\n                    moz_to_me += \"from_moz(M.\" + moz + \").body\";\n                    me_to_moz += \"to_moz_block(M)\";\n                    break;\n                default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        moz_to_me += \"\\n})\\n}\";\n        me_to_moz += \"\\n}\\n}\";\n\n        moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(\n            ast, my_start_token, my_end_token, from_moz\n        );\n        me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(\n            to_moz, to_moz_block, to_moz_scope\n        );\n        MOZ_TO_ME[moztype] = moz_to_me;\n        def_to_moz(mytype, me_to_moz);\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(node) {\n        FROM_MOZ_STACK.push(node);\n        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n        FROM_MOZ_STACK.pop();\n        return ret;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n"]},"metadata":{},"sourceType":"module"}