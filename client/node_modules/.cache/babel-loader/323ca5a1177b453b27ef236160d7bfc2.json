{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.NextJsRequireCacheHotReloader = void 0;\n\nvar _webpack = require(\"webpack\");\n\nvar _fs = require(\"fs\");\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst isWebpack5 = parseInt(_webpack.version) === 5;\n\nfunction deleteCache(filePath) {\n  try {\n    delete require.cache[(0, _fs.realpathSync)(filePath)];\n  } catch (e) {\n    if (e.code !== 'ENOENT') throw e;\n  } finally {\n    delete require.cache[filePath];\n  }\n}\n\nconst PLUGIN_NAME = 'NextJsRequireCacheHotReloader'; // This plugin flushes require.cache after emitting the files. Providing 'hot reloading' of server files.\n\nclass NextJsRequireCacheHotReloader {\n  constructor() {\n    this.prevAssets = null;\n    this.previousOutputPathsWebpack5 = new Set();\n    this.currentOutputPathsWebpack5 = new Set();\n  }\n\n  apply(compiler) {\n    if (isWebpack5) {\n      // @ts-ignored Webpack has this hooks\n      compiler.hooks.assetEmitted.tap(PLUGIN_NAME, (_file, {\n        targetPath\n      }) => {\n        this.currentOutputPathsWebpack5.add(targetPath);\n        deleteCache(targetPath);\n      });\n      compiler.hooks.afterEmit.tap(PLUGIN_NAME, compilation => {\n        const runtimeChunkPath = _path.default.join(compilation.outputOptions.path, 'webpack-runtime.js');\n\n        deleteCache(runtimeChunkPath); // we need to make sure to clear all server entries from cache\n        // since they can have a stale webpack-runtime cache\n        // which needs to always be in-sync\n\n        const entries = [...compilation.entries.keys()].filter(entry => entry.toString().startsWith('pages/'));\n        entries.forEach(page => {\n          const outputPath = _path.default.join(compilation.outputOptions.path, page + '.js');\n\n          deleteCache(outputPath);\n        });\n      });\n      this.previousOutputPathsWebpack5 = new Set(this.currentOutputPathsWebpack5);\n      this.currentOutputPathsWebpack5.clear();\n      return;\n    }\n\n    compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, (compilation, callback) => {\n      const {\n        assets\n      } = compilation;\n\n      if (this.prevAssets) {\n        for (const f of Object.keys(assets)) {\n          deleteCache(assets[f].existsAt);\n        }\n\n        for (const f of Object.keys(this.prevAssets)) {\n          if (!assets[f]) {\n            deleteCache(this.prevAssets[f].existsAt);\n          }\n        }\n      }\n\n      this.prevAssets = assets;\n      callback();\n    });\n  }\n\n}\n\nexports.NextJsRequireCacheHotReloader = NextJsRequireCacheHotReloader;","map":{"version":3,"sources":["../../../../build/webpack/plugins/nextjs-require-cache-hot-reloader.ts"],"names":["isWebpack5","parseInt","version","require","e","PLUGIN_NAME","NextJsRequireCacheHotReloader","apply","compiler","deleteCache","compilation","runtimeChunkPath","path","entries","entry","page","outputPath","Object","assets","callback"],"mappings":"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","sourcesContent":["import { Compiler, Plugin, version } from 'webpack'\nimport { realpathSync } from 'fs'\nimport path from 'path'\n\nconst isWebpack5 = parseInt(version!) === 5\n\nfunction deleteCache(filePath: string) {\n  try {\n    delete require.cache[realpathSync(filePath)]\n  } catch (e) {\n    if (e.code !== 'ENOENT') throw e\n  } finally {\n    delete require.cache[filePath]\n  }\n}\n\nconst PLUGIN_NAME = 'NextJsRequireCacheHotReloader'\n\n// This plugin flushes require.cache after emitting the files. Providing 'hot reloading' of server files.\nexport class NextJsRequireCacheHotReloader implements Plugin {\n  prevAssets: any = null\n  previousOutputPathsWebpack5: Set<string> = new Set()\n  currentOutputPathsWebpack5: Set<string> = new Set()\n\n  apply(compiler: Compiler) {\n    if (isWebpack5) {\n      // @ts-ignored Webpack has this hooks\n      compiler.hooks.assetEmitted.tap(\n        PLUGIN_NAME,\n        (_file: any, { targetPath }: any) => {\n          this.currentOutputPathsWebpack5.add(targetPath)\n          deleteCache(targetPath)\n        }\n      )\n\n      compiler.hooks.afterEmit.tap(PLUGIN_NAME, (compilation) => {\n        const runtimeChunkPath = path.join(\n          compilation.outputOptions.path,\n          'webpack-runtime.js'\n        )\n        deleteCache(runtimeChunkPath)\n\n        // we need to make sure to clear all server entries from cache\n        // since they can have a stale webpack-runtime cache\n        // which needs to always be in-sync\n        const entries = [...compilation.entries.keys()].filter((entry) =>\n          entry.toString().startsWith('pages/')\n        )\n\n        entries.forEach((page) => {\n          const outputPath = path.join(\n            compilation.outputOptions.path,\n            page + '.js'\n          )\n          deleteCache(outputPath)\n        })\n      })\n\n      this.previousOutputPathsWebpack5 = new Set(\n        this.currentOutputPathsWebpack5\n      )\n      this.currentOutputPathsWebpack5.clear()\n      return\n    }\n\n    compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, (compilation, callback) => {\n      const { assets } = compilation\n\n      if (this.prevAssets) {\n        for (const f of Object.keys(assets)) {\n          deleteCache(assets[f].existsAt)\n        }\n        for (const f of Object.keys(this.prevAssets)) {\n          if (!assets[f]) {\n            deleteCache(this.prevAssets[f].existsAt)\n          }\n        }\n      }\n      this.prevAssets = assets\n\n      callback()\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}