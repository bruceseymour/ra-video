{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.imageOptimizer = imageOptimizer;\nexports.getMaxAge = getMaxAge;\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _path = require(\"path\");\n\nvar _accept = require(\"@hapi/accept\");\n\nvar _fs = require(\"fs\");\n\nvar _crypto = require(\"crypto\");\n\nvar _serveStatic = require(\"./serve-static\");\n\nvar _fileExists = require(\"../../lib/file-exists\");\n\nvar _isAnimated = _interopRequireDefault(require(\"next/dist/compiled/is-animated\"));\n\nvar _stream = _interopRequireDefault(require(\"stream\"));\n\nvar _sendPayload = require(\"./send-payload\");\n\nvar _imageConfig = require(\"./image-config\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // @ts-ignore no types for is-animated\n\n\nlet sharp; //const AVIF = 'image/avif'\n\nconst WEBP = 'image/webp';\nconst PNG = 'image/png';\nconst JPEG = 'image/jpeg';\nconst GIF = 'image/gif';\nconst SVG = 'image/svg+xml';\nconst CACHE_VERSION = 2;\nconst MODERN_TYPES = [\n/* AVIF, */\nWEBP];\nconst ANIMATABLE_TYPES = [WEBP, PNG, GIF];\nconst VECTOR_TYPES = [SVG];\n\nasync function imageOptimizer(server, req, res, parsedUrl) {\n  var _upstreamType;\n\n  const {\n    nextConfig,\n    distDir\n  } = server;\n  const imageData = nextConfig.images || _imageConfig.imageConfigDefault;\n  const {\n    deviceSizes = [],\n    imageSizes = [],\n    domains = [],\n    loader\n  } = imageData;\n\n  if (loader !== 'default') {\n    await server.render404(req, res, parsedUrl);\n    return {\n      finished: true\n    };\n  }\n\n  const {\n    headers\n  } = req;\n  const {\n    url,\n    w,\n    q\n  } = parsedUrl.query;\n  const mimeType = getSupportedMimeType(MODERN_TYPES, headers.accept);\n  let href;\n\n  if (!url) {\n    res.statusCode = 400;\n    res.end('\"url\" parameter is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(url)) {\n    res.statusCode = 400;\n    res.end('\"url\" parameter cannot be an array');\n    return {\n      finished: true\n    };\n  }\n\n  let isAbsolute;\n\n  if (url.startsWith('/')) {\n    href = url;\n    isAbsolute = false;\n  } else {\n    let hrefParsed;\n\n    try {\n      hrefParsed = new URL(url);\n      href = hrefParsed.toString();\n      isAbsolute = true;\n    } catch (_error) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is invalid');\n      return {\n        finished: true\n      };\n    }\n\n    if (!['http:', 'https:'].includes(hrefParsed.protocol)) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is invalid');\n      return {\n        finished: true\n      };\n    }\n\n    if (!domains.includes(hrefParsed.hostname)) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is not allowed');\n      return {\n        finished: true\n      };\n    }\n  }\n\n  if (!w) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(w)) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) cannot be an array');\n    return {\n      finished: true\n    };\n  }\n\n  if (!q) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(q)) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) cannot be an array');\n    return {\n      finished: true\n    };\n  }\n\n  const width = parseInt(w, 10);\n\n  if (!width || isNaN(width)) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) must be a number greater than 0');\n    return {\n      finished: true\n    };\n  }\n\n  const sizes = [...deviceSizes, ...imageSizes];\n\n  if (!sizes.includes(width)) {\n    res.statusCode = 400;\n    res.end(`\"w\" parameter (width) of ${width} is not allowed`);\n    return {\n      finished: true\n    };\n  }\n\n  const quality = parseInt(q);\n\n  if (isNaN(quality) || quality < 1 || quality > 100) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) must be a number between 1 and 100');\n    return {\n      finished: true\n    };\n  }\n\n  const hash = getHash([CACHE_VERSION, href, width, quality, mimeType]);\n  const imagesDir = (0, _path.join)(distDir, 'cache', 'images');\n  const hashDir = (0, _path.join)(imagesDir, hash);\n  const now = Date.now();\n\n  if (await (0, _fileExists.fileExists)(hashDir, 'directory')) {\n    const files = await _fs.promises.readdir(hashDir);\n\n    for (let file of files) {\n      const [prefix, etag, extension] = file.split('.');\n      const expireAt = Number(prefix);\n      const contentType = (0, _serveStatic.getContentType)(extension);\n      const fsPath = (0, _path.join)(hashDir, file);\n\n      if (now < expireAt) {\n        res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate');\n\n        if ((0, _sendPayload.sendEtagResponse)(req, res, etag)) {\n          return {\n            finished: true\n          };\n        }\n\n        if (contentType) {\n          res.setHeader('Content-Type', contentType);\n        }\n\n        (0, _fs.createReadStream)(fsPath).pipe(res);\n        return {\n          finished: true\n        };\n      } else {\n        await _fs.promises.unlink(fsPath);\n      }\n    }\n  }\n\n  let upstreamBuffer;\n  let upstreamType;\n  let maxAge;\n\n  if (isAbsolute) {\n    const upstreamRes = await fetch(href);\n\n    if (!upstreamRes.ok) {\n      res.statusCode = upstreamRes.status;\n      res.end('\"url\" parameter is valid but upstream response is invalid');\n      return {\n        finished: true\n      };\n    }\n\n    res.statusCode = upstreamRes.status;\n    upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer());\n    upstreamType = upstreamRes.headers.get('Content-Type');\n    maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'));\n  } else {\n    try {\n      const _req = {\n        headers: req.headers,\n        method: req.method,\n        url: href\n      };\n      const resBuffers = [];\n      const mockRes = new _stream.default.Writable();\n\n      mockRes.write = chunk => {\n        resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n      };\n\n      mockRes._write = chunk => {\n        mockRes.write(chunk);\n      };\n\n      const mockHeaders = {};\n\n      mockRes.writeHead = (_status, _headers) => Object.assign(mockHeaders, _headers);\n\n      mockRes.getHeader = name => mockHeaders[name.toLowerCase()];\n\n      mockRes.getHeaders = () => mockHeaders;\n\n      mockRes.getHeaderNames = () => Object.keys(mockHeaders);\n\n      mockRes.setHeader = (name, value) => mockHeaders[name.toLowerCase()] = value;\n\n      mockRes._implicitHeader = () => {};\n\n      mockRes.finished = false;\n      mockRes.statusCode = 200;\n      await server.getRequestHandler()(_req, mockRes, _url.default.parse(href, true));\n      res.statusCode = mockRes.statusCode;\n      upstreamBuffer = Buffer.concat(resBuffers);\n      upstreamType = mockRes.getHeader('Content-Type');\n      maxAge = getMaxAge(mockRes.getHeader('Cache-Control'));\n    } catch (err) {\n      res.statusCode = 500;\n      res.end('\"url\" parameter is valid but upstream response is invalid');\n      return {\n        finished: true\n      };\n    }\n  }\n\n  if (upstreamType) {\n    const vector = VECTOR_TYPES.includes(upstreamType);\n    const animate = ANIMATABLE_TYPES.includes(upstreamType) && (0, _isAnimated.default)(upstreamBuffer);\n\n    if (vector || animate) {\n      sendResponse(req, res, upstreamType, upstreamBuffer);\n      return {\n        finished: true\n      };\n    }\n  }\n\n  const expireAt = maxAge * 1000 + now;\n  let contentType;\n\n  if (mimeType) {\n    contentType = mimeType;\n  } else if ((_upstreamType = upstreamType) != null && _upstreamType.startsWith('image/') && (0, _serveStatic.getExtension)(upstreamType)) {\n    contentType = upstreamType;\n  } else {\n    contentType = JPEG;\n  }\n\n  if (!sharp) {\n    try {\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      sharp = require('sharp');\n    } catch (error) {\n      if (error.code === 'MODULE_NOT_FOUND') {\n        error.message += '\\n\\nLearn more: https://err.sh/next.js/install-sharp';\n        server.logError(error);\n        sendResponse(req, res, upstreamType, upstreamBuffer);\n        return {\n          finished: true\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  try {\n    const transformer = sharp(upstreamBuffer);\n    transformer.rotate(); // auto rotate based on EXIF data\n\n    const {\n      width: metaWidth\n    } = await transformer.metadata();\n\n    if (metaWidth && metaWidth > width) {\n      transformer.resize(width);\n    } //if (contentType === AVIF) {\n    // Soon https://github.com/lovell/sharp/issues/2289\n    //}\n\n\n    if (contentType === WEBP) {\n      transformer.webp({\n        quality\n      });\n    } else if (contentType === PNG) {\n      transformer.png({\n        quality\n      });\n    } else if (contentType === JPEG) {\n      transformer.jpeg({\n        quality\n      });\n    }\n\n    const optimizedBuffer = await transformer.toBuffer();\n    await _fs.promises.mkdir(hashDir, {\n      recursive: true\n    });\n    const extension = (0, _serveStatic.getExtension)(contentType);\n    const etag = getHash([optimizedBuffer]);\n    const filename = (0, _path.join)(hashDir, `${expireAt}.${etag}.${extension}`);\n    await _fs.promises.writeFile(filename, optimizedBuffer);\n    sendResponse(req, res, contentType, optimizedBuffer);\n  } catch (error) {\n    sendResponse(req, res, upstreamType, upstreamBuffer);\n  }\n\n  return {\n    finished: true\n  };\n}\n\nfunction sendResponse(req, res, contentType, buffer) {\n  const etag = getHash([buffer]);\n  res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate');\n\n  if ((0, _sendPayload.sendEtagResponse)(req, res, etag)) {\n    return;\n  }\n\n  if (contentType) {\n    res.setHeader('Content-Type', contentType);\n  }\n\n  res.end(buffer);\n}\n\nfunction getSupportedMimeType(options, accept = '') {\n  const mimeType = (0, _accept.mediaType)(accept, options);\n  return accept.includes(mimeType) ? mimeType : '';\n}\n\nfunction getHash(items) {\n  const hash = (0, _crypto.createHash)('sha256');\n\n  for (let item of items) {\n    if (typeof item === 'number') hash.update(String(item));else {\n      hash.update(item);\n    }\n  } // See https://en.wikipedia.org/wiki/Base64#Filenames\n\n\n  return hash.digest('base64').replace(/\\//g, '-');\n}\n\nfunction parseCacheControl(str) {\n  const map = new Map();\n\n  if (!str) {\n    return map;\n  }\n\n  for (let directive of str.split(',')) {\n    let [key, value] = directive.trim().split('=');\n    key = key.toLowerCase();\n\n    if (value) {\n      value = value.toLowerCase();\n    }\n\n    map.set(key, value);\n  }\n\n  return map;\n}\n\nfunction getMaxAge(str) {\n  const minimum = 60;\n  const map = parseCacheControl(str);\n\n  if (map) {\n    let age = map.get('s-maxage') || map.get('max-age') || '';\n\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1);\n    }\n\n    const n = parseInt(age, 10);\n\n    if (!isNaN(n)) {\n      return Math.max(n, minimum);\n    }\n  }\n\n  return minimum;\n}","map":{"version":3,"sources":["../../../next-server/server/image-optimizer.ts"],"names":["WEBP","PNG","JPEG","GIF","SVG","CACHE_VERSION","MODERN_TYPES","ANIMATABLE_TYPES","VECTOR_TYPES","imageData","nextConfig","imageConfigDefault","deviceSizes","imageSizes","domains","loader","server","finished","parsedUrl","mimeType","getSupportedMimeType","headers","res","Array","url","href","isAbsolute","hrefParsed","width","parseInt","isNaN","sizes","quality","hash","getHash","imagesDir","hashDir","now","Date","files","promises","file","expireAt","Number","contentType","fsPath","upstreamRes","fetch","upstreamBuffer","Buffer","upstreamType","maxAge","getMaxAge","_req","req","method","resBuffers","mockRes","Stream","chunk","mockHeaders","Object","name","nodeUrl","vector","animate","sendResponse","sharp","require","error","transformer","metaWidth","optimizedBuffer","recursive","extension","etag","filename","accept","String","map","str","directive","key","value","minimum","parseCacheControl","age","n","Math"],"mappings":"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","sourcesContent":["import nodeUrl, { UrlWithParsedQuery } from 'url'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { join } from 'path'\nimport { mediaType } from '@hapi/accept'\nimport { createReadStream, promises } from 'fs'\nimport { createHash } from 'crypto'\nimport Server from './next-server'\nimport { getContentType, getExtension } from './serve-static'\nimport { fileExists } from '../../lib/file-exists'\n// @ts-ignore no types for is-animated\nimport isAnimated from 'next/dist/compiled/is-animated'\nimport Stream from 'stream'\nimport { sendEtagResponse } from './send-payload'\nimport { ImageConfig, imageConfigDefault } from './image-config'\n\nlet sharp: typeof import('sharp')\n//const AVIF = 'image/avif'\nconst WEBP = 'image/webp'\nconst PNG = 'image/png'\nconst JPEG = 'image/jpeg'\nconst GIF = 'image/gif'\nconst SVG = 'image/svg+xml'\nconst CACHE_VERSION = 2\nconst MODERN_TYPES = [/* AVIF, */ WEBP]\nconst ANIMATABLE_TYPES = [WEBP, PNG, GIF]\nconst VECTOR_TYPES = [SVG]\n\nexport async function imageOptimizer(\n  server: Server,\n  req: IncomingMessage,\n  res: ServerResponse,\n  parsedUrl: UrlWithParsedQuery\n) {\n  const { nextConfig, distDir } = server\n  const imageData: ImageConfig = nextConfig.images || imageConfigDefault\n  const { deviceSizes = [], imageSizes = [], domains = [], loader } = imageData\n\n  if (loader !== 'default') {\n    await server.render404(req, res, parsedUrl)\n    return { finished: true }\n  }\n\n  const { headers } = req\n  const { url, w, q } = parsedUrl.query\n  const mimeType = getSupportedMimeType(MODERN_TYPES, headers.accept)\n  let href: string\n\n  if (!url) {\n    res.statusCode = 400\n    res.end('\"url\" parameter is required')\n    return { finished: true }\n  } else if (Array.isArray(url)) {\n    res.statusCode = 400\n    res.end('\"url\" parameter cannot be an array')\n    return { finished: true }\n  }\n\n  let isAbsolute: boolean\n\n  if (url.startsWith('/')) {\n    href = url\n    isAbsolute = false\n  } else {\n    let hrefParsed: URL\n\n    try {\n      hrefParsed = new URL(url)\n      href = hrefParsed.toString()\n      isAbsolute = true\n    } catch (_error) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is invalid')\n      return { finished: true }\n    }\n\n    if (!['http:', 'https:'].includes(hrefParsed.protocol)) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is invalid')\n      return { finished: true }\n    }\n\n    if (!domains.includes(hrefParsed.hostname)) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is not allowed')\n      return { finished: true }\n    }\n  }\n\n  if (!w) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) is required')\n    return { finished: true }\n  } else if (Array.isArray(w)) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) cannot be an array')\n    return { finished: true }\n  }\n\n  if (!q) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) is required')\n    return { finished: true }\n  } else if (Array.isArray(q)) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) cannot be an array')\n    return { finished: true }\n  }\n\n  const width = parseInt(w, 10)\n\n  if (!width || isNaN(width)) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) must be a number greater than 0')\n    return { finished: true }\n  }\n\n  const sizes = [...deviceSizes, ...imageSizes]\n\n  if (!sizes.includes(width)) {\n    res.statusCode = 400\n    res.end(`\"w\" parameter (width) of ${width} is not allowed`)\n    return { finished: true }\n  }\n\n  const quality = parseInt(q)\n\n  if (isNaN(quality) || quality < 1 || quality > 100) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) must be a number between 1 and 100')\n    return { finished: true }\n  }\n\n  const hash = getHash([CACHE_VERSION, href, width, quality, mimeType])\n  const imagesDir = join(distDir, 'cache', 'images')\n  const hashDir = join(imagesDir, hash)\n  const now = Date.now()\n\n  if (await fileExists(hashDir, 'directory')) {\n    const files = await promises.readdir(hashDir)\n    for (let file of files) {\n      const [prefix, etag, extension] = file.split('.')\n      const expireAt = Number(prefix)\n      const contentType = getContentType(extension)\n      const fsPath = join(hashDir, file)\n      if (now < expireAt) {\n        res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate')\n        if (sendEtagResponse(req, res, etag)) {\n          return { finished: true }\n        }\n        if (contentType) {\n          res.setHeader('Content-Type', contentType)\n        }\n        createReadStream(fsPath).pipe(res)\n        return { finished: true }\n      } else {\n        await promises.unlink(fsPath)\n      }\n    }\n  }\n\n  let upstreamBuffer: Buffer\n  let upstreamType: string | null\n  let maxAge: number\n\n  if (isAbsolute) {\n    const upstreamRes = await fetch(href)\n\n    if (!upstreamRes.ok) {\n      res.statusCode = upstreamRes.status\n      res.end('\"url\" parameter is valid but upstream response is invalid')\n      return { finished: true }\n    }\n\n    res.statusCode = upstreamRes.status\n    upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer())\n    upstreamType = upstreamRes.headers.get('Content-Type')\n    maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'))\n  } else {\n    try {\n      const _req: any = {\n        headers: req.headers,\n        method: req.method,\n        url: href,\n      }\n      const resBuffers: Buffer[] = []\n      const mockRes: any = new Stream.Writable()\n\n      mockRes.write = (chunk: Buffer | string) => {\n        resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))\n      }\n      mockRes._write = (chunk: Buffer | string) => {\n        mockRes.write(chunk)\n      }\n\n      const mockHeaders: Record<string, string | string[]> = {}\n\n      mockRes.writeHead = (_status: any, _headers: any) =>\n        Object.assign(mockHeaders, _headers)\n      mockRes.getHeader = (name: string) => mockHeaders[name.toLowerCase()]\n      mockRes.getHeaders = () => mockHeaders\n      mockRes.getHeaderNames = () => Object.keys(mockHeaders)\n      mockRes.setHeader = (name: string, value: string | string[]) =>\n        (mockHeaders[name.toLowerCase()] = value)\n      mockRes._implicitHeader = () => {}\n      mockRes.finished = false\n      mockRes.statusCode = 200\n\n      await server.getRequestHandler()(_req, mockRes, nodeUrl.parse(href, true))\n      res.statusCode = mockRes.statusCode\n\n      upstreamBuffer = Buffer.concat(resBuffers)\n      upstreamType = mockRes.getHeader('Content-Type')\n      maxAge = getMaxAge(mockRes.getHeader('Cache-Control'))\n    } catch (err) {\n      res.statusCode = 500\n      res.end('\"url\" parameter is valid but upstream response is invalid')\n      return { finished: true }\n    }\n  }\n\n  if (upstreamType) {\n    const vector = VECTOR_TYPES.includes(upstreamType)\n    const animate =\n      ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)\n    if (vector || animate) {\n      sendResponse(req, res, upstreamType, upstreamBuffer)\n      return { finished: true }\n    }\n  }\n\n  const expireAt = maxAge * 1000 + now\n  let contentType: string\n\n  if (mimeType) {\n    contentType = mimeType\n  } else if (upstreamType?.startsWith('image/') && getExtension(upstreamType)) {\n    contentType = upstreamType\n  } else {\n    contentType = JPEG\n  }\n\n  if (!sharp) {\n    try {\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      sharp = require('sharp')\n    } catch (error) {\n      if (error.code === 'MODULE_NOT_FOUND') {\n        error.message += '\\n\\nLearn more: https://err.sh/next.js/install-sharp'\n        server.logError(error)\n        sendResponse(req, res, upstreamType, upstreamBuffer)\n        return { finished: true }\n      }\n      throw error\n    }\n  }\n\n  try {\n    const transformer = sharp(upstreamBuffer)\n    transformer.rotate() // auto rotate based on EXIF data\n\n    const { width: metaWidth } = await transformer.metadata()\n\n    if (metaWidth && metaWidth > width) {\n      transformer.resize(width)\n    }\n\n    //if (contentType === AVIF) {\n    // Soon https://github.com/lovell/sharp/issues/2289\n    //}\n    if (contentType === WEBP) {\n      transformer.webp({ quality })\n    } else if (contentType === PNG) {\n      transformer.png({ quality })\n    } else if (contentType === JPEG) {\n      transformer.jpeg({ quality })\n    }\n\n    const optimizedBuffer = await transformer.toBuffer()\n    await promises.mkdir(hashDir, { recursive: true })\n    const extension = getExtension(contentType)\n    const etag = getHash([optimizedBuffer])\n    const filename = join(hashDir, `${expireAt}.${etag}.${extension}`)\n    await promises.writeFile(filename, optimizedBuffer)\n    sendResponse(req, res, contentType, optimizedBuffer)\n  } catch (error) {\n    sendResponse(req, res, upstreamType, upstreamBuffer)\n  }\n\n  return { finished: true }\n}\n\nfunction sendResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  contentType: string | null,\n  buffer: Buffer\n) {\n  const etag = getHash([buffer])\n  res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate')\n  if (sendEtagResponse(req, res, etag)) {\n    return\n  }\n  if (contentType) {\n    res.setHeader('Content-Type', contentType)\n  }\n  res.end(buffer)\n}\n\nfunction getSupportedMimeType(options: string[], accept = ''): string {\n  const mimeType = mediaType(accept, options)\n  return accept.includes(mimeType) ? mimeType : ''\n}\n\nfunction getHash(items: (string | number | Buffer)[]) {\n  const hash = createHash('sha256')\n  for (let item of items) {\n    if (typeof item === 'number') hash.update(String(item))\n    else {\n      hash.update(item)\n    }\n  }\n  // See https://en.wikipedia.org/wiki/Base64#Filenames\n  return hash.digest('base64').replace(/\\//g, '-')\n}\n\nfunction parseCacheControl(str: string | null): Map<string, string> {\n  const map = new Map<string, string>()\n  if (!str) {\n    return map\n  }\n  for (let directive of str.split(',')) {\n    let [key, value] = directive.trim().split('=')\n    key = key.toLowerCase()\n    if (value) {\n      value = value.toLowerCase()\n    }\n    map.set(key, value)\n  }\n  return map\n}\n\nexport function getMaxAge(str: string | null): number {\n  const minimum = 60\n  const map = parseCacheControl(str)\n  if (map) {\n    let age = map.get('s-maxage') || map.get('max-age') || ''\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1)\n    }\n    const n = parseInt(age, 10)\n    if (!isNaN(n)) {\n      return Math.max(n, minimum)\n    }\n  }\n  return minimum\n}\n"]},"metadata":{},"sourceType":"script"}