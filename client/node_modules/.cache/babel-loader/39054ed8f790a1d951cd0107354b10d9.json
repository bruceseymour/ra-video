{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _webpackSources = _interopRequireDefault(require(\"webpack-sources\"));\n\nvar _path = require(\"path\");\n\nvar _getRouteFromEntrypoint = _interopRequireDefault(require(\"../../../next-server/server/get-route-from-entrypoint\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst SSR_MODULE_CACHE_FILENAME = 'ssr-module-cache.js'; // @ts-ignore: TODO: remove ignore when webpack 5 is stable\n\nconst {\n  RawSource\n} = _webpack.default.sources || _webpackSources.default; // By default webpack keeps initialized modules per-module.\n// This means that if you have 2 entrypoints loaded into the same app\n// they will *not* share the same instance\n// This creates many issues when developers / libraries rely on the singleton pattern\n// As this pattern assumes every module will have 1 instance\n// This plugin overrides webpack's code generation step to replace `installedModules`\n// The replacement is a require for a file that's also generated here that only exports an empty object\n// Because of Node.js's single instance modules this makes webpack share all initialized instances\n// Do note that this module is only geared towards the `node` compilation target.\n// For the client side compilation we use `runtimeChunk: 'single'`\n\nclass NextJsSsrImportPlugin {\n  constructor(options) {\n    this.options = void 0;\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const {\n      outputPath\n    } = this.options;\n    compiler.hooks.emit.tapAsync('NextJsSSRModuleCache', (compilation, callback) => {\n      compilation.assets[SSR_MODULE_CACHE_FILENAME] = new RawSource(`\n      /* This cache is used by webpack for instantiated modules */\n      module.exports = {}\n      `);\n      callback();\n    });\n    compiler.hooks.compilation.tap('NextJsSSRModuleCache', compilation => {\n      compilation.mainTemplate.hooks.localVars.intercept({\n        register(tapInfo) {\n          if (tapInfo.name === 'MainTemplate') {\n            const originalFn = tapInfo.fn;\n\n            tapInfo.fn = (source, chunk) => {\n              // If the chunk is not part of the pages directory we have to keep the original behavior,\n              // otherwise webpack will error out when the file is used before the compilation finishes\n              // this is the case with mini-css-extract-plugin\n              if (!(0, _getRouteFromEntrypoint.default)(chunk.name)) {\n                return originalFn(source, chunk);\n              }\n\n              const pagePath = (0, _path.join)(outputPath, (0, _path.dirname)(chunk.name));\n              let relativePathToBaseDir = (0, _path.relative)(pagePath, (0, _path.join)(outputPath, SSR_MODULE_CACHE_FILENAME)); // Make sure even in windows, the path looks like in unix\n              // Node.js require system will convert it accordingly\n\n              const relativePathToBaseDirNormalized = relativePathToBaseDir.replace(/\\\\/g, '/');\n              return _webpack.default.Template.asString([source, '// The module cache', `var installedModules = require('${relativePathToBaseDirNormalized}');`]);\n            };\n          }\n\n          return tapInfo;\n        }\n\n      });\n    });\n  }\n\n}\n\nexports.default = NextJsSsrImportPlugin;","map":{"version":3,"sources":["../../../../build/webpack/plugins/nextjs-ssr-module-cache.ts"],"names":["SSR_MODULE_CACHE_FILENAME","webpack","sources","NextJsSsrImportPlugin","options","constructor","apply","callback","compiler","compilation","register","tapInfo","originalFn","chunk","pagePath","relativePathToBaseDir","relativePathToBaseDirNormalized"],"mappings":";;;;;AAAA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,IAAA,eAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,uBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,uDAAA,CAAA,CAAA;;;;;;AACA;;AAAA,MAAMA,yBAAyB,GAA/B,qBAAA,C,CAEA;;AACA,MAAM;AAAA,EAAA;AAAA,IAAgBC,QAAAA,CAAAA,OAAAA,CAAAA,OAAAA,IAAmBC,eAAAA,CAAzC,OAAA,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACe,MAAMC,qBAAN,CAA4B;AAGzCE,EAAAA,WAAW,CAAA,OAAA,EAAkC;AAAA,SAFrCD,OAEqC,GAAA,KAAA,CAAA;AAC3C,SAAA,OAAA,GAAA,OAAA;AAEFE;;AAAAA,EAAAA,KAAK,CAAA,QAAA,EAA6B;AAChC,UAAM;AAAA,MAAA;AAAA,QAAiB,KAAvB,OAAA;AACA,IAAA,QAAQ,CAAR,KAAA,CAAA,IAAA,CAAA,QAAA,CAAA,sBAAA,EAEE,CAAA,WAAA,EAAA,QAAA,KAA2B;AACzB,MAAA,WAAW,CAAX,MAAA,CAAA,yBAAA,IAAgD,IAAA,SAAA,CAAe;AACvE;AACA;AAFQ,OAAgD,CAAhD;AAIAC,MAAAA,QAAQ;AAPZ,KAAA;AAUAC,IAAAA,QAAQ,CAARA,KAAAA,CAAAA,WAAAA,CAAAA,GAAAA,CAAAA,sBAAAA,EAEGC,WAAD,IAAsB;AACpBA,MAAAA,WAAW,CAAXA,YAAAA,CAAAA,KAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CAAmD;AACjDC,QAAAA,QAAQ,CAAA,OAAA,EAAe;AACrB,cAAIC,OAAO,CAAPA,IAAAA,KAAJ,cAAA,EAAqC;AACnC,kBAAMC,UAAU,GAAGD,OAAO,CAA1B,EAAA;;AACAA,YAAAA,OAAO,CAAPA,EAAAA,GAAa,CAAA,MAAA,EAAA,KAAA,KAA6B;AACxC;AACA;AACA;AAEA,kBAAI,CAAC,CAAA,GAAA,uBAAA,CAAA,OAAA,EAAuBE,KAAK,CAAjC,IAAK,CAAL,EAAyC;AACvC,uBAAOD,UAAU,CAAA,MAAA,EAAjB,KAAiB,CAAjB;AAEF;;AAAA,oBAAME,QAAQ,GAAG,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,UAAA,EAAiB,CAAA,GAAA,KAAA,CAAA,OAAA,EAAQD,KAAK,CAA/C,IAAkC,CAAjB,CAAjB;AACA,kBAAIE,qBAAqB,GAAG,CAAA,GAAA,KAAA,CAAA,QAAA,EAAA,QAAA,EAE1B,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,UAAA,EAFF,yBAEE,CAF0B,CAA5B,CATwC,CAcxC;AACA;;AACA,oBAAMC,+BAA+B,GAAGD,qBAAqB,CAArBA,OAAAA,CAAAA,KAAAA,EAAxC,GAAwCA,CAAxC;AAIA,qBAAQd,QAAAA,CAAD,OAACA,CAAD,QAACA,CAAD,QAACA,CAAkC,CAAA,MAAA,EAAA,qBAAA,EAGvC,mCAAkCe,+BAHrC,KAA0C,CAAlCf,CAAR;AApBFU,aAAAA;AA2BF;;AAAA,iBAAA,OAAA;AA/BJF;;AAAmD,OAAnDA;AAHJD,KAAAA;AAlBuC;;AAAA","sourcesContent":["import webpack from 'webpack'\nimport sources from 'webpack-sources'\nimport { join, relative, dirname } from 'path'\nimport getRouteFromEntrypoint from '../../../next-server/server/get-route-from-entrypoint'\nconst SSR_MODULE_CACHE_FILENAME = 'ssr-module-cache.js'\n\n// @ts-ignore: TODO: remove ignore when webpack 5 is stable\nconst { RawSource } = webpack.sources || sources\n\n// By default webpack keeps initialized modules per-module.\n// This means that if you have 2 entrypoints loaded into the same app\n// they will *not* share the same instance\n// This creates many issues when developers / libraries rely on the singleton pattern\n// As this pattern assumes every module will have 1 instance\n// This plugin overrides webpack's code generation step to replace `installedModules`\n// The replacement is a require for a file that's also generated here that only exports an empty object\n// Because of Node.js's single instance modules this makes webpack share all initialized instances\n// Do note that this module is only geared towards the `node` compilation target.\n// For the client side compilation we use `runtimeChunk: 'single'`\nexport default class NextJsSsrImportPlugin {\n  private options: { outputPath: string }\n\n  constructor(options: { outputPath: string }) {\n    this.options = options\n  }\n  apply(compiler: webpack.Compiler) {\n    const { outputPath } = this.options\n    compiler.hooks.emit.tapAsync(\n      'NextJsSSRModuleCache',\n      (compilation, callback) => {\n        compilation.assets[SSR_MODULE_CACHE_FILENAME] = new RawSource(`\n      /* This cache is used by webpack for instantiated modules */\n      module.exports = {}\n      `)\n        callback()\n      }\n    )\n    compiler.hooks.compilation.tap(\n      'NextJsSSRModuleCache',\n      (compilation: any) => {\n        compilation.mainTemplate.hooks.localVars.intercept({\n          register(tapInfo: any) {\n            if (tapInfo.name === 'MainTemplate') {\n              const originalFn = tapInfo.fn\n              tapInfo.fn = (source: any, chunk: any) => {\n                // If the chunk is not part of the pages directory we have to keep the original behavior,\n                // otherwise webpack will error out when the file is used before the compilation finishes\n                // this is the case with mini-css-extract-plugin\n\n                if (!getRouteFromEntrypoint(chunk.name)) {\n                  return originalFn(source, chunk)\n                }\n                const pagePath = join(outputPath, dirname(chunk.name))\n                let relativePathToBaseDir = relative(\n                  pagePath,\n                  join(outputPath, SSR_MODULE_CACHE_FILENAME)\n                )\n\n                // Make sure even in windows, the path looks like in unix\n                // Node.js require system will convert it accordingly\n                const relativePathToBaseDirNormalized = relativePathToBaseDir.replace(\n                  /\\\\/g,\n                  '/'\n                )\n                return (webpack as any).Template.asString([\n                  source,\n                  '// The module cache',\n                  `var installedModules = require('${relativePathToBaseDirNormalized}');`,\n                ])\n              }\n            }\n            return tapInfo\n          },\n        })\n      }\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}