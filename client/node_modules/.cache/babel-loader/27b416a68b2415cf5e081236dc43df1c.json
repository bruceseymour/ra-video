{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.route = void 0;\n\nvar _pathMatch = _interopRequireDefault(require(\"../lib/router/utils/path-match\"));\n\nvar _normalizeTrailingSlash = require(\"../../client/normalize-trailing-slash\");\n\nvar _normalizeLocalePath = require(\"../lib/i18n/normalize-locale-path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst route = (0, _pathMatch.default)();\nexports.route = route;\nconst customRouteTypes = new Set(['rewrite', 'redirect', 'header']);\n\nfunction replaceBasePath(basePath, pathname) {\n  // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n  return pathname.replace(basePath, '') || '/';\n}\n\nclass Router {\n  constructor({\n    basePath = '',\n    headers = [],\n    fsRoutes = [],\n    rewrites = [],\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n    locales = []\n  }) {\n    this.basePath = void 0;\n    this.headers = void 0;\n    this.fsRoutes = void 0;\n    this.rewrites = void 0;\n    this.redirects = void 0;\n    this.catchAllRoute = void 0;\n    this.pageChecker = void 0;\n    this.dynamicRoutes = void 0;\n    this.useFileSystemPublicRoutes = void 0;\n    this.locales = void 0;\n    this.basePath = basePath;\n    this.headers = headers;\n    this.fsRoutes = fsRoutes;\n    this.rewrites = rewrites;\n    this.redirects = redirects;\n    this.pageChecker = pageChecker;\n    this.catchAllRoute = catchAllRoute;\n    this.dynamicRoutes = dynamicRoutes;\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes;\n    this.locales = locales;\n  }\n\n  setDynamicRoutes(routes = []) {\n    this.dynamicRoutes = routes;\n  }\n\n  addFsRoute(fsRoute) {\n    this.fsRoutes.unshift(fsRoute);\n  }\n\n  async execute(req, res, parsedUrl) {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks = {};\n\n    const memoizedPageChecker = async p => {\n      p = (0, _normalizeLocalePath.normalizeLocalePath)(p, this.locales).pathname;\n\n      if (pageChecks[p]) {\n        return pageChecks[p];\n      }\n\n      const result = this.pageChecker(p);\n      pageChecks[p] = result;\n      return result;\n    };\n\n    let parsedUrlUpdated = parsedUrl;\n    /*\n    Desired routes order\n    - headers\n    - redirects\n    - Check filesystem (including pages), if nothing found continue\n    - User rewrites (checking filesystem and pages each match)\n    */\n\n    const allRoutes = [...this.headers, ...this.redirects, ...this.fsRoutes, // We only check the catch-all route if public page routes hasn't been\n    // disabled\n    ...(this.useFileSystemPublicRoutes ? [{\n      type: 'route',\n      name: 'page checker',\n      requireBasePath: false,\n      match: route('/:path*'),\n      fn: async (checkerReq, checkerRes, params, parsedCheckerUrl) => {\n        let {\n          pathname\n        } = parsedCheckerUrl;\n        pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname || '/');\n\n        if (!pathname) {\n          return {\n            finished: false\n          };\n        }\n\n        if (await memoizedPageChecker(pathname)) {\n          return this.catchAllRoute.fn(checkerReq, checkerRes, params, parsedCheckerUrl);\n        }\n\n        return {\n          finished: false\n        };\n      }\n    }] : []), ...this.rewrites, // We only check the catch-all route if public page routes hasn't been\n    // disabled\n    ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : [])];\n    const originallyHadBasePath = !this.basePath || req._nextHadBasePath;\n\n    for (const testRoute of allRoutes) {\n      // if basePath is being used, the basePath will still be included\n      // in the pathname here to allow custom-routes to require containing\n      // it or not, filesystem routes and pages must always include the basePath\n      // if it is set\n      let currentPathname = parsedUrlUpdated.pathname;\n      const originalPathname = currentPathname;\n      const requireBasePath = testRoute.requireBasePath !== false;\n      const isCustomRoute = customRouteTypes.has(testRoute.type);\n      const isPublicFolderCatchall = testRoute.name === 'public folder catchall';\n      const keepBasePath = isCustomRoute || isPublicFolderCatchall;\n      const keepLocale = isCustomRoute;\n      const currentPathnameNoBasePath = replaceBasePath(this.basePath, currentPathname);\n\n      if (!keepBasePath) {\n        currentPathname = currentPathnameNoBasePath;\n      }\n\n      const localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(currentPathnameNoBasePath, this.locales);\n      const activeBasePath = keepBasePath ? this.basePath : '';\n\n      if (keepLocale) {\n        if (!testRoute.internal && parsedUrl.query.__nextLocale && !localePathResult.detectedLocale) {\n          currentPathname = `${activeBasePath}/${parsedUrl.query.__nextLocale}${currentPathnameNoBasePath === '/' ? '' : currentPathnameNoBasePath}`;\n        }\n\n        if (req.__nextHadTrailingSlash && !currentPathname.endsWith('/')) {\n          currentPathname += '/';\n        }\n      } else {\n        currentPathname = `${req._nextHadBasePath ? activeBasePath : ''}${activeBasePath && localePathResult.pathname === '/' ? '' : localePathResult.pathname}`;\n      }\n\n      const newParams = testRoute.match(currentPathname); // Check if the match function matched\n\n      if (newParams) {\n        // since we require basePath be present for non-custom-routes we\n        // 404 here when we matched an fs route\n        if (!keepBasePath) {\n          if (!originallyHadBasePath && !req._nextDidRewrite) {\n            if (requireBasePath) {\n              // consider this a non-match so the 404 renders\n              return false;\n            } // page checker occurs before rewrites so we need to continue\n            // to check those since they don't always require basePath\n\n\n            continue;\n          }\n\n          parsedUrlUpdated.pathname = currentPathname;\n        }\n\n        const result = await testRoute.fn(req, res, newParams, parsedUrlUpdated); // The response was handled\n\n        if (result.finished) {\n          return true;\n        } // since the fs route didn't match we need to re-add the basePath\n        // to continue checking rewrites with the basePath present\n\n\n        if (!keepBasePath) {\n          parsedUrlUpdated.pathname = originalPathname;\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname;\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = { ...parsedUrlUpdated.query,\n            ...result.query\n          };\n        } // check filesystem\n\n\n        if (testRoute.check === true) {\n          const originalFsPathname = parsedUrlUpdated.pathname;\n          const fsPathname = replaceBasePath(this.basePath, originalFsPathname);\n\n          for (const fsRoute of this.fsRoutes) {\n            const fsParams = fsRoute.match(fsPathname);\n\n            if (fsParams) {\n              parsedUrlUpdated.pathname = fsPathname;\n              const fsResult = await fsRoute.fn(req, res, fsParams, parsedUrlUpdated);\n\n              if (fsResult.finished) {\n                return true;\n              }\n\n              parsedUrlUpdated.pathname = originalFsPathname;\n            }\n          }\n\n          let matchedPage = await memoizedPageChecker(fsPathname); // If we didn't match a page check dynamic routes\n\n          if (!matchedPage) {\n            for (const dynamicRoute of this.dynamicRoutes) {\n              if (dynamicRoute.match(fsPathname)) {\n                matchedPage = true;\n              }\n            }\n          } // Matched a page or dynamic route so render it using catchAllRoute\n\n\n          if (matchedPage) {\n            parsedUrlUpdated.pathname = fsPathname;\n            const pageParams = this.catchAllRoute.match(parsedUrlUpdated.pathname);\n            await this.catchAllRoute.fn(req, res, pageParams, parsedUrlUpdated);\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.default = Router;","map":{"version":3,"sources":["../../../next-server/server/router.ts"],"names":["route","customRouteTypes","pathname","Router","basePath","headers","fsRoutes","rewrites","redirects","catchAllRoute","pageChecker","dynamicRoutes","useFileSystemPublicRoutes","locales","constructor","setDynamicRoutes","routes","addFsRoute","pageChecks","memoizedPageChecker","p","result","parsedUrlUpdated","allRoutes","type","name","requireBasePath","match","fn","finished","originallyHadBasePath","req","currentPathname","originalPathname","testRoute","isCustomRoute","isPublicFolderCatchall","keepBasePath","keepLocale","currentPathnameNoBasePath","replaceBasePath","localePathResult","activeBasePath","parsedUrl","__nextLocale","newParams","originalFsPathname","fsPathname","fsParams","fsRoute","fsResult","matchedPage","dynamicRoute","pageParams"],"mappings":"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","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { UrlWithParsedQuery } from 'url'\n\nimport pathMatch from '../lib/router/utils/path-match'\nimport { removePathTrailingSlash } from '../../client/normalize-trailing-slash'\nimport { normalizeLocalePath } from '../lib/i18n/normalize-locale-path'\n\nexport const route = pathMatch()\n\nexport type Params = { [param: string]: any }\n\nexport type RouteMatch = (pathname: string | null | undefined) => false | Params\n\ntype RouteResult = {\n  finished: boolean\n  pathname?: string\n  query?: { [k: string]: string }\n}\n\nexport type Route = {\n  match: RouteMatch\n  type: string\n  check?: boolean\n  statusCode?: number\n  name: string\n  requireBasePath?: false\n  internal?: true\n  fn: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ) => Promise<RouteResult> | RouteResult\n}\n\nexport type DynamicRoutes = Array<{ page: string; match: RouteMatch }>\n\nexport type PageChecker = (pathname: string) => Promise<boolean>\n\nconst customRouteTypes = new Set(['rewrite', 'redirect', 'header'])\n\nfunction replaceBasePath(basePath: string, pathname: string) {\n  // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n  return pathname!.replace(basePath, '') || '/'\n}\n\nexport default class Router {\n  basePath: string\n  headers: Route[]\n  fsRoutes: Route[]\n  rewrites: Route[]\n  redirects: Route[]\n  catchAllRoute: Route\n  pageChecker: PageChecker\n  dynamicRoutes: DynamicRoutes\n  useFileSystemPublicRoutes: boolean\n  locales: string[]\n\n  constructor({\n    basePath = '',\n    headers = [],\n    fsRoutes = [],\n    rewrites = [],\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n    locales = [],\n  }: {\n    basePath: string\n    headers: Route[]\n    fsRoutes: Route[]\n    rewrites: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    dynamicRoutes: DynamicRoutes | undefined\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    locales: string[]\n  }) {\n    this.basePath = basePath\n    this.headers = headers\n    this.fsRoutes = fsRoutes\n    this.rewrites = rewrites\n    this.redirects = redirects\n    this.pageChecker = pageChecker\n    this.catchAllRoute = catchAllRoute\n    this.dynamicRoutes = dynamicRoutes\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes\n    this.locales = locales\n  }\n\n  setDynamicRoutes(routes: DynamicRoutes = []) {\n    this.dynamicRoutes = routes\n  }\n\n  addFsRoute(fsRoute: Route) {\n    this.fsRoutes.unshift(fsRoute)\n  }\n\n  async execute(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks: { [name: string]: Promise<boolean> } = {}\n    const memoizedPageChecker = async (p: string): Promise<boolean> => {\n      p = normalizeLocalePath(p, this.locales).pathname\n\n      if (pageChecks[p]) {\n        return pageChecks[p]\n      }\n      const result = this.pageChecker(p)\n      pageChecks[p] = result\n      return result\n    }\n\n    let parsedUrlUpdated = parsedUrl\n\n    /*\n      Desired routes order\n      - headers\n      - redirects\n      - Check filesystem (including pages), if nothing found continue\n      - User rewrites (checking filesystem and pages each match)\n    */\n\n    const allRoutes = [\n      ...this.headers,\n      ...this.redirects,\n      ...this.fsRoutes,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes\n        ? [\n            {\n              type: 'route',\n              name: 'page checker',\n              requireBasePath: false,\n              match: route('/:path*'),\n              fn: async (checkerReq, checkerRes, params, parsedCheckerUrl) => {\n                let { pathname } = parsedCheckerUrl\n                pathname = removePathTrailingSlash(pathname || '/')\n\n                if (!pathname) {\n                  return { finished: false }\n                }\n\n                if (await memoizedPageChecker(pathname)) {\n                  return this.catchAllRoute.fn(\n                    checkerReq,\n                    checkerRes,\n                    params,\n                    parsedCheckerUrl\n                  )\n                }\n                return { finished: false }\n              },\n            } as Route,\n          ]\n        : []),\n      ...this.rewrites,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : []),\n    ]\n    const originallyHadBasePath =\n      !this.basePath || (req as any)._nextHadBasePath\n\n    for (const testRoute of allRoutes) {\n      // if basePath is being used, the basePath will still be included\n      // in the pathname here to allow custom-routes to require containing\n      // it or not, filesystem routes and pages must always include the basePath\n      // if it is set\n      let currentPathname = parsedUrlUpdated.pathname as string\n      const originalPathname = currentPathname\n      const requireBasePath = testRoute.requireBasePath !== false\n      const isCustomRoute = customRouteTypes.has(testRoute.type)\n      const isPublicFolderCatchall = testRoute.name === 'public folder catchall'\n      const keepBasePath = isCustomRoute || isPublicFolderCatchall\n      const keepLocale = isCustomRoute\n\n      const currentPathnameNoBasePath = replaceBasePath(\n        this.basePath,\n        currentPathname\n      )\n\n      if (!keepBasePath) {\n        currentPathname = currentPathnameNoBasePath\n      }\n\n      const localePathResult = normalizeLocalePath(\n        currentPathnameNoBasePath,\n        this.locales\n      )\n      const activeBasePath = keepBasePath ? this.basePath : ''\n\n      if (keepLocale) {\n        if (\n          !testRoute.internal &&\n          parsedUrl.query.__nextLocale &&\n          !localePathResult.detectedLocale\n        ) {\n          currentPathname = `${activeBasePath}/${parsedUrl.query.__nextLocale}${\n            currentPathnameNoBasePath === '/' ? '' : currentPathnameNoBasePath\n          }`\n        }\n\n        if (\n          (req as any).__nextHadTrailingSlash &&\n          !currentPathname.endsWith('/')\n        ) {\n          currentPathname += '/'\n        }\n      } else {\n        currentPathname = `${\n          (req as any)._nextHadBasePath ? activeBasePath : ''\n        }${\n          activeBasePath && localePathResult.pathname === '/'\n            ? ''\n            : localePathResult.pathname\n        }`\n      }\n\n      const newParams = testRoute.match(currentPathname)\n\n      // Check if the match function matched\n      if (newParams) {\n        // since we require basePath be present for non-custom-routes we\n        // 404 here when we matched an fs route\n        if (!keepBasePath) {\n          if (!originallyHadBasePath && !(req as any)._nextDidRewrite) {\n            if (requireBasePath) {\n              // consider this a non-match so the 404 renders\n              return false\n            }\n            // page checker occurs before rewrites so we need to continue\n            // to check those since they don't always require basePath\n            continue\n          }\n\n          parsedUrlUpdated.pathname = currentPathname\n        }\n\n        const result = await testRoute.fn(req, res, newParams, parsedUrlUpdated)\n\n        // The response was handled\n        if (result.finished) {\n          return true\n        }\n\n        // since the fs route didn't match we need to re-add the basePath\n        // to continue checking rewrites with the basePath present\n        if (!keepBasePath) {\n          parsedUrlUpdated.pathname = originalPathname\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = {\n            ...parsedUrlUpdated.query,\n            ...result.query,\n          }\n        }\n\n        // check filesystem\n        if (testRoute.check === true) {\n          const originalFsPathname = parsedUrlUpdated.pathname\n          const fsPathname = replaceBasePath(this.basePath, originalFsPathname!)\n\n          for (const fsRoute of this.fsRoutes) {\n            const fsParams = fsRoute.match(fsPathname)\n\n            if (fsParams) {\n              parsedUrlUpdated.pathname = fsPathname\n\n              const fsResult = await fsRoute.fn(\n                req,\n                res,\n                fsParams,\n                parsedUrlUpdated\n              )\n\n              if (fsResult.finished) {\n                return true\n              }\n\n              parsedUrlUpdated.pathname = originalFsPathname\n            }\n          }\n\n          let matchedPage = await memoizedPageChecker(fsPathname)\n\n          // If we didn't match a page check dynamic routes\n          if (!matchedPage) {\n            for (const dynamicRoute of this.dynamicRoutes) {\n              if (dynamicRoute.match(fsPathname)) {\n                matchedPage = true\n              }\n            }\n          }\n\n          // Matched a page or dynamic route so render it using catchAllRoute\n          if (matchedPage) {\n            parsedUrlUpdated.pathname = fsPathname\n\n            const pageParams = this.catchAllRoute.match(\n              parsedUrlUpdated.pathname\n            )\n\n            await this.catchAllRoute.fn(\n              req,\n              res,\n              pageParams as Params,\n              parsedUrlUpdated\n            )\n            return true\n          }\n        }\n      }\n    }\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}