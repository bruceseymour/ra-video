{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.ReactSyncScriptsConformanceCheck = exports.MinificationConformanceCheck = exports.GranularChunksConformanceCheck = exports.DuplicatePolyfillsConformanceCheck = void 0;\n\nvar _recast = require(\"next/dist/compiled/recast\");\n\nvar _TestInterface = require(\"./TestInterface\");\n\nvar _duplicatePolyfillsConformanceCheck = require(\"./checks/duplicate-polyfills-conformance-check\");\n\nexports.DuplicatePolyfillsConformanceCheck = _duplicatePolyfillsConformanceCheck.DuplicatePolyfillsConformanceCheck;\n\nvar _granularChunksConformance = require(\"./checks/granular-chunks-conformance\");\n\nexports.GranularChunksConformanceCheck = _granularChunksConformance.GranularChunksConformanceCheck;\n\nvar _minificationConformanceCheck = require(\"./checks/minification-conformance-check\");\n\nexports.MinificationConformanceCheck = _minificationConformanceCheck.MinificationConformanceCheck;\n\nvar _reactSyncScriptsConformanceCheck = require(\"./checks/react-sync-scripts-conformance-check\");\n\nexports.ReactSyncScriptsConformanceCheck = _reactSyncScriptsConformanceCheck.ReactSyncScriptsConformanceCheck; // eslint-disable-next-line import/no-extraneous-dependencies\n\nclass WebpackConformancePlugin {\n  constructor(options) {\n    this.tests = void 0;\n    this.errors = void 0;\n    this.warnings = void 0;\n    this.compiler = void 0;\n\n    this.buildStartedHandler = (_compilation, callback) => {\n      const buildStartedResults = this.tests.map(test => {\n        if (test.buildStared && this.compiler) {\n          return test.buildStared(this.compiler.options);\n        }\n\n        return {\n          result: _TestInterface.IConformanceTestStatus.SUCCESS\n        };\n      });\n      this.gatherResults(buildStartedResults);\n      callback();\n    };\n\n    this.buildCompletedHandler = (compilation, cb) => {\n      const buildCompletedResults = this.tests.map(test => {\n        if (test.buildCompleted) {\n          return test.buildCompleted(compilation.assets);\n        }\n\n        return {\n          result: _TestInterface.IConformanceTestStatus.SUCCESS\n        };\n      });\n      this.gatherResults(buildCompletedResults);\n      compilation.errors.push(...this.errors);\n      compilation.warnings.push(...this.warnings);\n      cb();\n    };\n\n    this.parserHandler = factory => {\n      const JS_TYPES = ['auto', 'esm', 'dynamic'];\n      const collectedVisitors = new Map(); // Collect all interested visitors from all tests.\n\n      this.tests.forEach(test => {\n        if (test.getAstNode) {\n          const getAstNodeCallbacks = test.getAstNode();\n          getAstNodeCallbacks.forEach(result => {\n            if (!collectedVisitors.has(result.visitor)) {\n              collectedVisitors.set(result.visitor, []);\n            }\n\n            ;\n            collectedVisitors.get(result.visitor).push(result.inspectNode);\n          });\n        }\n      }); // Do an extra walk per module and add interested visitors to the walk.\n\n      for (const type of JS_TYPES) {\n        factory.hooks.parser.for('javascript/' + type).tap(this.constructor.name, parser => {\n          parser.hooks.program.tap(this.constructor.name, ast => {\n            const visitors = {};\n            const that = this;\n\n            for (const visitorKey of collectedVisitors.keys()) {\n              visitors[visitorKey] = function (path) {\n                const callbacks = collectedVisitors.get(visitorKey) || [];\n                callbacks.forEach(cb => {\n                  if (!cb) {\n                    return;\n                  }\n\n                  const {\n                    request\n                  } = parser.state.module;\n                  const outcome = cb(path, {\n                    request\n                  });\n                  that.gatherResults([outcome]);\n                });\n                this.traverse(path);\n                return false;\n              };\n            }\n\n            (0, _recast.visit)(ast, visitors);\n          });\n        });\n      }\n    };\n\n    this.tests = [];\n\n    if (options.tests) {\n      this.tests.push(...options.tests);\n    }\n\n    this.errors = [];\n    this.warnings = [];\n  }\n\n  gatherResults(results) {\n    results.forEach(result => {\n      if (result.result === _TestInterface.IConformanceTestStatus.FAILED) {\n        result.errors && this.errors.push(...result.errors);\n        result.warnings && this.warnings.push(...result.warnings);\n      }\n    });\n  }\n\n  apply(compiler) {\n    this.compiler = compiler;\n    compiler.hooks.make.tapAsync(this.constructor.name, this.buildStartedHandler);\n    compiler.hooks.emit.tapAsync(this.constructor.name, this.buildCompletedHandler);\n    compiler.hooks.normalModuleFactory.tap(this.constructor.name, this.parserHandler);\n  }\n\n}\n\nexports.default = WebpackConformancePlugin;","map":{"version":3,"sources":["../../../../../build/webpack/plugins/webpack-conformance-plugin/index.ts"],"names":["WebpackConformancePlugin","tests","errors","warnings","compiler","constructor","options","gatherResults","results","result","IConformanceTestStatus","buildStartedResults","test","callback","buildCompletedResults","compilation","cb","factory","JS_TYPES","collectedVisitors","getAstNodeCallbacks","parser","ast","visitors","that","callbacks","outcome","apply"],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nimport { NodePath } from 'ast-types/lib/node-path'\nimport { visit } from 'next/dist/compiled/recast'\nimport { compilation as CompilationType, Compiler } from 'webpack'\nimport {\n  IConformanceAnomaly,\n  IConformanceTestResult,\n  IConformanceTestStatus,\n  IGetAstNodeResult,\n  IWebpackConformanceTest,\n  NodeInspector,\n} from './TestInterface'\n\nexport { DuplicatePolyfillsConformanceCheck } from './checks/duplicate-polyfills-conformance-check'\nexport { GranularChunksConformanceCheck } from './checks/granular-chunks-conformance'\nexport { MinificationConformanceCheck } from './checks/minification-conformance-check'\nexport { ReactSyncScriptsConformanceCheck } from './checks/react-sync-scripts-conformance-check'\n\nexport interface IWebpackConformancePluginOptions {\n  tests: IWebpackConformanceTest[]\n}\n\ninterface VisitorMap {\n  [key: string]: (path: NodePath) => void\n}\n\nexport default class WebpackConformancePlugin {\n  private tests: IWebpackConformanceTest[]\n  private errors: Array<IConformanceAnomaly>\n  private warnings: Array<IConformanceAnomaly>\n  private compiler?: Compiler\n\n  constructor(options: IWebpackConformancePluginOptions) {\n    this.tests = []\n    if (options.tests) {\n      this.tests.push(...options.tests)\n    }\n    this.errors = []\n    this.warnings = []\n  }\n\n  private gatherResults(results: Array<IConformanceTestResult>): void {\n    results.forEach((result) => {\n      if (result.result === IConformanceTestStatus.FAILED) {\n        result.errors && this.errors.push(...result.errors)\n        result.warnings && this.warnings.push(...result.warnings)\n      }\n    })\n  }\n\n  private buildStartedHandler = (\n    _compilation: CompilationType.Compilation,\n    callback: () => void\n  ) => {\n    const buildStartedResults: IConformanceTestResult[] = this.tests.map(\n      (test) => {\n        if (test.buildStared && this.compiler) {\n          return test.buildStared(this.compiler.options)\n        }\n        return {\n          result: IConformanceTestStatus.SUCCESS,\n        } as IConformanceTestResult\n      }\n    )\n\n    this.gatherResults(buildStartedResults)\n    callback()\n  }\n\n  private buildCompletedHandler = (\n    compilation: CompilationType.Compilation,\n    cb: () => void\n  ): void => {\n    const buildCompletedResults: IConformanceTestResult[] = this.tests.map(\n      (test) => {\n        if (test.buildCompleted) {\n          return test.buildCompleted(compilation.assets)\n        }\n        return {\n          result: IConformanceTestStatus.SUCCESS,\n        } as IConformanceTestResult\n      }\n    )\n\n    this.gatherResults(buildCompletedResults)\n    compilation.errors.push(...this.errors)\n    compilation.warnings.push(...this.warnings)\n    cb()\n  }\n\n  private parserHandler = (\n    factory: CompilationType.NormalModuleFactory\n  ): void => {\n    const JS_TYPES = ['auto', 'esm', 'dynamic']\n    const collectedVisitors: Map<string, [NodeInspector?]> = new Map()\n    // Collect all interested visitors from all tests.\n    this.tests.forEach((test) => {\n      if (test.getAstNode) {\n        const getAstNodeCallbacks: IGetAstNodeResult[] = test.getAstNode()\n        getAstNodeCallbacks.forEach((result) => {\n          if (!collectedVisitors.has(result.visitor)) {\n            collectedVisitors.set(result.visitor, [])\n          }\n          ;(collectedVisitors.get(result.visitor) as NodeInspector[]).push(\n            result.inspectNode\n          )\n        })\n      }\n    })\n\n    // Do an extra walk per module and add interested visitors to the walk.\n    for (const type of JS_TYPES) {\n      factory.hooks.parser\n        .for('javascript/' + type)\n        .tap(this.constructor.name, (parser: any) => {\n          parser.hooks.program.tap(this.constructor.name, (ast: any) => {\n            const visitors: VisitorMap = {}\n            const that = this\n            for (const visitorKey of collectedVisitors.keys()) {\n              visitors[visitorKey] = function (path: NodePath) {\n                const callbacks = collectedVisitors.get(visitorKey) || []\n                callbacks.forEach((cb) => {\n                  if (!cb) {\n                    return\n                  }\n                  const { request } = parser.state.module\n                  const outcome = cb(path, { request })\n                  that.gatherResults([outcome])\n                })\n                this.traverse(path)\n                return false\n              }\n            }\n            visit(ast, visitors)\n          })\n        })\n    }\n  }\n\n  public apply(compiler: Compiler) {\n    this.compiler = compiler\n    compiler.hooks.make.tapAsync(\n      this.constructor.name,\n      this.buildStartedHandler\n    )\n    compiler.hooks.emit.tapAsync(\n      this.constructor.name,\n      this.buildCompletedHandler\n    )\n    compiler.hooks.normalModuleFactory.tap(\n      this.constructor.name,\n      this.parserHandler\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}