{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.store = void 0;\n\nvar _unistore = _interopRequireDefault(require(\"next/dist/compiled/unistore\"));\n\nvar _stripAnsi = _interopRequireDefault(require(\"next/dist/compiled/strip-ansi\"));\n\nvar Log = _interopRequireWildcard(require(\"./log\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst store = (0, _unistore.default)({\n  appUrl: null,\n  bootstrap: true\n});\nexports.store = store;\nlet lastStore = {\n  appUrl: null,\n  bootstrap: true\n};\n\nfunction hasStoreChanged(nextStore) {\n  if ([...new Set([...Object.keys(lastStore), ...Object.keys(nextStore)])].every(key => Object.is(lastStore[key], nextStore[key]))) {\n    return false;\n  }\n\n  lastStore = nextStore;\n  return true;\n}\n\nstore.subscribe(state => {\n  if (!hasStoreChanged(state)) {\n    return;\n  }\n\n  if (state.bootstrap) {\n    if (state.appUrl) {\n      Log.ready(`started server on ${state.appUrl}`);\n    }\n\n    return;\n  }\n\n  if (state.loading) {\n    Log.wait('compiling...');\n    return;\n  }\n\n  if (state.errors) {\n    Log.error(state.errors[0]);\n    const cleanError = (0, _stripAnsi.default)(state.errors[0]);\n\n    if (cleanError.indexOf('SyntaxError') > -1) {\n      const matches = cleanError.match(/\\[.*\\]=/);\n\n      if (matches) {\n        for (const match of matches) {\n          const prop = (match.split(']').shift() || '').substr(1);\n          console.log(`AMP bind syntax [${prop}]='' is not supported in JSX, use 'data-amp-bind-${prop}' instead. https://err.sh/vercel/next.js/amp-bind-jsx-alt`);\n        }\n\n        return;\n      }\n    }\n\n    return;\n  }\n\n  if (state.warnings) {\n    Log.warn(state.warnings.join('\\n\\n'));\n\n    if (state.appUrl) {\n      Log.info(`ready on ${state.appUrl}`);\n    }\n\n    return;\n  }\n\n  if (state.typeChecking) {\n    Log.info('bundled successfully, waiting for typecheck results...');\n    return;\n  }\n\n  Log.event('compiled successfully');\n});","map":{"version":3,"sources":["../../../build/output/store.ts"],"names":["store","appUrl","bootstrap","lastStore","Object","key","nextStore","state","hasStoreChanged","Log","cleanError","matches","prop","match","console"],"mappings":"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","sourcesContent":["import createStore from 'next/dist/compiled/unistore'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\n\nimport * as Log from './log'\n\nexport type OutputState =\n  | { bootstrap: true; appUrl: string | null }\n  | ({ bootstrap: false; appUrl: string | null } & (\n      | { loading: true }\n      | {\n          loading: false\n          typeChecking: boolean\n          errors: string[] | null\n          warnings: string[] | null\n        }\n    ))\n\nexport const store = createStore<OutputState>({ appUrl: null, bootstrap: true })\n\nlet lastStore: OutputState = { appUrl: null, bootstrap: true }\nfunction hasStoreChanged(nextStore: OutputState) {\n  if (\n    ([\n      ...new Set([...Object.keys(lastStore), ...Object.keys(nextStore)]),\n    ] as Array<keyof OutputState>).every((key) =>\n      Object.is(lastStore[key], nextStore[key])\n    )\n  ) {\n    return false\n  }\n\n  lastStore = nextStore\n  return true\n}\n\nstore.subscribe((state) => {\n  if (!hasStoreChanged(state)) {\n    return\n  }\n\n  if (state.bootstrap) {\n    if (state.appUrl) {\n      Log.ready(`started server on ${state.appUrl}`)\n    }\n    return\n  }\n\n  if (state.loading) {\n    Log.wait('compiling...')\n    return\n  }\n\n  if (state.errors) {\n    Log.error(state.errors[0])\n\n    const cleanError = stripAnsi(state.errors[0])\n    if (cleanError.indexOf('SyntaxError') > -1) {\n      const matches = cleanError.match(/\\[.*\\]=/)\n      if (matches) {\n        for (const match of matches) {\n          const prop = (match.split(']').shift() || '').substr(1)\n          console.log(\n            `AMP bind syntax [${prop}]='' is not supported in JSX, use 'data-amp-bind-${prop}' instead. https://err.sh/vercel/next.js/amp-bind-jsx-alt`\n          )\n        }\n        return\n      }\n    }\n\n    return\n  }\n\n  if (state.warnings) {\n    Log.warn(state.warnings.join('\\n\\n'))\n    if (state.appUrl) {\n      Log.info(`ready on ${state.appUrl}`)\n    }\n    return\n  }\n\n  if (state.typeChecking) {\n    Log.info('bundled successfully, waiting for typecheck results...')\n    return\n  }\n\n  Log.event('compiled successfully')\n})\n"]},"metadata":{},"sourceType":"script"}