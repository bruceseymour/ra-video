{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\"use strict\";\n\nimport { defaults, keep_name, mergeSort, push_uniq, make_node, return_false, return_this, return_true, string_template } from \"./utils/index.js\";\nimport { AST_Arrow, AST_Block, AST_Call, AST_Catch, AST_Class, AST_Conditional, AST_DefClass, AST_Defun, AST_Destructuring, AST_Dot, AST_Export, AST_For, AST_ForIn, AST_Function, AST_Import, AST_IterationStatement, AST_Label, AST_LabeledStatement, AST_LabelRef, AST_Lambda, AST_LoopControl, AST_NameMapping, AST_Node, AST_Scope, AST_Sequence, AST_String, AST_Sub, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_SymbolBlockDeclaration, AST_SymbolCatch, AST_SymbolClass, AST_SymbolConst, AST_SymbolDefClass, AST_SymbolDefun, AST_SymbolExport, AST_SymbolFunarg, AST_SymbolImport, AST_SymbolLambda, AST_SymbolLet, AST_SymbolMethod, AST_SymbolRef, AST_SymbolVar, AST_Toplevel, AST_VarDef, AST_With, TreeWalker, walk } from \"./ast.js\";\nimport { RESERVED_WORDS, js_error } from \"./parse.js\";\nconst MASK_EXPORT_DONT_MANGLE = 1 << 0;\nconst MASK_EXPORT_WANT_MANGLE = 1 << 1;\nlet function_defs = null;\nlet unmangleable_names = null;\n\nclass SymbolDef {\n  constructor(scope, orig, init) {\n    this.name = orig.name;\n    this.orig = [orig];\n    this.init = init;\n    this.eliminated = 0;\n    this.assignments = 0;\n    this.scope = scope;\n    this.replaced = 0;\n    this.global = false;\n    this.export = 0;\n    this.mangled_name = null;\n    this.undeclared = false;\n    this.id = SymbolDef.next_id++;\n    this.chained = false;\n    this.direct_access = false;\n    this.escaped = 0;\n    this.recursive_refs = 0;\n    this.references = [];\n    this.should_replace = undefined;\n    this.single_use = false;\n    this.fixed = false;\n    Object.seal(this);\n  }\n\n  fixed_value() {\n    if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;\n    return this.fixed();\n  }\n\n  unmangleable(options) {\n    if (!options) options = {};\n    if (function_defs && function_defs.has(this.id) && keep_name(options.keep_fnames, this.orig[0].name)) return true;\n    return this.global && !options.toplevel || this.export & MASK_EXPORT_DONT_MANGLE || this.undeclared || !options.eval && this.scope.pinned() || (this.orig[0] instanceof AST_SymbolLambda || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name) || this.orig[0] instanceof AST_SymbolMethod || (this.orig[0] instanceof AST_SymbolClass || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);\n  }\n\n  mangle(options) {\n    const cache = options.cache && options.cache.props;\n\n    if (this.global && cache && cache.has(this.name)) {\n      this.mangled_name = cache.get(this.name);\n    } else if (!this.mangled_name && !this.unmangleable(options)) {\n      var s = this.scope;\n      var sym = this.orig[0];\n      if (options.ie8 && sym instanceof AST_SymbolLambda) s = s.parent_scope;\n      const redefinition = redefined_catch_def(this);\n      this.mangled_name = redefinition ? redefinition.mangled_name || redefinition.name : s.next_mangled(options, this);\n\n      if (this.global && cache) {\n        cache.set(this.name, this.mangled_name);\n      }\n    }\n  }\n\n}\n\nSymbolDef.next_id = 1;\n\nfunction redefined_catch_def(def) {\n  if (def.orig[0] instanceof AST_SymbolCatch && def.scope.is_block_scope()) {\n    return def.scope.get_defun_scope().variables.get(def.name);\n  }\n}\n\nAST_Scope.DEFMETHOD(\"figure_out_scope\", function (options, {\n  parent_scope = null,\n  toplevel = this\n} = {}) {\n  options = defaults(options, {\n    cache: null,\n    ie8: false,\n    safari10: false\n  });\n\n  if (!(toplevel instanceof AST_Toplevel)) {\n    throw new Error(\"Invalid toplevel scope\");\n  } // pass 1: setup scope chaining and handle definitions\n\n\n  var scope = this.parent_scope = parent_scope;\n  var labels = new Map();\n  var defun = null;\n  var in_destructuring = null;\n  var for_scopes = [];\n  var tw = new TreeWalker((node, descend) => {\n    if (node.is_block_scope()) {\n      const save_scope = scope;\n      node.block_scope = scope = new AST_Scope(node);\n      scope._block_scope = true; // AST_Try in the AST sadly *is* (not has) a body itself,\n      // and its catch and finally branches are children of the AST_Try itself\n\n      const parent_scope = node instanceof AST_Catch ? save_scope.parent_scope : save_scope;\n      scope.init_scope_vars(parent_scope);\n      scope.uses_with = save_scope.uses_with;\n      scope.uses_eval = save_scope.uses_eval;\n\n      if (options.safari10) {\n        if (node instanceof AST_For || node instanceof AST_ForIn) {\n          for_scopes.push(scope);\n        }\n      }\n\n      if (node instanceof AST_Switch) {\n        // XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope\n        // AST_Switch has a scope within the body, but it itself \"is a block scope\"\n        // This means the switched expression has to belong to the outer scope\n        // while the body inside belongs to the switch itself.\n        // This is pretty nasty and warrants an AST change similar to AST_Try (read above)\n        const the_block_scope = scope;\n        scope = save_scope;\n        node.expression.walk(tw);\n        scope = the_block_scope;\n\n        for (let i = 0; i < node.body.length; i++) {\n          node.body[i].walk(tw);\n        }\n      } else {\n        descend();\n      }\n\n      scope = save_scope;\n      return true;\n    }\n\n    if (node instanceof AST_Destructuring) {\n      const save_destructuring = in_destructuring;\n      in_destructuring = node;\n      descend();\n      in_destructuring = save_destructuring;\n      return true;\n    }\n\n    if (node instanceof AST_Scope) {\n      node.init_scope_vars(scope);\n      var save_scope = scope;\n      var save_defun = defun;\n      var save_labels = labels;\n      defun = scope = node;\n      labels = new Map();\n      descend();\n      scope = save_scope;\n      defun = save_defun;\n      labels = save_labels;\n      return true; // don't descend again in TreeWalker\n    }\n\n    if (node instanceof AST_LabeledStatement) {\n      var l = node.label;\n\n      if (labels.has(l.name)) {\n        throw new Error(string_template(\"Label {name} defined twice\", l));\n      }\n\n      labels.set(l.name, l);\n      descend();\n      labels.delete(l.name);\n      return true; // no descend again\n    }\n\n    if (node instanceof AST_With) {\n      for (var s = scope; s; s = s.parent_scope) s.uses_with = true;\n\n      return;\n    }\n\n    if (node instanceof AST_Symbol) {\n      node.scope = scope;\n    }\n\n    if (node instanceof AST_Label) {\n      node.thedef = node;\n      node.references = [];\n    }\n\n    if (node instanceof AST_SymbolLambda) {\n      defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n    } else if (node instanceof AST_SymbolDefun) {\n      // Careful here, the scope where this should be defined is\n      // the parent scope.  The reason is that we enter a new\n      // scope when we encounter the AST_Defun node (which is\n      // instanceof AST_Scope) but we get to the symbol a bit\n      // later.\n      mark_export((node.scope = defun.parent_scope.get_defun_scope()).def_function(node, defun), 1);\n    } else if (node instanceof AST_SymbolClass) {\n      mark_export(defun.def_variable(node, defun), 1);\n    } else if (node instanceof AST_SymbolImport) {\n      scope.def_variable(node);\n    } else if (node instanceof AST_SymbolDefClass) {\n      // This deals with the name of the class being available\n      // inside the class.\n      mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);\n    } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolLet || node instanceof AST_SymbolConst || node instanceof AST_SymbolCatch) {\n      var def;\n\n      if (node instanceof AST_SymbolBlockDeclaration) {\n        def = scope.def_variable(node, null);\n      } else {\n        def = defun.def_variable(node, node.TYPE == \"SymbolVar\" ? null : undefined);\n      }\n\n      if (!def.orig.every(sym => {\n        if (sym === node) return true;\n\n        if (node instanceof AST_SymbolBlockDeclaration) {\n          return sym instanceof AST_SymbolLambda;\n        }\n\n        return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst);\n      })) {\n        js_error(`\"${node.name}\" is redeclared`, node.start.file, node.start.line, node.start.col, node.start.pos);\n      }\n\n      if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);\n\n      if (defun !== scope) {\n        node.mark_enclosed();\n        var def = scope.find_variable(node);\n\n        if (node.thedef !== def) {\n          node.thedef = def;\n          node.reference();\n        }\n      }\n    } else if (node instanceof AST_LabelRef) {\n      var sym = labels.get(node.name);\n      if (!sym) throw new Error(string_template(\"Undefined label {name} [{line},{col}]\", {\n        name: node.name,\n        line: node.start.line,\n        col: node.start.col\n      }));\n      node.thedef = sym;\n    }\n\n    if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {\n      js_error(`\"${node.TYPE}\" statement may only appear at the top level`, node.start.file, node.start.line, node.start.col, node.start.pos);\n    }\n  });\n  this.walk(tw);\n\n  function mark_export(def, level) {\n    if (in_destructuring) {\n      var i = 0;\n\n      do {\n        level++;\n      } while (tw.parent(i++) !== in_destructuring);\n    }\n\n    var node = tw.parent(level);\n\n    if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {\n      var exported = node.exported_definition;\n\n      if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {\n        def.export = MASK_EXPORT_WANT_MANGLE;\n      }\n    }\n  } // pass 2: find back references and eval\n\n\n  const is_toplevel = this instanceof AST_Toplevel;\n\n  if (is_toplevel) {\n    this.globals = new Map();\n  }\n\n  var tw = new TreeWalker(node => {\n    if (node instanceof AST_LoopControl && node.label) {\n      node.label.thedef.references.push(node);\n      return true;\n    }\n\n    if (node instanceof AST_SymbolRef) {\n      var name = node.name;\n\n      if (name == \"eval\" && tw.parent() instanceof AST_Call) {\n        for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {\n          s.uses_eval = true;\n        }\n      }\n\n      var sym;\n\n      if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name || !(sym = node.scope.find_variable(name))) {\n        sym = toplevel.def_global(node);\n        if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;\n      } else if (sym.scope instanceof AST_Lambda && name == \"arguments\") {\n        sym.scope.uses_arguments = true;\n      }\n\n      node.thedef = sym;\n      node.reference();\n\n      if (node.scope.is_block_scope() && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {\n        node.scope = node.scope.get_defun_scope();\n      }\n\n      return true;\n    } // ensure mangling works if catch reuses a scope variable\n\n\n    var def;\n\n    if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {\n      var s = node.scope;\n\n      while (s) {\n        push_uniq(s.enclosed, def);\n        if (s === def.scope) break;\n        s = s.parent_scope;\n      }\n    }\n  });\n  this.walk(tw); // pass 3: work around IE8 and Safari catch scope bugs\n\n  if (options.ie8 || options.safari10) {\n    walk(this, node => {\n      if (node instanceof AST_SymbolCatch) {\n        var name = node.name;\n        var refs = node.thedef.references;\n        var scope = node.scope.get_defun_scope();\n        var def = scope.find_variable(name) || toplevel.globals.get(name) || scope.def_variable(node);\n        refs.forEach(function (ref) {\n          ref.thedef = def;\n          ref.reference();\n        });\n        node.thedef = def;\n        node.reference();\n        return true;\n      }\n    });\n  } // pass 4: add symbol definitions to loop scopes\n  // Safari/Webkit bug workaround - loop init let variable shadowing argument.\n  // https://github.com/mishoo/UglifyJS2/issues/1753\n  // https://bugs.webkit.org/show_bug.cgi?id=171041\n\n\n  if (options.safari10) {\n    for (const scope of for_scopes) {\n      scope.parent_scope.variables.forEach(function (def) {\n        push_uniq(scope.enclosed, def);\n      });\n    }\n  }\n});\nAST_Toplevel.DEFMETHOD(\"def_global\", function (node) {\n  var globals = this.globals,\n      name = node.name;\n\n  if (globals.has(name)) {\n    return globals.get(name);\n  } else {\n    var g = new SymbolDef(this, node);\n    g.undeclared = true;\n    g.global = true;\n    globals.set(name, g);\n    return g;\n  }\n});\nAST_Scope.DEFMETHOD(\"init_scope_vars\", function (parent_scope) {\n  this.variables = new Map(); // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n\n  this.functions = new Map(); // map name to AST_SymbolDefun (functions defined in this scope)\n\n  this.uses_with = false; // will be set to true if this or some nested scope uses the `with` statement\n\n  this.uses_eval = false; // will be set to true if this or nested scope uses the global `eval`\n\n  this.parent_scope = parent_scope; // the parent scope\n\n  this.enclosed = []; // a list of variables from this or outer scope(s) that are referenced from this or inner scopes\n\n  this.cname = -1; // the current index for mangling functions/variables\n});\nAST_Scope.DEFMETHOD(\"conflicting_def\", function (name) {\n  return this.enclosed.find(def => def.name === name) || this.variables.has(name) || this.parent_scope && this.parent_scope.conflicting_def(name);\n});\nAST_Scope.DEFMETHOD(\"conflicting_def_shallow\", function (name) {\n  return this.enclosed.find(def => def.name === name) || this.variables.has(name);\n});\nAST_Scope.DEFMETHOD(\"add_child_scope\", function (scope) {\n  // `scope` is going to be moved into `this` right now.\n  // Update the required scopes' information\n  if (scope.parent_scope === this) return;\n  scope.parent_scope = this; // TODO uses_with, uses_eval, etc\n\n  const scope_ancestry = (() => {\n    const ancestry = [];\n    let cur = this;\n\n    do {\n      ancestry.push(cur);\n    } while (cur = cur.parent_scope);\n\n    ancestry.reverse();\n    return ancestry;\n  })();\n\n  const new_scope_enclosed_set = new Set(scope.enclosed);\n  const to_enclose = [];\n\n  for (const scope_topdown of scope_ancestry) {\n    to_enclose.forEach(e => push_uniq(scope_topdown.enclosed, e));\n\n    for (const def of scope_topdown.variables.values()) {\n      if (new_scope_enclosed_set.has(def)) {\n        push_uniq(to_enclose, def);\n        push_uniq(scope_topdown.enclosed, def);\n      }\n    }\n  }\n});\n\nfunction find_scopes_visible_from(scopes) {\n  const found_scopes = new Set();\n\n  for (const scope of new Set(scopes)) {\n    (function bubble_up(scope) {\n      if (scope == null || found_scopes.has(scope)) return;\n      found_scopes.add(scope);\n      bubble_up(scope.parent_scope);\n    })(scope);\n  }\n\n  return [...found_scopes];\n} // Creates a symbol during compression\n\n\nAST_Scope.DEFMETHOD(\"create_symbol\", function (SymClass, {\n  source,\n  tentative_name,\n  scope,\n  conflict_scopes = [scope],\n  init = null\n} = {}) {\n  let symbol_name;\n  conflict_scopes = find_scopes_visible_from(conflict_scopes);\n\n  if (tentative_name) {\n    // Implement hygiene (no new names are conflicting with existing names)\n    tentative_name = symbol_name = tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n    let i = 0;\n\n    while (conflict_scopes.find(s => s.conflicting_def_shallow(symbol_name))) {\n      symbol_name = tentative_name + \"$\" + i++;\n    }\n  }\n\n  if (!symbol_name) {\n    throw new Error(\"No symbol name could be generated in create_symbol()\");\n  }\n\n  const symbol = make_node(SymClass, source, {\n    name: symbol_name,\n    scope\n  });\n  this.def_variable(symbol, init || null);\n  symbol.mark_enclosed();\n  return symbol;\n});\nAST_Node.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Class.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Lambda.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Toplevel.DEFMETHOD(\"is_block_scope\", return_false);\nAST_SwitchBranch.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Block.DEFMETHOD(\"is_block_scope\", return_true);\nAST_Scope.DEFMETHOD(\"is_block_scope\", function () {\n  return this._block_scope || false;\n});\nAST_IterationStatement.DEFMETHOD(\"is_block_scope\", return_true);\nAST_Lambda.DEFMETHOD(\"init_scope_vars\", function () {\n  AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n  this.uses_arguments = false;\n  this.def_variable(new AST_SymbolFunarg({\n    name: \"arguments\",\n    start: this.start,\n    end: this.end\n  }));\n});\nAST_Arrow.DEFMETHOD(\"init_scope_vars\", function () {\n  AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n  this.uses_arguments = false;\n});\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function () {\n  var def = this.definition();\n  var s = this.scope;\n\n  while (s) {\n    push_uniq(s.enclosed, def);\n    if (s === def.scope) break;\n    s = s.parent_scope;\n  }\n});\nAST_Symbol.DEFMETHOD(\"reference\", function () {\n  this.definition().references.push(this);\n  this.mark_enclosed();\n});\nAST_Scope.DEFMETHOD(\"find_variable\", function (name) {\n  if (name instanceof AST_Symbol) name = name.name;\n  return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);\n});\nAST_Scope.DEFMETHOD(\"def_function\", function (symbol, init) {\n  var def = this.def_variable(symbol, init);\n  if (!def.init || def.init instanceof AST_Defun) def.init = init;\n  this.functions.set(symbol.name, def);\n  return def;\n});\nAST_Scope.DEFMETHOD(\"def_variable\", function (symbol, init) {\n  var def = this.variables.get(symbol.name);\n\n  if (def) {\n    def.orig.push(symbol);\n\n    if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {\n      def.init = init;\n    }\n  } else {\n    def = new SymbolDef(this, symbol, init);\n    this.variables.set(symbol.name, def);\n    def.global = !this.parent_scope;\n  }\n\n  return symbol.thedef = def;\n});\n\nfunction next_mangled(scope, options) {\n  var ext = scope.enclosed;\n\n  out: while (true) {\n    var m = base54(++scope.cname);\n    if (RESERVED_WORDS.has(m)) continue; // skip over \"do\"\n    // https://github.com/mishoo/UglifyJS2/issues/242 -- do not\n    // shadow a name reserved from mangling.\n\n    if (options.reserved.has(m)) continue; // Functions with short names might collide with base54 output\n    // and therefore cause collisions when keep_fnames is true.\n\n    if (unmangleable_names && unmangleable_names.has(m)) continue out; // we must ensure that the mangled name does not shadow a name\n    // from some parent scope that is referenced in this or in\n    // inner scopes.\n\n    for (let i = ext.length; --i >= 0;) {\n      const def = ext[i];\n      const name = def.mangled_name || def.unmangleable(options) && def.name;\n      if (m == name) continue out;\n    }\n\n    return m;\n  }\n}\n\nAST_Scope.DEFMETHOD(\"next_mangled\", function (options) {\n  return next_mangled(this, options);\n});\nAST_Toplevel.DEFMETHOD(\"next_mangled\", function (options) {\n  let name;\n  const mangled_names = this.mangled_names;\n\n  do {\n    name = next_mangled(this, options);\n  } while (mangled_names.has(name));\n\n  return name;\n});\nAST_Function.DEFMETHOD(\"next_mangled\", function (options, def) {\n  // #179, #326\n  // in Safari strict mode, something like (function x(x){...}) is a syntax error;\n  // a function expression's argument cannot shadow the function expression's name\n  var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition(); // the function's mangled_name is null when keep_fnames is true\n\n  var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;\n\n  while (true) {\n    var name = next_mangled(this, options);\n    if (!tricky_name || tricky_name != name) return name;\n  }\n});\nAST_Symbol.DEFMETHOD(\"unmangleable\", function (options) {\n  var def = this.definition();\n  return !def || def.unmangleable(options);\n}); // labels are always mangleable\n\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\nAST_Symbol.DEFMETHOD(\"unreferenced\", function () {\n  return !this.definition().references.length && !this.scope.pinned();\n});\nAST_Symbol.DEFMETHOD(\"definition\", function () {\n  return this.thedef;\n});\nAST_Symbol.DEFMETHOD(\"global\", function () {\n  return this.thedef.global;\n});\nAST_Toplevel.DEFMETHOD(\"_default_mangler_options\", function (options) {\n  options = defaults(options, {\n    eval: false,\n    ie8: false,\n    keep_classnames: false,\n    keep_fnames: false,\n    module: false,\n    reserved: [],\n    toplevel: false\n  });\n  if (options.module) options.toplevel = true;\n\n  if (!Array.isArray(options.reserved) && !(options.reserved instanceof Set)) {\n    options.reserved = [];\n  }\n\n  options.reserved = new Set(options.reserved); // Never mangle arguments\n\n  options.reserved.add(\"arguments\");\n  return options;\n});\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function (options) {\n  options = this._default_mangler_options(options); // We only need to mangle declaration nodes.  Special logic wired\n  // into the code generator will display the mangled name if it's\n  // present (and for AST_SymbolRef-s it'll use the mangled name of\n  // the AST_SymbolDeclaration that it points to).\n\n  var lname = -1;\n  var to_mangle = [];\n\n  if (options.keep_fnames) {\n    function_defs = new Set();\n  }\n\n  const mangled_names = this.mangled_names = new Set();\n\n  if (options.cache) {\n    this.globals.forEach(collect);\n\n    if (options.cache.props) {\n      options.cache.props.forEach(function (mangled_name) {\n        mangled_names.add(mangled_name);\n      });\n    }\n  }\n\n  var tw = new TreeWalker(function (node, descend) {\n    if (node instanceof AST_LabeledStatement) {\n      // lname is incremented when we get to the AST_Label\n      var save_nesting = lname;\n      descend();\n      lname = save_nesting;\n      return true; // don't descend again in TreeWalker\n    }\n\n    if (node instanceof AST_Scope) {\n      node.variables.forEach(collect);\n      return;\n    }\n\n    if (node.is_block_scope()) {\n      node.block_scope.variables.forEach(collect);\n      return;\n    }\n\n    if (function_defs && node instanceof AST_VarDef && node.value instanceof AST_Lambda && !node.value.name && keep_name(options.keep_fnames, node.name.name)) {\n      function_defs.add(node.name.definition().id);\n      return;\n    }\n\n    if (node instanceof AST_Label) {\n      let name;\n\n      do {\n        name = base54(++lname);\n      } while (RESERVED_WORDS.has(name));\n\n      node.mangled_name = name;\n      return true;\n    }\n\n    if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {\n      to_mangle.push(node.definition());\n      return;\n    }\n  });\n  this.walk(tw);\n\n  if (options.keep_fnames || options.keep_classnames) {\n    unmangleable_names = new Set(); // Collect a set of short names which are unmangleable,\n    // for use in avoiding collisions in next_mangled.\n\n    to_mangle.forEach(def => {\n      if (def.name.length < 6 && def.unmangleable(options)) {\n        unmangleable_names.add(def.name);\n      }\n    });\n  }\n\n  to_mangle.forEach(def => {\n    def.mangle(options);\n  });\n  function_defs = null;\n  unmangleable_names = null;\n\n  function collect(symbol) {\n    const should_mangle = !options.reserved.has(symbol.name) && !(symbol.export & MASK_EXPORT_DONT_MANGLE);\n\n    if (should_mangle) {\n      to_mangle.push(symbol);\n    }\n  }\n});\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function (options) {\n  const cache = options.cache && options.cache.props;\n  const avoid = new Set();\n  options.reserved.forEach(to_avoid);\n  this.globals.forEach(add_def);\n  this.walk(new TreeWalker(function (node) {\n    if (node instanceof AST_Scope) node.variables.forEach(add_def);\n    if (node instanceof AST_SymbolCatch) add_def(node.definition());\n  }));\n  return avoid;\n\n  function to_avoid(name) {\n    avoid.add(name);\n  }\n\n  function add_def(def) {\n    var name = def.name;\n    if (def.global && cache && cache.has(name)) name = cache.get(name);else if (!def.unmangleable(options)) return;\n    to_avoid(name);\n  }\n});\nAST_Toplevel.DEFMETHOD(\"expand_names\", function (options) {\n  base54.reset();\n  base54.sort();\n  options = this._default_mangler_options(options);\n  var avoid = this.find_colliding_names(options);\n  var cname = 0;\n  this.globals.forEach(rename);\n  this.walk(new TreeWalker(function (node) {\n    if (node instanceof AST_Scope) node.variables.forEach(rename);\n    if (node instanceof AST_SymbolCatch) rename(node.definition());\n  }));\n\n  function next_name() {\n    var name;\n\n    do {\n      name = base54(cname++);\n    } while (avoid.has(name) || RESERVED_WORDS.has(name));\n\n    return name;\n  }\n\n  function rename(def) {\n    if (def.global && options.cache) return;\n    if (def.unmangleable(options)) return;\n    if (options.reserved.has(def.name)) return;\n    const redefinition = redefined_catch_def(def);\n    const name = def.name = redefinition ? redefinition.name : next_name();\n    def.orig.forEach(function (sym) {\n      sym.name = name;\n    });\n    def.references.forEach(function (sym) {\n      sym.name = name;\n    });\n  }\n});\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function () {\n  return this.expressions[this.expressions.length - 1];\n});\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function (options) {\n  options = this._default_mangler_options(options);\n\n  try {\n    AST_Node.prototype.print = function (stream, force_parens) {\n      this._print(stream, force_parens);\n\n      if (this instanceof AST_Symbol && !this.unmangleable(options)) {\n        base54.consider(this.name, -1);\n      } else if (options.properties) {\n        if (this instanceof AST_Dot) {\n          base54.consider(this.property, -1);\n        } else if (this instanceof AST_Sub) {\n          skip_string(this.property);\n        }\n      }\n    };\n\n    base54.consider(this.print_to_string(), 1);\n  } finally {\n    AST_Node.prototype.print = AST_Node.prototype._print;\n  }\n\n  base54.sort();\n\n  function skip_string(node) {\n    if (node instanceof AST_String) {\n      base54.consider(node.value, -1);\n    } else if (node instanceof AST_Conditional) {\n      skip_string(node.consequent);\n      skip_string(node.alternative);\n    } else if (node instanceof AST_Sequence) {\n      skip_string(node.tail_node());\n    }\n  }\n});\n\nconst base54 = (() => {\n  const leading = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\".split(\"\");\n  const digits = \"0123456789\".split(\"\");\n  let chars;\n  let frequency;\n\n  function reset() {\n    frequency = new Map();\n    leading.forEach(function (ch) {\n      frequency.set(ch, 0);\n    });\n    digits.forEach(function (ch) {\n      frequency.set(ch, 0);\n    });\n  }\n\n  base54.consider = function (str, delta) {\n    for (var i = str.length; --i >= 0;) {\n      frequency.set(str[i], frequency.get(str[i]) + delta);\n    }\n  };\n\n  function compare(a, b) {\n    return frequency.get(b) - frequency.get(a);\n  }\n\n  base54.sort = function () {\n    chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));\n  };\n\n  base54.reset = reset;\n  reset();\n\n  function base54(num) {\n    var ret = \"\",\n        base = 54;\n    num++;\n\n    do {\n      num--;\n      ret += chars[num % base];\n      num = Math.floor(num / base);\n      base = 64;\n    } while (num > 0);\n\n    return ret;\n  }\n\n  return base54;\n})();\n\nexport { base54, SymbolDef };","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/node_modules/terser/lib/scope.js"],"names":["defaults","keep_name","mergeSort","push_uniq","make_node","return_false","return_this","return_true","string_template","AST_Arrow","AST_Block","AST_Call","AST_Catch","AST_Class","AST_Conditional","AST_DefClass","AST_Defun","AST_Destructuring","AST_Dot","AST_Export","AST_For","AST_ForIn","AST_Function","AST_Import","AST_IterationStatement","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_LoopControl","AST_NameMapping","AST_Node","AST_Scope","AST_Sequence","AST_String","AST_Sub","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolBlockDeclaration","AST_SymbolCatch","AST_SymbolClass","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_Toplevel","AST_VarDef","AST_With","TreeWalker","walk","RESERVED_WORDS","js_error","MASK_EXPORT_DONT_MANGLE","MASK_EXPORT_WANT_MANGLE","function_defs","unmangleable_names","SymbolDef","constructor","scope","orig","init","name","eliminated","assignments","replaced","global","export","mangled_name","undeclared","id","next_id","chained","direct_access","escaped","recursive_refs","references","should_replace","undefined","single_use","fixed","Object","seal","fixed_value","unmangleable","options","has","keep_fnames","toplevel","eval","pinned","keep_classnames","mangle","cache","props","get","s","sym","ie8","parent_scope","redefinition","redefined_catch_def","next_mangled","set","def","is_block_scope","get_defun_scope","variables","DEFMETHOD","safari10","Error","labels","Map","defun","in_destructuring","for_scopes","tw","node","descend","save_scope","block_scope","_block_scope","init_scope_vars","uses_with","uses_eval","push","the_block_scope","expression","i","body","length","save_destructuring","save_defun","save_labels","l","label","delete","thedef","def_function","mark_export","def_variable","TYPE","every","start","file","line","col","pos","mark_enclosed","find_variable","reference","level","parent","exported","exported_definition","is_default","is_toplevel","globals","module_name","def_global","uses_arguments","definition","enclosed","refs","forEach","ref","g","functions","cname","find","conflicting_def","scope_ancestry","ancestry","cur","reverse","new_scope_enclosed_set","Set","to_enclose","scope_topdown","e","values","find_scopes_visible_from","scopes","found_scopes","bubble_up","add","SymClass","source","tentative_name","conflict_scopes","symbol_name","replace","conflicting_def_shallow","symbol","prototype","apply","arguments","end","ext","out","m","base54","reserved","mangled_names","tricky_def","tricky_name","module","Array","isArray","_default_mangler_options","lname","to_mangle","collect","save_nesting","value","should_mangle","avoid","to_avoid","add_def","reset","sort","find_colliding_names","rename","next_name","expressions","print","stream","force_parens","_print","consider","properties","property","skip_string","print_to_string","consequent","alternative","tail_node","leading","split","digits","chars","frequency","ch","str","delta","compare","a","b","concat","num","ret","base","Math","floor"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,SACIA,QADJ,EAEIC,SAFJ,EAGIC,SAHJ,EAIIC,SAJJ,EAKIC,SALJ,EAMIC,YANJ,EAOIC,WAPJ,EAQIC,WARJ,EASIC,eATJ,QAUO,kBAVP;AAWA,SACIC,SADJ,EAEIC,SAFJ,EAGIC,QAHJ,EAIIC,SAJJ,EAKIC,SALJ,EAMIC,eANJ,EAOIC,YAPJ,EAQIC,SARJ,EASIC,iBATJ,EAUIC,OAVJ,EAWIC,UAXJ,EAYIC,OAZJ,EAaIC,SAbJ,EAcIC,YAdJ,EAeIC,UAfJ,EAgBIC,sBAhBJ,EAiBIC,SAjBJ,EAkBIC,oBAlBJ,EAmBIC,YAnBJ,EAoBIC,UApBJ,EAqBIC,eArBJ,EAsBIC,eAtBJ,EAuBIC,QAvBJ,EAwBIC,SAxBJ,EAyBIC,YAzBJ,EA0BIC,UA1BJ,EA2BIC,OA3BJ,EA4BIC,UA5BJ,EA6BIC,gBA7BJ,EA8BIC,UA9BJ,EA+BIC,0BA/BJ,EAgCIC,eAhCJ,EAiCIC,eAjCJ,EAkCIC,eAlCJ,EAmCIC,kBAnCJ,EAoCIC,eApCJ,EAqCIC,gBArCJ,EAsCIC,gBAtCJ,EAuCIC,gBAvCJ,EAwCIC,gBAxCJ,EAyCIC,aAzCJ,EA0CIC,gBA1CJ,EA2CIC,aA3CJ,EA4CIC,aA5CJ,EA6CIC,YA7CJ,EA8CIC,UA9CJ,EA+CIC,QA/CJ,EAgDIC,UAhDJ,EAiDIC,IAjDJ,QAkDO,UAlDP;AAmDA,SACIC,cADJ,EAEIC,QAFJ,QAGO,YAHP;AAKA,MAAMC,uBAAuB,GAAG,KAAK,CAArC;AACA,MAAMC,uBAAuB,GAAG,KAAK,CAArC;AAEA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,kBAAkB,GAAG,IAAzB;;AAEA,MAAMC,SAAN,CAAgB;AACZC,EAAAA,WAAW,CAACC,KAAD,EAAQC,IAAR,EAAcC,IAAd,EAAoB;AAC3B,SAAKC,IAAL,GAAYF,IAAI,CAACE,IAAjB;AACA,SAAKF,IAAL,GAAY,CAAEA,IAAF,CAAZ;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKE,UAAL,GAAkB,CAAlB;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKL,KAAL,GAAaA,KAAb;AACA,SAAKM,QAAL,GAAgB,CAAhB;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,EAAL,GAAUb,SAAS,CAACc,OAAV,EAAV;AACA,SAAKC,OAAL,GAAe,KAAf;AACA,SAAKC,aAAL,GAAqB,KAArB;AACA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,cAAL,GAAsBC,SAAtB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,KAAL,GAAa,KAAb;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAY,IAAZ;AACH;;AACDC,EAAAA,WAAW,GAAG;AACV,QAAI,CAAC,KAAKH,KAAN,IAAe,KAAKA,KAAL,YAAsBxD,QAAzC,EAAmD,OAAO,KAAKwD,KAAZ;AACnD,WAAO,KAAKA,KAAL,EAAP;AACH;;AACDI,EAAAA,YAAY,CAACC,OAAD,EAAU;AAClB,QAAI,CAACA,OAAL,EAAcA,OAAO,GAAG,EAAV;AAEd,QACI9B,aAAa,IACbA,aAAa,CAAC+B,GAAd,CAAkB,KAAKhB,EAAvB,CADA,IAEA5E,SAAS,CAAC2F,OAAO,CAACE,WAAT,EAAsB,KAAK3B,IAAL,CAAU,CAAV,EAAaE,IAAnC,CAHb,EAIE,OAAO,IAAP;AAEF,WAAO,KAAKI,MAAL,IAAe,CAACmB,OAAO,CAACG,QAAxB,IACC,KAAKrB,MAAL,GAAcd,uBADf,IAEA,KAAKgB,UAFL,IAGA,CAACgB,OAAO,CAACI,IAAT,IAAiB,KAAK9B,KAAL,CAAW+B,MAAX,EAHjB,IAIA,CAAC,KAAK9B,IAAL,CAAU,CAAV,aAAwBnB,gBAAxB,IACK,KAAKmB,IAAL,CAAU,CAAV,aAAwBvB,eAD9B,KACkD3C,SAAS,CAAC2F,OAAO,CAACE,WAAT,EAAsB,KAAK3B,IAAL,CAAU,CAAV,EAAaE,IAAnC,CAL3D,IAMA,KAAKF,IAAL,CAAU,CAAV,aAAwBjB,gBANxB,IAOA,CAAC,KAAKiB,IAAL,CAAU,CAAV,aAAwB1B,eAAxB,IACK,KAAK0B,IAAL,CAAU,CAAV,aAAwBxB,kBAD9B,KACqD1C,SAAS,CAAC2F,OAAO,CAACM,eAAT,EAA0B,KAAK/B,IAAL,CAAU,CAAV,EAAaE,IAAvC,CARrE;AASH;;AACD8B,EAAAA,MAAM,CAACP,OAAD,EAAU;AACZ,UAAMQ,KAAK,GAAGR,OAAO,CAACQ,KAAR,IAAiBR,OAAO,CAACQ,KAAR,CAAcC,KAA7C;;AACA,QAAI,KAAK5B,MAAL,IAAe2B,KAAf,IAAwBA,KAAK,CAACP,GAAN,CAAU,KAAKxB,IAAf,CAA5B,EAAkD;AAC9C,WAAKM,YAAL,GAAoByB,KAAK,CAACE,GAAN,CAAU,KAAKjC,IAAf,CAApB;AACH,KAFD,MAEO,IAAI,CAAC,KAAKM,YAAN,IAAsB,CAAC,KAAKgB,YAAL,CAAkBC,OAAlB,CAA3B,EAAuD;AAC1D,UAAIW,CAAC,GAAG,KAAKrC,KAAb;AACA,UAAIsC,GAAG,GAAG,KAAKrC,IAAL,CAAU,CAAV,CAAV;AACA,UAAIyB,OAAO,CAACa,GAAR,IAAeD,GAAG,YAAYxD,gBAAlC,EACIuD,CAAC,GAAGA,CAAC,CAACG,YAAN;AACJ,YAAMC,YAAY,GAAGC,mBAAmB,CAAC,IAAD,CAAxC;AACA,WAAKjC,YAAL,GAAoBgC,YAAY,GAC1BA,YAAY,CAAChC,YAAb,IAA6BgC,YAAY,CAACtC,IADhB,GAE1BkC,CAAC,CAACM,YAAF,CAAejB,OAAf,EAAwB,IAAxB,CAFN;;AAGA,UAAI,KAAKnB,MAAL,IAAe2B,KAAnB,EAA0B;AACtBA,QAAAA,KAAK,CAACU,GAAN,CAAU,KAAKzC,IAAf,EAAqB,KAAKM,YAA1B;AACH;AACJ;AACJ;;AAhEW;;AAmEhBX,SAAS,CAACc,OAAV,GAAoB,CAApB;;AAEA,SAAS8B,mBAAT,CAA6BG,GAA7B,EAAkC;AAC9B,MAAIA,GAAG,CAAC5C,IAAJ,CAAS,CAAT,aAAuB3B,eAAvB,IACGuE,GAAG,CAAC7C,KAAJ,CAAU8C,cAAV,EADP,EAEE;AACE,WAAOD,GAAG,CAAC7C,KAAJ,CAAU+C,eAAV,GAA4BC,SAA5B,CAAsCZ,GAAtC,CAA0CS,GAAG,CAAC1C,IAA9C,CAAP;AACH;AACJ;;AAEDrC,SAAS,CAACmF,SAAV,CAAoB,kBAApB,EAAwC,UAASvB,OAAT,EAAkB;AAAEc,EAAAA,YAAY,GAAG,IAAjB;AAAuBX,EAAAA,QAAQ,GAAG;AAAlC,IAA2C,EAA7D,EAAiE;AACrGH,EAAAA,OAAO,GAAG5F,QAAQ,CAAC4F,OAAD,EAAU;AACxBQ,IAAAA,KAAK,EAAE,IADiB;AAExBK,IAAAA,GAAG,EAAE,KAFmB;AAGxBW,IAAAA,QAAQ,EAAE;AAHc,GAAV,CAAlB;;AAMA,MAAI,EAAErB,QAAQ,YAAY1C,YAAtB,CAAJ,EAAyC;AACrC,UAAM,IAAIgE,KAAJ,CAAU,wBAAV,CAAN;AACH,GAToG,CAWrG;;;AACA,MAAInD,KAAK,GAAG,KAAKwC,YAAL,GAAoBA,YAAhC;AACA,MAAIY,MAAM,GAAG,IAAIC,GAAJ,EAAb;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,gBAAgB,GAAG,IAAvB;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,EAAE,GAAG,IAAInE,UAAJ,CAAe,CAACoE,IAAD,EAAOC,OAAP,KAAmB;AACvC,QAAID,IAAI,CAACZ,cAAL,EAAJ,EAA2B;AACvB,YAAMc,UAAU,GAAG5D,KAAnB;AACA0D,MAAAA,IAAI,CAACG,WAAL,GAAmB7D,KAAK,GAAG,IAAIlC,SAAJ,CAAc4F,IAAd,CAA3B;AACA1D,MAAAA,KAAK,CAAC8D,YAAN,GAAqB,IAArB,CAHuB,CAIvB;AACA;;AACA,YAAMtB,YAAY,GAAGkB,IAAI,YAAYhH,SAAhB,GACfkH,UAAU,CAACpB,YADI,GAEfoB,UAFN;AAGA5D,MAAAA,KAAK,CAAC+D,eAAN,CAAsBvB,YAAtB;AACAxC,MAAAA,KAAK,CAACgE,SAAN,GAAkBJ,UAAU,CAACI,SAA7B;AACAhE,MAAAA,KAAK,CAACiE,SAAN,GAAkBL,UAAU,CAACK,SAA7B;;AACA,UAAIvC,OAAO,CAACwB,QAAZ,EAAsB;AAClB,YAAIQ,IAAI,YAAYxG,OAAhB,IAA2BwG,IAAI,YAAYvG,SAA/C,EAA0D;AACtDqG,UAAAA,UAAU,CAACU,IAAX,CAAgBlE,KAAhB;AACH;AACJ;;AAED,UAAI0D,IAAI,YAAYxF,UAApB,EAAgC;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAMiG,eAAe,GAAGnE,KAAxB;AACAA,QAAAA,KAAK,GAAG4D,UAAR;AACAF,QAAAA,IAAI,CAACU,UAAL,CAAgB7E,IAAhB,CAAqBkE,EAArB;AACAzD,QAAAA,KAAK,GAAGmE,eAAR;;AACA,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,IAAI,CAACY,IAAL,CAAUC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACvCX,UAAAA,IAAI,CAACY,IAAL,CAAUD,CAAV,EAAa9E,IAAb,CAAkBkE,EAAlB;AACH;AACJ,OAbD,MAaO;AACHE,QAAAA,OAAO;AACV;;AACD3D,MAAAA,KAAK,GAAG4D,UAAR;AACA,aAAO,IAAP;AACH;;AACD,QAAIF,IAAI,YAAY3G,iBAApB,EAAuC;AACnC,YAAMyH,kBAAkB,GAAGjB,gBAA3B;AACAA,MAAAA,gBAAgB,GAAGG,IAAnB;AACAC,MAAAA,OAAO;AACPJ,MAAAA,gBAAgB,GAAGiB,kBAAnB;AACA,aAAO,IAAP;AACH;;AACD,QAAId,IAAI,YAAY5F,SAApB,EAA+B;AAC3B4F,MAAAA,IAAI,CAACK,eAAL,CAAqB/D,KAArB;AACA,UAAI4D,UAAU,GAAG5D,KAAjB;AACA,UAAIyE,UAAU,GAAGnB,KAAjB;AACA,UAAIoB,WAAW,GAAGtB,MAAlB;AACAE,MAAAA,KAAK,GAAGtD,KAAK,GAAG0D,IAAhB;AACAN,MAAAA,MAAM,GAAG,IAAIC,GAAJ,EAAT;AACAM,MAAAA,OAAO;AACP3D,MAAAA,KAAK,GAAG4D,UAAR;AACAN,MAAAA,KAAK,GAAGmB,UAAR;AACArB,MAAAA,MAAM,GAAGsB,WAAT;AACA,aAAO,IAAP,CAX2B,CAWP;AACvB;;AACD,QAAIhB,IAAI,YAAYlG,oBAApB,EAA0C;AACtC,UAAImH,CAAC,GAAGjB,IAAI,CAACkB,KAAb;;AACA,UAAIxB,MAAM,CAACzB,GAAP,CAAWgD,CAAC,CAACxE,IAAb,CAAJ,EAAwB;AACpB,cAAM,IAAIgD,KAAJ,CAAU7G,eAAe,CAAC,4BAAD,EAA+BqI,CAA/B,CAAzB,CAAN;AACH;;AACDvB,MAAAA,MAAM,CAACR,GAAP,CAAW+B,CAAC,CAACxE,IAAb,EAAmBwE,CAAnB;AACAhB,MAAAA,OAAO;AACPP,MAAAA,MAAM,CAACyB,MAAP,CAAcF,CAAC,CAACxE,IAAhB;AACA,aAAO,IAAP,CARsC,CAQlB;AACvB;;AACD,QAAIuD,IAAI,YAAYrE,QAApB,EAA8B;AAC1B,WAAK,IAAIgD,CAAC,GAAGrC,KAAb,EAAoBqC,CAApB,EAAuBA,CAAC,GAAGA,CAAC,CAACG,YAA7B,EACIH,CAAC,CAAC2B,SAAF,GAAc,IAAd;;AACJ;AACH;;AACD,QAAIN,IAAI,YAAYtF,UAApB,EAAgC;AAC5BsF,MAAAA,IAAI,CAAC1D,KAAL,GAAaA,KAAb;AACH;;AACD,QAAI0D,IAAI,YAAYnG,SAApB,EAA+B;AAC3BmG,MAAAA,IAAI,CAACoB,MAAL,GAAcpB,IAAd;AACAA,MAAAA,IAAI,CAACzC,UAAL,GAAkB,EAAlB;AACH;;AACD,QAAIyC,IAAI,YAAY5E,gBAApB,EAAsC;AAClCwE,MAAAA,KAAK,CAACyB,YAAN,CAAmBrB,IAAnB,EAAyBA,IAAI,CAACvD,IAAL,IAAa,WAAb,GAA2BgB,SAA3B,GAAuCmC,KAAhE;AACH,KAFD,MAEO,IAAII,IAAI,YAAYhF,eAApB,EAAqC;AACxC;AACA;AACA;AACA;AACA;AACAsG,MAAAA,WAAW,CAAC,CAACtB,IAAI,CAAC1D,KAAL,GAAasD,KAAK,CAACd,YAAN,CAAmBO,eAAnB,EAAd,EAAoDgC,YAApD,CAAiErB,IAAjE,EAAuEJ,KAAvE,CAAD,EAAgF,CAAhF,CAAX;AACH,KAPM,MAOA,IAAII,IAAI,YAAYnF,eAApB,EAAqC;AACxCyG,MAAAA,WAAW,CAAC1B,KAAK,CAAC2B,YAAN,CAAmBvB,IAAnB,EAAyBJ,KAAzB,CAAD,EAAkC,CAAlC,CAAX;AACH,KAFM,MAEA,IAAII,IAAI,YAAY7E,gBAApB,EAAsC;AACzCmB,MAAAA,KAAK,CAACiF,YAAN,CAAmBvB,IAAnB;AACH,KAFM,MAEA,IAAIA,IAAI,YAAYjF,kBAApB,EAAwC;AAC3C;AACA;AACAuG,MAAAA,WAAW,CAAC,CAACtB,IAAI,CAAC1D,KAAL,GAAasD,KAAK,CAACd,YAApB,EAAkCuC,YAAlC,CAA+CrB,IAA/C,EAAqDJ,KAArD,CAAD,EAA8D,CAA9D,CAAX;AACH,KAJM,MAIA,IACHI,IAAI,YAAYxE,aAAhB,IACGwE,IAAI,YAAY3E,aADnB,IAEG2E,IAAI,YAAYlF,eAFnB,IAGGkF,IAAI,YAAYpF,eAJhB,EAKL;AACE,UAAIuE,GAAJ;;AACA,UAAIa,IAAI,YAAYrF,0BAApB,EAAgD;AAC5CwE,QAAAA,GAAG,GAAG7C,KAAK,CAACiF,YAAN,CAAmBvB,IAAnB,EAAyB,IAAzB,CAAN;AACH,OAFD,MAEO;AACHb,QAAAA,GAAG,GAAGS,KAAK,CAAC2B,YAAN,CAAmBvB,IAAnB,EAAyBA,IAAI,CAACwB,IAAL,IAAa,WAAb,GAA2B,IAA3B,GAAkC/D,SAA3D,CAAN;AACH;;AACD,UAAI,CAAC0B,GAAG,CAAC5C,IAAJ,CAASkF,KAAT,CAAgB7C,GAAD,IAAS;AACzB,YAAIA,GAAG,KAAKoB,IAAZ,EAAkB,OAAO,IAAP;;AAClB,YAAIA,IAAI,YAAYrF,0BAApB,EAAgD;AAC5C,iBAAOiE,GAAG,YAAYxD,gBAAtB;AACH;;AACD,eAAO,EAAEwD,GAAG,YAAYvD,aAAf,IAAgCuD,GAAG,YAAY9D,eAAjD,CAAP;AACH,OANI,CAAL,EAMI;AACAiB,QAAAA,QAAQ,CACH,IAAGiE,IAAI,CAACvD,IAAK,iBADV,EAEJuD,IAAI,CAAC0B,KAAL,CAAWC,IAFP,EAGJ3B,IAAI,CAAC0B,KAAL,CAAWE,IAHP,EAIJ5B,IAAI,CAAC0B,KAAL,CAAWG,GAJP,EAKJ7B,IAAI,CAAC0B,KAAL,CAAWI,GALP,CAAR;AAOH;;AACD,UAAI,EAAE9B,IAAI,YAAY9E,gBAAlB,CAAJ,EAAyCoG,WAAW,CAACnC,GAAD,EAAM,CAAN,CAAX;;AACzC,UAAIS,KAAK,KAAKtD,KAAd,EAAqB;AACjB0D,QAAAA,IAAI,CAAC+B,aAAL;AACA,YAAI5C,GAAG,GAAG7C,KAAK,CAAC0F,aAAN,CAAoBhC,IAApB,CAAV;;AACA,YAAIA,IAAI,CAACoB,MAAL,KAAgBjC,GAApB,EAAyB;AACrBa,UAAAA,IAAI,CAACoB,MAAL,GAAcjC,GAAd;AACAa,UAAAA,IAAI,CAACiC,SAAL;AACH;AACJ;AACJ,KApCM,MAoCA,IAAIjC,IAAI,YAAYjG,YAApB,EAAkC;AACrC,UAAI6E,GAAG,GAAGc,MAAM,CAAChB,GAAP,CAAWsB,IAAI,CAACvD,IAAhB,CAAV;AACA,UAAI,CAACmC,GAAL,EAAU,MAAM,IAAIa,KAAJ,CAAU7G,eAAe,CAAC,uCAAD,EAA0C;AAC/E6D,QAAAA,IAAI,EAAEuD,IAAI,CAACvD,IADoE;AAE/EmF,QAAAA,IAAI,EAAE5B,IAAI,CAAC0B,KAAL,CAAWE,IAF8D;AAG/EC,QAAAA,GAAG,EAAE7B,IAAI,CAAC0B,KAAL,CAAWG;AAH+D,OAA1C,CAAzB,CAAN;AAKV7B,MAAAA,IAAI,CAACoB,MAAL,GAAcxC,GAAd;AACH;;AACD,QAAI,EAAEtC,KAAK,YAAYb,YAAnB,MAAqCuE,IAAI,YAAYzG,UAAhB,IAA8ByG,IAAI,YAAYrG,UAAnF,CAAJ,EAAoG;AAChGoC,MAAAA,QAAQ,CACH,IAAGiE,IAAI,CAACwB,IAAK,8CADV,EAEJxB,IAAI,CAAC0B,KAAL,CAAWC,IAFP,EAGJ3B,IAAI,CAAC0B,KAAL,CAAWE,IAHP,EAIJ5B,IAAI,CAAC0B,KAAL,CAAWG,GAJP,EAKJ7B,IAAI,CAAC0B,KAAL,CAAWI,GALP,CAAR;AAOH;AACJ,GAvJQ,CAAT;AAwJA,OAAKjG,IAAL,CAAUkE,EAAV;;AAEA,WAASuB,WAAT,CAAqBnC,GAArB,EAA0B+C,KAA1B,EAAiC;AAC7B,QAAIrC,gBAAJ,EAAsB;AAClB,UAAIc,CAAC,GAAG,CAAR;;AACA,SAAG;AACCuB,QAAAA,KAAK;AACR,OAFD,QAESnC,EAAE,CAACoC,MAAH,CAAUxB,CAAC,EAAX,MAAmBd,gBAF5B;AAGH;;AACD,QAAIG,IAAI,GAAGD,EAAE,CAACoC,MAAH,CAAUD,KAAV,CAAX;;AACA,QAAI/C,GAAG,CAACrC,MAAJ,GAAakD,IAAI,YAAYzG,UAAhB,GAA6ByC,uBAA7B,GAAuD,CAAxE,EAA2E;AACvE,UAAIoG,QAAQ,GAAGpC,IAAI,CAACqC,mBAApB;;AACA,UAAI,CAACD,QAAQ,YAAYhJ,SAApB,IAAiCgJ,QAAQ,YAAYjJ,YAAtD,KAAuE6G,IAAI,CAACsC,UAAhF,EAA4F;AACxFnD,QAAAA,GAAG,CAACrC,MAAJ,GAAab,uBAAb;AACH;AACJ;AACJ,GAzLoG,CA2LrG;;;AACA,QAAMsG,WAAW,GAAG,gBAAgB9G,YAApC;;AACA,MAAI8G,WAAJ,EAAiB;AACb,SAAKC,OAAL,GAAe,IAAI7C,GAAJ,EAAf;AACH;;AAED,MAAII,EAAE,GAAG,IAAInE,UAAJ,CAAeoE,IAAI,IAAI;AAC5B,QAAIA,IAAI,YAAY/F,eAAhB,IAAmC+F,IAAI,CAACkB,KAA5C,EAAmD;AAC/ClB,MAAAA,IAAI,CAACkB,KAAL,CAAWE,MAAX,CAAkB7D,UAAlB,CAA6BiD,IAA7B,CAAkCR,IAAlC;AACA,aAAO,IAAP;AACH;;AACD,QAAIA,IAAI,YAAYzE,aAApB,EAAmC;AAC/B,UAAIkB,IAAI,GAAGuD,IAAI,CAACvD,IAAhB;;AACA,UAAIA,IAAI,IAAI,MAAR,IAAkBsD,EAAE,CAACoC,MAAH,cAAuBpJ,QAA7C,EAAuD;AACnD,aAAK,IAAI4F,CAAC,GAAGqB,IAAI,CAAC1D,KAAlB,EAAyBqC,CAAC,IAAI,CAACA,CAAC,CAAC4B,SAAjC,EAA4C5B,CAAC,GAAGA,CAAC,CAACG,YAAlD,EAAgE;AAC5DH,UAAAA,CAAC,CAAC4B,SAAF,GAAc,IAAd;AACH;AACJ;;AACD,UAAI3B,GAAJ;;AACA,UAAImB,EAAE,CAACoC,MAAH,cAAuBjI,eAAvB,IAA0C6F,EAAE,CAACoC,MAAH,CAAU,CAAV,EAAaM,WAAvD,IACG,EAAE7D,GAAG,GAAGoB,IAAI,CAAC1D,KAAL,CAAW0F,aAAX,CAAyBvF,IAAzB,CAAR,CADP,EACgD;AAE5CmC,QAAAA,GAAG,GAAGT,QAAQ,CAACuE,UAAT,CAAoB1C,IAApB,CAAN;AACA,YAAIA,IAAI,YAAY/E,gBAApB,EAAsC2D,GAAG,CAAC9B,MAAJ,GAAad,uBAAb;AACzC,OALD,MAKO,IAAI4C,GAAG,CAACtC,KAAJ,YAAqBtC,UAArB,IAAmCyC,IAAI,IAAI,WAA/C,EAA4D;AAC/DmC,QAAAA,GAAG,CAACtC,KAAJ,CAAUqG,cAAV,GAA2B,IAA3B;AACH;;AACD3C,MAAAA,IAAI,CAACoB,MAAL,GAAcxC,GAAd;AACAoB,MAAAA,IAAI,CAACiC,SAAL;;AACA,UAAIjC,IAAI,CAAC1D,KAAL,CAAW8C,cAAX,MACG,EAAER,GAAG,CAACrC,IAAJ,CAAS,CAAT,aAAuB5B,0BAAzB,CADP,EAC6D;AACzDqF,QAAAA,IAAI,CAAC1D,KAAL,GAAa0D,IAAI,CAAC1D,KAAL,CAAW+C,eAAX,EAAb;AACH;;AACD,aAAO,IAAP;AACH,KA5B2B,CA6B5B;;;AACA,QAAIF,GAAJ;;AACA,QAAIa,IAAI,YAAYpF,eAAhB,KAAoCuE,GAAG,GAAGH,mBAAmB,CAACgB,IAAI,CAAC4C,UAAL,EAAD,CAA7D,CAAJ,EAAuF;AACnF,UAAIjE,CAAC,GAAGqB,IAAI,CAAC1D,KAAb;;AACA,aAAOqC,CAAP,EAAU;AACNpG,QAAAA,SAAS,CAACoG,CAAC,CAACkE,QAAH,EAAa1D,GAAb,CAAT;AACA,YAAIR,CAAC,KAAKQ,GAAG,CAAC7C,KAAd,EAAqB;AACrBqC,QAAAA,CAAC,GAAGA,CAAC,CAACG,YAAN;AACH;AACJ;AACJ,GAvCQ,CAAT;AAwCA,OAAKjD,IAAL,CAAUkE,EAAV,EAzOqG,CA2OrG;;AACA,MAAI/B,OAAO,CAACa,GAAR,IAAeb,OAAO,CAACwB,QAA3B,EAAqC;AACjC3D,IAAAA,IAAI,CAAC,IAAD,EAAOmE,IAAI,IAAI;AACf,UAAIA,IAAI,YAAYpF,eAApB,EAAqC;AACjC,YAAI6B,IAAI,GAAGuD,IAAI,CAACvD,IAAhB;AACA,YAAIqG,IAAI,GAAG9C,IAAI,CAACoB,MAAL,CAAY7D,UAAvB;AACA,YAAIjB,KAAK,GAAG0D,IAAI,CAAC1D,KAAL,CAAW+C,eAAX,EAAZ;AACA,YAAIF,GAAG,GAAG7C,KAAK,CAAC0F,aAAN,CAAoBvF,IAApB,KACH0B,QAAQ,CAACqE,OAAT,CAAiB9D,GAAjB,CAAqBjC,IAArB,CADG,IAEHH,KAAK,CAACiF,YAAN,CAAmBvB,IAAnB,CAFP;AAGA8C,QAAAA,IAAI,CAACC,OAAL,CAAa,UAASC,GAAT,EAAc;AACvBA,UAAAA,GAAG,CAAC5B,MAAJ,GAAajC,GAAb;AACA6D,UAAAA,GAAG,CAACf,SAAJ;AACH,SAHD;AAIAjC,QAAAA,IAAI,CAACoB,MAAL,GAAcjC,GAAd;AACAa,QAAAA,IAAI,CAACiC,SAAL;AACA,eAAO,IAAP;AACH;AACJ,KAhBG,CAAJ;AAiBH,GA9PoG,CAgQrG;AACA;AACA;AACA;;;AACA,MAAIjE,OAAO,CAACwB,QAAZ,EAAsB;AAClB,SAAK,MAAMlD,KAAX,IAAoBwD,UAApB,EAAgC;AAC5BxD,MAAAA,KAAK,CAACwC,YAAN,CAAmBQ,SAAnB,CAA6ByD,OAA7B,CAAqC,UAAS5D,GAAT,EAAc;AAC/C5G,QAAAA,SAAS,CAAC+D,KAAK,CAACuG,QAAP,EAAiB1D,GAAjB,CAAT;AACH,OAFD;AAGH;AACJ;AACJ,CA3QD;AA6QA1D,YAAY,CAAC8D,SAAb,CAAuB,YAAvB,EAAqC,UAASS,IAAT,EAAe;AAChD,MAAIwC,OAAO,GAAG,KAAKA,OAAnB;AAAA,MAA4B/F,IAAI,GAAGuD,IAAI,CAACvD,IAAxC;;AACA,MAAI+F,OAAO,CAACvE,GAAR,CAAYxB,IAAZ,CAAJ,EAAuB;AACnB,WAAO+F,OAAO,CAAC9D,GAAR,CAAYjC,IAAZ,CAAP;AACH,GAFD,MAEO;AACH,QAAIwG,CAAC,GAAG,IAAI7G,SAAJ,CAAc,IAAd,EAAoB4D,IAApB,CAAR;AACAiD,IAAAA,CAAC,CAACjG,UAAF,GAAe,IAAf;AACAiG,IAAAA,CAAC,CAACpG,MAAF,GAAW,IAAX;AACA2F,IAAAA,OAAO,CAACtD,GAAR,CAAYzC,IAAZ,EAAkBwG,CAAlB;AACA,WAAOA,CAAP;AACH;AACJ,CAXD;AAaA7I,SAAS,CAACmF,SAAV,CAAoB,iBAApB,EAAuC,UAAST,YAAT,EAAuB;AAC1D,OAAKQ,SAAL,GAAiB,IAAIK,GAAJ,EAAjB,CAD0D,CACtB;;AACpC,OAAKuD,SAAL,GAAiB,IAAIvD,GAAJ,EAAjB,CAF0D,CAEtB;;AACpC,OAAKW,SAAL,GAAiB,KAAjB,CAH0D,CAGtB;;AACpC,OAAKC,SAAL,GAAiB,KAAjB,CAJ0D,CAItB;;AACpC,OAAKzB,YAAL,GAAoBA,YAApB,CAL0D,CAKtB;;AACpC,OAAK+D,QAAL,GAAgB,EAAhB,CAN0D,CAMtB;;AACpC,OAAKM,KAAL,GAAa,CAAC,CAAd,CAP0D,CAOtB;AACvC,CARD;AAUA/I,SAAS,CAACmF,SAAV,CAAoB,iBAApB,EAAuC,UAAU9C,IAAV,EAAgB;AACnD,SACI,KAAKoG,QAAL,CAAcO,IAAd,CAAmBjE,GAAG,IAAIA,GAAG,CAAC1C,IAAJ,KAAaA,IAAvC,KACG,KAAK6C,SAAL,CAAerB,GAAf,CAAmBxB,IAAnB,CADH,IAEI,KAAKqC,YAAL,IAAqB,KAAKA,YAAL,CAAkBuE,eAAlB,CAAkC5G,IAAlC,CAH7B;AAKH,CAND;AAQArC,SAAS,CAACmF,SAAV,CAAoB,yBAApB,EAA+C,UAAU9C,IAAV,EAAgB;AAC3D,SACI,KAAKoG,QAAL,CAAcO,IAAd,CAAmBjE,GAAG,IAAIA,GAAG,CAAC1C,IAAJ,KAAaA,IAAvC,KACG,KAAK6C,SAAL,CAAerB,GAAf,CAAmBxB,IAAnB,CAFP;AAIH,CALD;AAOArC,SAAS,CAACmF,SAAV,CAAoB,iBAApB,EAAuC,UAAUjD,KAAV,EAAiB;AACpD;AACA;AAEA,MAAIA,KAAK,CAACwC,YAAN,KAAuB,IAA3B,EAAiC;AAEjCxC,EAAAA,KAAK,CAACwC,YAAN,GAAqB,IAArB,CANoD,CAQpD;;AAEA,QAAMwE,cAAc,GAAG,CAAC,MAAM;AAC1B,UAAMC,QAAQ,GAAG,EAAjB;AACA,QAAIC,GAAG,GAAG,IAAV;;AACA,OAAG;AACCD,MAAAA,QAAQ,CAAC/C,IAAT,CAAcgD,GAAd;AACH,KAFD,QAEUA,GAAG,GAAGA,GAAG,CAAC1E,YAFpB;;AAGAyE,IAAAA,QAAQ,CAACE,OAAT;AACA,WAAOF,QAAP;AACH,GARsB,GAAvB;;AAUA,QAAMG,sBAAsB,GAAG,IAAIC,GAAJ,CAAQrH,KAAK,CAACuG,QAAd,CAA/B;AACA,QAAMe,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAMC,aAAX,IAA4BP,cAA5B,EAA4C;AACxCM,IAAAA,UAAU,CAACb,OAAX,CAAmBe,CAAC,IAAIvL,SAAS,CAACsL,aAAa,CAAChB,QAAf,EAAyBiB,CAAzB,CAAjC;;AACA,SAAK,MAAM3E,GAAX,IAAkB0E,aAAa,CAACvE,SAAd,CAAwByE,MAAxB,EAAlB,EAAoD;AAChD,UAAIL,sBAAsB,CAACzF,GAAvB,CAA2BkB,GAA3B,CAAJ,EAAqC;AACjC5G,QAAAA,SAAS,CAACqL,UAAD,EAAazE,GAAb,CAAT;AACA5G,QAAAA,SAAS,CAACsL,aAAa,CAAChB,QAAf,EAAyB1D,GAAzB,CAAT;AACH;AACJ;AACJ;AACJ,CA/BD;;AAiCA,SAAS6E,wBAAT,CAAkCC,MAAlC,EAA0C;AACtC,QAAMC,YAAY,GAAG,IAAIP,GAAJ,EAArB;;AAEA,OAAK,MAAMrH,KAAX,IAAoB,IAAIqH,GAAJ,CAAQM,MAAR,CAApB,EAAqC;AACjC,KAAC,SAASE,SAAT,CAAmB7H,KAAnB,EAA0B;AACvB,UAAIA,KAAK,IAAI,IAAT,IAAiB4H,YAAY,CAACjG,GAAb,CAAiB3B,KAAjB,CAArB,EAA8C;AAE9C4H,MAAAA,YAAY,CAACE,GAAb,CAAiB9H,KAAjB;AAEA6H,MAAAA,SAAS,CAAC7H,KAAK,CAACwC,YAAP,CAAT;AACH,KAND,EAMGxC,KANH;AAOH;;AAED,SAAO,CAAC,GAAG4H,YAAJ,CAAP;AACH,C,CAED;;;AACA9J,SAAS,CAACmF,SAAV,CAAoB,eAApB,EAAqC,UAAS8E,QAAT,EAAmB;AACpDC,EAAAA,MADoD;AAEpDC,EAAAA,cAFoD;AAGpDjI,EAAAA,KAHoD;AAIpDkI,EAAAA,eAAe,GAAG,CAAClI,KAAD,CAJkC;AAKpDE,EAAAA,IAAI,GAAG;AAL6C,IAMpD,EANiC,EAM7B;AACJ,MAAIiI,WAAJ;AAEAD,EAAAA,eAAe,GAAGR,wBAAwB,CAACQ,eAAD,CAA1C;;AAEA,MAAID,cAAJ,EAAoB;AAChB;AACAA,IAAAA,cAAc,GACVE,WAAW,GACXF,cAAc,CAACG,OAAf,CAAuB,6BAAvB,EAAsD,GAAtD,CAFJ;AAIA,QAAI/D,CAAC,GAAG,CAAR;;AACA,WAAO6D,eAAe,CAACpB,IAAhB,CAAqBzE,CAAC,IAAIA,CAAC,CAACgG,uBAAF,CAA0BF,WAA1B,CAA1B,CAAP,EAA0E;AACtEA,MAAAA,WAAW,GAAGF,cAAc,GAAG,GAAjB,GAAuB5D,CAAC,EAAtC;AACH;AACJ;;AAED,MAAI,CAAC8D,WAAL,EAAkB;AACd,UAAM,IAAIhF,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAED,QAAMmF,MAAM,GAAGpM,SAAS,CAAC6L,QAAD,EAAWC,MAAX,EAAmB;AACvC7H,IAAAA,IAAI,EAAEgI,WADiC;AAEvCnI,IAAAA;AAFuC,GAAnB,CAAxB;AAKA,OAAKiF,YAAL,CAAkBqD,MAAlB,EAA0BpI,IAAI,IAAI,IAAlC;AAEAoI,EAAAA,MAAM,CAAC7C,aAAP;AAEA,SAAO6C,MAAP;AACH,CArCD;AAwCAzK,QAAQ,CAACoF,SAAT,CAAmB,gBAAnB,EAAqC9G,YAArC;AACAQ,SAAS,CAACsG,SAAV,CAAoB,gBAApB,EAAsC9G,YAAtC;AACAuB,UAAU,CAACuF,SAAX,CAAqB,gBAArB,EAAuC9G,YAAvC;AACAgD,YAAY,CAAC8D,SAAb,CAAuB,gBAAvB,EAAyC9G,YAAzC;AACAgC,gBAAgB,CAAC8E,SAAjB,CAA2B,gBAA3B,EAA6C9G,YAA7C;AACAK,SAAS,CAACyG,SAAV,CAAoB,gBAApB,EAAsC5G,WAAtC;AACAyB,SAAS,CAACmF,SAAV,CAAoB,gBAApB,EAAsC,YAAY;AAC9C,SAAO,KAAKa,YAAL,IAAqB,KAA5B;AACH,CAFD;AAGAxG,sBAAsB,CAAC2F,SAAvB,CAAiC,gBAAjC,EAAmD5G,WAAnD;AAEAqB,UAAU,CAACuF,SAAX,CAAqB,iBAArB,EAAwC,YAAW;AAC/CnF,EAAAA,SAAS,CAACyK,SAAV,CAAoBxE,eAApB,CAAoCyE,KAApC,CAA0C,IAA1C,EAAgDC,SAAhD;AACA,OAAKpC,cAAL,GAAsB,KAAtB;AACA,OAAKpB,YAAL,CAAkB,IAAIrG,gBAAJ,CAAqB;AACnCuB,IAAAA,IAAI,EAAE,WAD6B;AAEnCiF,IAAAA,KAAK,EAAE,KAAKA,KAFuB;AAGnCsD,IAAAA,GAAG,EAAE,KAAKA;AAHyB,GAArB,CAAlB;AAKH,CARD;AAUAnM,SAAS,CAAC0G,SAAV,CAAoB,iBAApB,EAAuC,YAAW;AAC9CnF,EAAAA,SAAS,CAACyK,SAAV,CAAoBxE,eAApB,CAAoCyE,KAApC,CAA0C,IAA1C,EAAgDC,SAAhD;AACA,OAAKpC,cAAL,GAAsB,KAAtB;AACH,CAHD;AAKAjI,UAAU,CAAC6E,SAAX,CAAqB,eAArB,EAAsC,YAAW;AAC7C,MAAIJ,GAAG,GAAG,KAAKyD,UAAL,EAAV;AACA,MAAIjE,CAAC,GAAG,KAAKrC,KAAb;;AACA,SAAOqC,CAAP,EAAU;AACNpG,IAAAA,SAAS,CAACoG,CAAC,CAACkE,QAAH,EAAa1D,GAAb,CAAT;AACA,QAAIR,CAAC,KAAKQ,GAAG,CAAC7C,KAAd,EAAqB;AACrBqC,IAAAA,CAAC,GAAGA,CAAC,CAACG,YAAN;AACH;AACJ,CARD;AAUApE,UAAU,CAAC6E,SAAX,CAAqB,WAArB,EAAkC,YAAW;AACzC,OAAKqD,UAAL,GAAkBrF,UAAlB,CAA6BiD,IAA7B,CAAkC,IAAlC;AACA,OAAKuB,aAAL;AACH,CAHD;AAKA3H,SAAS,CAACmF,SAAV,CAAoB,eAApB,EAAqC,UAAS9C,IAAT,EAAe;AAChD,MAAIA,IAAI,YAAY/B,UAApB,EAAgC+B,IAAI,GAAGA,IAAI,CAACA,IAAZ;AAChC,SAAO,KAAK6C,SAAL,CAAeZ,GAAf,CAAmBjC,IAAnB,KACC,KAAKqC,YAAL,IAAqB,KAAKA,YAAL,CAAkBkD,aAAlB,CAAgCvF,IAAhC,CAD7B;AAEH,CAJD;AAMArC,SAAS,CAACmF,SAAV,CAAoB,cAApB,EAAoC,UAASqF,MAAT,EAAiBpI,IAAjB,EAAuB;AACvD,MAAI2C,GAAG,GAAG,KAAKoC,YAAL,CAAkBqD,MAAlB,EAA0BpI,IAA1B,CAAV;AACA,MAAI,CAAC2C,GAAG,CAAC3C,IAAL,IAAa2C,GAAG,CAAC3C,IAAJ,YAAoBpD,SAArC,EAAgD+F,GAAG,CAAC3C,IAAJ,GAAWA,IAAX;AAChD,OAAK0G,SAAL,CAAehE,GAAf,CAAmB0F,MAAM,CAACnI,IAA1B,EAAgC0C,GAAhC;AACA,SAAOA,GAAP;AACH,CALD;AAOA/E,SAAS,CAACmF,SAAV,CAAoB,cAApB,EAAoC,UAASqF,MAAT,EAAiBpI,IAAjB,EAAuB;AACvD,MAAI2C,GAAG,GAAG,KAAKG,SAAL,CAAeZ,GAAf,CAAmBkG,MAAM,CAACnI,IAA1B,CAAV;;AACA,MAAI0C,GAAJ,EAAS;AACLA,IAAAA,GAAG,CAAC5C,IAAJ,CAASiE,IAAT,CAAcoE,MAAd;;AACA,QAAIzF,GAAG,CAAC3C,IAAJ,KAAa2C,GAAG,CAAC7C,KAAJ,KAAcsI,MAAM,CAACtI,KAArB,IAA8B6C,GAAG,CAAC3C,IAAJ,YAAoB9C,YAA/D,CAAJ,EAAkF;AAC9EyF,MAAAA,GAAG,CAAC3C,IAAJ,GAAWA,IAAX;AACH;AACJ,GALD,MAKO;AACH2C,IAAAA,GAAG,GAAG,IAAI/C,SAAJ,CAAc,IAAd,EAAoBwI,MAApB,EAA4BpI,IAA5B,CAAN;AACA,SAAK8C,SAAL,CAAeJ,GAAf,CAAmB0F,MAAM,CAACnI,IAA1B,EAAgC0C,GAAhC;AACAA,IAAAA,GAAG,CAACtC,MAAJ,GAAa,CAAC,KAAKiC,YAAnB;AACH;;AACD,SAAO8F,MAAM,CAACxD,MAAP,GAAgBjC,GAAvB;AACH,CAbD;;AAeA,SAASF,YAAT,CAAsB3C,KAAtB,EAA6B0B,OAA7B,EAAsC;AAClC,MAAIiH,GAAG,GAAG3I,KAAK,CAACuG,QAAhB;;AACAqC,EAAAA,GAAG,EAAE,OAAO,IAAP,EAAa;AACd,QAAIC,CAAC,GAAGC,MAAM,CAAC,EAAE9I,KAAK,CAAC6G,KAAT,CAAd;AACA,QAAIrH,cAAc,CAACmC,GAAf,CAAmBkH,CAAnB,CAAJ,EAA2B,SAFb,CAEuB;AAErC;AACA;;AACA,QAAInH,OAAO,CAACqH,QAAR,CAAiBpH,GAAjB,CAAqBkH,CAArB,CAAJ,EAA6B,SANf,CAQd;AACA;;AACA,QAAIhJ,kBAAkB,IAAIA,kBAAkB,CAAC8B,GAAnB,CAAuBkH,CAAvB,CAA1B,EAAqD,SAASD,GAAT,CAVvC,CAYd;AACA;AACA;;AACA,SAAK,IAAIvE,CAAC,GAAGsE,GAAG,CAACpE,MAAjB,EAAyB,EAAEF,CAAF,IAAO,CAAhC,GAAoC;AAChC,YAAMxB,GAAG,GAAG8F,GAAG,CAACtE,CAAD,CAAf;AACA,YAAMlE,IAAI,GAAG0C,GAAG,CAACpC,YAAJ,IAAqBoC,GAAG,CAACpB,YAAJ,CAAiBC,OAAjB,KAA6BmB,GAAG,CAAC1C,IAAnE;AACA,UAAI0I,CAAC,IAAI1I,IAAT,EAAe,SAASyI,GAAT;AAClB;;AACD,WAAOC,CAAP;AACH;AACJ;;AAED/K,SAAS,CAACmF,SAAV,CAAoB,cAApB,EAAoC,UAASvB,OAAT,EAAkB;AAClD,SAAOiB,YAAY,CAAC,IAAD,EAAOjB,OAAP,CAAnB;AACH,CAFD;AAIAvC,YAAY,CAAC8D,SAAb,CAAuB,cAAvB,EAAuC,UAASvB,OAAT,EAAkB;AACrD,MAAIvB,IAAJ;AACA,QAAM6I,aAAa,GAAG,KAAKA,aAA3B;;AACA,KAAG;AACC7I,IAAAA,IAAI,GAAGwC,YAAY,CAAC,IAAD,EAAOjB,OAAP,CAAnB;AACH,GAFD,QAESsH,aAAa,CAACrH,GAAd,CAAkBxB,IAAlB,CAFT;;AAGA,SAAOA,IAAP;AACH,CAPD;AASA/C,YAAY,CAAC6F,SAAb,CAAuB,cAAvB,EAAuC,UAASvB,OAAT,EAAkBmB,GAAlB,EAAuB;AAC1D;AACA;AACA;AAEA,MAAIoG,UAAU,GAAGpG,GAAG,CAAC5C,IAAJ,CAAS,CAAT,aAAuBrB,gBAAvB,IAA2C,KAAKuB,IAAhD,IAAwD,KAAKA,IAAL,CAAUmG,UAAV,EAAzE,CAL0D,CAO1D;;AACA,MAAI4C,WAAW,GAAGD,UAAU,GAAGA,UAAU,CAACxI,YAAX,IAA2BwI,UAAU,CAAC9I,IAAzC,GAAgD,IAA5E;;AAEA,SAAO,IAAP,EAAa;AACT,QAAIA,IAAI,GAAGwC,YAAY,CAAC,IAAD,EAAOjB,OAAP,CAAvB;AACA,QAAI,CAACwH,WAAD,IAAgBA,WAAW,IAAI/I,IAAnC,EACI,OAAOA,IAAP;AACP;AACJ,CAfD;AAiBA/B,UAAU,CAAC6E,SAAX,CAAqB,cAArB,EAAqC,UAASvB,OAAT,EAAkB;AACnD,MAAImB,GAAG,GAAG,KAAKyD,UAAL,EAAV;AACA,SAAO,CAACzD,GAAD,IAAQA,GAAG,CAACpB,YAAJ,CAAiBC,OAAjB,CAAf;AACH,CAHD,E,CAKA;;AACAnE,SAAS,CAAC0F,SAAV,CAAoB,cAApB,EAAoC9G,YAApC;AAEAiC,UAAU,CAAC6E,SAAX,CAAqB,cAArB,EAAqC,YAAW;AAC5C,SAAO,CAAC,KAAKqD,UAAL,GAAkBrF,UAAlB,CAA6BsD,MAA9B,IAAwC,CAAC,KAAKvE,KAAL,CAAW+B,MAAX,EAAhD;AACH,CAFD;AAIA3D,UAAU,CAAC6E,SAAX,CAAqB,YAArB,EAAmC,YAAW;AAC1C,SAAO,KAAK6B,MAAZ;AACH,CAFD;AAIA1G,UAAU,CAAC6E,SAAX,CAAqB,QAArB,EAA+B,YAAW;AACtC,SAAO,KAAK6B,MAAL,CAAYvE,MAAnB;AACH,CAFD;AAIApB,YAAY,CAAC8D,SAAb,CAAuB,0BAAvB,EAAmD,UAASvB,OAAT,EAAkB;AACjEA,EAAAA,OAAO,GAAG5F,QAAQ,CAAC4F,OAAD,EAAU;AACxBI,IAAAA,IAAI,EAAU,KADU;AAExBS,IAAAA,GAAG,EAAW,KAFU;AAGxBP,IAAAA,eAAe,EAAE,KAHO;AAIxBJ,IAAAA,WAAW,EAAG,KAJU;AAKxBuH,IAAAA,MAAM,EAAQ,KALU;AAMxBJ,IAAAA,QAAQ,EAAM,EANU;AAOxBlH,IAAAA,QAAQ,EAAM;AAPU,GAAV,CAAlB;AASA,MAAIH,OAAO,CAACyH,MAAZ,EAAoBzH,OAAO,CAACG,QAAR,GAAmB,IAAnB;;AACpB,MAAI,CAACuH,KAAK,CAACC,OAAN,CAAc3H,OAAO,CAACqH,QAAtB,CAAD,IACG,EAAErH,OAAO,CAACqH,QAAR,YAA4B1B,GAA9B,CADP,EAEE;AACE3F,IAAAA,OAAO,CAACqH,QAAR,GAAmB,EAAnB;AACH;;AACDrH,EAAAA,OAAO,CAACqH,QAAR,GAAmB,IAAI1B,GAAJ,CAAQ3F,OAAO,CAACqH,QAAhB,CAAnB,CAhBiE,CAiBjE;;AACArH,EAAAA,OAAO,CAACqH,QAAR,CAAiBjB,GAAjB,CAAqB,WAArB;AACA,SAAOpG,OAAP;AACH,CApBD;AAsBAvC,YAAY,CAAC8D,SAAb,CAAuB,cAAvB,EAAuC,UAASvB,OAAT,EAAkB;AACrDA,EAAAA,OAAO,GAAG,KAAK4H,wBAAL,CAA8B5H,OAA9B,CAAV,CADqD,CAGrD;AACA;AACA;AACA;;AACA,MAAI6H,KAAK,GAAG,CAAC,CAAb;AACA,MAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAI9H,OAAO,CAACE,WAAZ,EAAyB;AACrBhC,IAAAA,aAAa,GAAG,IAAIyH,GAAJ,EAAhB;AACH;;AAED,QAAM2B,aAAa,GAAG,KAAKA,aAAL,GAAqB,IAAI3B,GAAJ,EAA3C;;AACA,MAAI3F,OAAO,CAACQ,KAAZ,EAAmB;AACf,SAAKgE,OAAL,CAAaO,OAAb,CAAqBgD,OAArB;;AACA,QAAI/H,OAAO,CAACQ,KAAR,CAAcC,KAAlB,EAAyB;AACrBT,MAAAA,OAAO,CAACQ,KAAR,CAAcC,KAAd,CAAoBsE,OAApB,CAA4B,UAAShG,YAAT,EAAuB;AAC/CuI,QAAAA,aAAa,CAAClB,GAAd,CAAkBrH,YAAlB;AACH,OAFD;AAGH;AACJ;;AAED,MAAIgD,EAAE,GAAG,IAAInE,UAAJ,CAAe,UAASoE,IAAT,EAAeC,OAAf,EAAwB;AAC5C,QAAID,IAAI,YAAYlG,oBAApB,EAA0C;AACtC;AACA,UAAIkM,YAAY,GAAGH,KAAnB;AACA5F,MAAAA,OAAO;AACP4F,MAAAA,KAAK,GAAGG,YAAR;AACA,aAAO,IAAP,CALsC,CAKlB;AACvB;;AACD,QAAIhG,IAAI,YAAY5F,SAApB,EAA+B;AAC3B4F,MAAAA,IAAI,CAACV,SAAL,CAAeyD,OAAf,CAAuBgD,OAAvB;AACA;AACH;;AACD,QAAI/F,IAAI,CAACZ,cAAL,EAAJ,EAA2B;AACvBY,MAAAA,IAAI,CAACG,WAAL,CAAiBb,SAAjB,CAA2ByD,OAA3B,CAAmCgD,OAAnC;AACA;AACH;;AACD,QACI7J,aAAa,IACV8D,IAAI,YAAYtE,UADnB,IAEGsE,IAAI,CAACiG,KAAL,YAAsBjM,UAFzB,IAGG,CAACgG,IAAI,CAACiG,KAAL,CAAWxJ,IAHf,IAIGpE,SAAS,CAAC2F,OAAO,CAACE,WAAT,EAAsB8B,IAAI,CAACvD,IAAL,CAAUA,IAAhC,CALhB,EAME;AACEP,MAAAA,aAAa,CAACkI,GAAd,CAAkBpE,IAAI,CAACvD,IAAL,CAAUmG,UAAV,GAAuB3F,EAAzC;AACA;AACH;;AACD,QAAI+C,IAAI,YAAYnG,SAApB,EAA+B;AAC3B,UAAI4C,IAAJ;;AACA,SAAG;AACCA,QAAAA,IAAI,GAAG2I,MAAM,CAAC,EAAES,KAAH,CAAb;AACH,OAFD,QAES/J,cAAc,CAACmC,GAAf,CAAmBxB,IAAnB,CAFT;;AAGAuD,MAAAA,IAAI,CAACjD,YAAL,GAAoBN,IAApB;AACA,aAAO,IAAP;AACH;;AACD,QAAI,EAAEuB,OAAO,CAACa,GAAR,IAAeb,OAAO,CAACwB,QAAzB,KAAsCQ,IAAI,YAAYpF,eAA1D,EAA2E;AACvEkL,MAAAA,SAAS,CAACtF,IAAV,CAAeR,IAAI,CAAC4C,UAAL,EAAf;AACA;AACH;AACJ,GAtCQ,CAAT;AAwCA,OAAK/G,IAAL,CAAUkE,EAAV;;AAEA,MAAI/B,OAAO,CAACE,WAAR,IAAuBF,OAAO,CAACM,eAAnC,EAAoD;AAChDnC,IAAAA,kBAAkB,GAAG,IAAIwH,GAAJ,EAArB,CADgD,CAEhD;AACA;;AACAmC,IAAAA,SAAS,CAAC/C,OAAV,CAAkB5D,GAAG,IAAI;AACrB,UAAIA,GAAG,CAAC1C,IAAJ,CAASoE,MAAT,GAAkB,CAAlB,IAAuB1B,GAAG,CAACpB,YAAJ,CAAiBC,OAAjB,CAA3B,EAAsD;AAClD7B,QAAAA,kBAAkB,CAACiI,GAAnB,CAAuBjF,GAAG,CAAC1C,IAA3B;AACH;AACJ,KAJD;AAKH;;AAEDqJ,EAAAA,SAAS,CAAC/C,OAAV,CAAkB5D,GAAG,IAAI;AAAEA,IAAAA,GAAG,CAACZ,MAAJ,CAAWP,OAAX;AAAsB,GAAjD;AAEA9B,EAAAA,aAAa,GAAG,IAAhB;AACAC,EAAAA,kBAAkB,GAAG,IAArB;;AAEA,WAAS4J,OAAT,CAAiBnB,MAAjB,EAAyB;AACrB,UAAMsB,aAAa,GAAG,CAAClI,OAAO,CAACqH,QAAR,CAAiBpH,GAAjB,CAAqB2G,MAAM,CAACnI,IAA5B,CAAD,IACf,EAAEmI,MAAM,CAAC9H,MAAP,GAAgBd,uBAAlB,CADP;;AAEA,QAAIkK,aAAJ,EAAmB;AACfJ,MAAAA,SAAS,CAACtF,IAAV,CAAeoE,MAAf;AACH;AACJ;AACJ,CAzFD;AA2FAnJ,YAAY,CAAC8D,SAAb,CAAuB,sBAAvB,EAA+C,UAASvB,OAAT,EAAkB;AAC7D,QAAMQ,KAAK,GAAGR,OAAO,CAACQ,KAAR,IAAiBR,OAAO,CAACQ,KAAR,CAAcC,KAA7C;AACA,QAAM0H,KAAK,GAAG,IAAIxC,GAAJ,EAAd;AACA3F,EAAAA,OAAO,CAACqH,QAAR,CAAiBtC,OAAjB,CAAyBqD,QAAzB;AACA,OAAK5D,OAAL,CAAaO,OAAb,CAAqBsD,OAArB;AACA,OAAKxK,IAAL,CAAU,IAAID,UAAJ,CAAe,UAASoE,IAAT,EAAe;AACpC,QAAIA,IAAI,YAAY5F,SAApB,EAA+B4F,IAAI,CAACV,SAAL,CAAeyD,OAAf,CAAuBsD,OAAvB;AAC/B,QAAIrG,IAAI,YAAYpF,eAApB,EAAqCyL,OAAO,CAACrG,IAAI,CAAC4C,UAAL,EAAD,CAAP;AACxC,GAHS,CAAV;AAIA,SAAOuD,KAAP;;AAEA,WAASC,QAAT,CAAkB3J,IAAlB,EAAwB;AACpB0J,IAAAA,KAAK,CAAC/B,GAAN,CAAU3H,IAAV;AACH;;AAED,WAAS4J,OAAT,CAAiBlH,GAAjB,EAAsB;AAClB,QAAI1C,IAAI,GAAG0C,GAAG,CAAC1C,IAAf;AACA,QAAI0C,GAAG,CAACtC,MAAJ,IAAc2B,KAAd,IAAuBA,KAAK,CAACP,GAAN,CAAUxB,IAAV,CAA3B,EAA4CA,IAAI,GAAG+B,KAAK,CAACE,GAAN,CAAUjC,IAAV,CAAP,CAA5C,KACK,IAAI,CAAC0C,GAAG,CAACpB,YAAJ,CAAiBC,OAAjB,CAAL,EAAgC;AACrCoI,IAAAA,QAAQ,CAAC3J,IAAD,CAAR;AACH;AACJ,CArBD;AAuBAhB,YAAY,CAAC8D,SAAb,CAAuB,cAAvB,EAAuC,UAASvB,OAAT,EAAkB;AACrDoH,EAAAA,MAAM,CAACkB,KAAP;AACAlB,EAAAA,MAAM,CAACmB,IAAP;AACAvI,EAAAA,OAAO,GAAG,KAAK4H,wBAAL,CAA8B5H,OAA9B,CAAV;AACA,MAAImI,KAAK,GAAG,KAAKK,oBAAL,CAA0BxI,OAA1B,CAAZ;AACA,MAAImF,KAAK,GAAG,CAAZ;AACA,OAAKX,OAAL,CAAaO,OAAb,CAAqB0D,MAArB;AACA,OAAK5K,IAAL,CAAU,IAAID,UAAJ,CAAe,UAASoE,IAAT,EAAe;AACpC,QAAIA,IAAI,YAAY5F,SAApB,EAA+B4F,IAAI,CAACV,SAAL,CAAeyD,OAAf,CAAuB0D,MAAvB;AAC/B,QAAIzG,IAAI,YAAYpF,eAApB,EAAqC6L,MAAM,CAACzG,IAAI,CAAC4C,UAAL,EAAD,CAAN;AACxC,GAHS,CAAV;;AAKA,WAAS8D,SAAT,GAAqB;AACjB,QAAIjK,IAAJ;;AACA,OAAG;AACCA,MAAAA,IAAI,GAAG2I,MAAM,CAACjC,KAAK,EAAN,CAAb;AACH,KAFD,QAESgD,KAAK,CAAClI,GAAN,CAAUxB,IAAV,KAAmBX,cAAc,CAACmC,GAAf,CAAmBxB,IAAnB,CAF5B;;AAGA,WAAOA,IAAP;AACH;;AAED,WAASgK,MAAT,CAAgBtH,GAAhB,EAAqB;AACjB,QAAIA,GAAG,CAACtC,MAAJ,IAAcmB,OAAO,CAACQ,KAA1B,EAAiC;AACjC,QAAIW,GAAG,CAACpB,YAAJ,CAAiBC,OAAjB,CAAJ,EAA+B;AAC/B,QAAIA,OAAO,CAACqH,QAAR,CAAiBpH,GAAjB,CAAqBkB,GAAG,CAAC1C,IAAzB,CAAJ,EAAoC;AACpC,UAAMsC,YAAY,GAAGC,mBAAmB,CAACG,GAAD,CAAxC;AACA,UAAM1C,IAAI,GAAG0C,GAAG,CAAC1C,IAAJ,GAAWsC,YAAY,GAAGA,YAAY,CAACtC,IAAhB,GAAuBiK,SAAS,EAApE;AACAvH,IAAAA,GAAG,CAAC5C,IAAJ,CAASwG,OAAT,CAAiB,UAASnE,GAAT,EAAc;AAC3BA,MAAAA,GAAG,CAACnC,IAAJ,GAAWA,IAAX;AACH,KAFD;AAGA0C,IAAAA,GAAG,CAAC5B,UAAJ,CAAewF,OAAf,CAAuB,UAASnE,GAAT,EAAc;AACjCA,MAAAA,GAAG,CAACnC,IAAJ,GAAWA,IAAX;AACH,KAFD;AAGH;AACJ,CAjCD;AAmCAtC,QAAQ,CAACoF,SAAT,CAAmB,WAAnB,EAAgC7G,WAAhC;AACA2B,YAAY,CAACkF,SAAb,CAAuB,WAAvB,EAAoC,YAAW;AAC3C,SAAO,KAAKoH,WAAL,CAAiB,KAAKA,WAAL,CAAiB9F,MAAjB,GAA0B,CAA3C,CAAP;AACH,CAFD;AAIApF,YAAY,CAAC8D,SAAb,CAAuB,wBAAvB,EAAiD,UAASvB,OAAT,EAAkB;AAC/DA,EAAAA,OAAO,GAAG,KAAK4H,wBAAL,CAA8B5H,OAA9B,CAAV;;AACA,MAAI;AACA7D,IAAAA,QAAQ,CAAC0K,SAAT,CAAmB+B,KAAnB,GAA2B,UAASC,MAAT,EAAiBC,YAAjB,EAA+B;AACtD,WAAKC,MAAL,CAAYF,MAAZ,EAAoBC,YAApB;;AACA,UAAI,gBAAgBpM,UAAhB,IAA8B,CAAC,KAAKqD,YAAL,CAAkBC,OAAlB,CAAnC,EAA+D;AAC3DoH,QAAAA,MAAM,CAAC4B,QAAP,CAAgB,KAAKvK,IAArB,EAA2B,CAAC,CAA5B;AACH,OAFD,MAEO,IAAIuB,OAAO,CAACiJ,UAAZ,EAAwB;AAC3B,YAAI,gBAAgB3N,OAApB,EAA6B;AACzB8L,UAAAA,MAAM,CAAC4B,QAAP,CAAgB,KAAKE,QAArB,EAA+B,CAAC,CAAhC;AACH,SAFD,MAEO,IAAI,gBAAgB3M,OAApB,EAA6B;AAChC4M,UAAAA,WAAW,CAAC,KAAKD,QAAN,CAAX;AACH;AACJ;AACJ,KAXD;;AAYA9B,IAAAA,MAAM,CAAC4B,QAAP,CAAgB,KAAKI,eAAL,EAAhB,EAAwC,CAAxC;AACH,GAdD,SAcU;AACNjN,IAAAA,QAAQ,CAAC0K,SAAT,CAAmB+B,KAAnB,GAA2BzM,QAAQ,CAAC0K,SAAT,CAAmBkC,MAA9C;AACH;;AACD3B,EAAAA,MAAM,CAACmB,IAAP;;AAEA,WAASY,WAAT,CAAqBnH,IAArB,EAA2B;AACvB,QAAIA,IAAI,YAAY1F,UAApB,EAAgC;AAC5B8K,MAAAA,MAAM,CAAC4B,QAAP,CAAgBhH,IAAI,CAACiG,KAArB,EAA4B,CAAC,CAA7B;AACH,KAFD,MAEO,IAAIjG,IAAI,YAAY9G,eAApB,EAAqC;AACxCiO,MAAAA,WAAW,CAACnH,IAAI,CAACqH,UAAN,CAAX;AACAF,MAAAA,WAAW,CAACnH,IAAI,CAACsH,WAAN,CAAX;AACH,KAHM,MAGA,IAAItH,IAAI,YAAY3F,YAApB,EAAkC;AACrC8M,MAAAA,WAAW,CAACnH,IAAI,CAACuH,SAAL,EAAD,CAAX;AACH;AACJ;AACJ,CA/BD;;AAiCA,MAAMnC,MAAM,GAAG,CAAC,MAAM;AAClB,QAAMoC,OAAO,GAAG,yDAAyDC,KAAzD,CAA+D,EAA/D,CAAhB;AACA,QAAMC,MAAM,GAAG,aAAaD,KAAb,CAAmB,EAAnB,CAAf;AACA,MAAIE,KAAJ;AACA,MAAIC,SAAJ;;AACA,WAAStB,KAAT,GAAiB;AACbsB,IAAAA,SAAS,GAAG,IAAIjI,GAAJ,EAAZ;AACA6H,IAAAA,OAAO,CAACzE,OAAR,CAAgB,UAAS8E,EAAT,EAAa;AACzBD,MAAAA,SAAS,CAAC1I,GAAV,CAAc2I,EAAd,EAAkB,CAAlB;AACH,KAFD;AAGAH,IAAAA,MAAM,CAAC3E,OAAP,CAAe,UAAS8E,EAAT,EAAa;AACxBD,MAAAA,SAAS,CAAC1I,GAAV,CAAc2I,EAAd,EAAkB,CAAlB;AACH,KAFD;AAGH;;AACDzC,EAAAA,MAAM,CAAC4B,QAAP,GAAkB,UAASc,GAAT,EAAcC,KAAd,EAAqB;AACnC,SAAK,IAAIpH,CAAC,GAAGmH,GAAG,CAACjH,MAAjB,EAAyB,EAAEF,CAAF,IAAO,CAAhC,GAAoC;AAChCiH,MAAAA,SAAS,CAAC1I,GAAV,CAAc4I,GAAG,CAACnH,CAAD,CAAjB,EAAsBiH,SAAS,CAAClJ,GAAV,CAAcoJ,GAAG,CAACnH,CAAD,CAAjB,IAAwBoH,KAA9C;AACH;AACJ,GAJD;;AAKA,WAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACnB,WAAON,SAAS,CAAClJ,GAAV,CAAcwJ,CAAd,IAAmBN,SAAS,CAAClJ,GAAV,CAAcuJ,CAAd,CAA1B;AACH;;AACD7C,EAAAA,MAAM,CAACmB,IAAP,GAAc,YAAW;AACrBoB,IAAAA,KAAK,GAAGrP,SAAS,CAACkP,OAAD,EAAUQ,OAAV,CAAT,CAA4BG,MAA5B,CAAmC7P,SAAS,CAACoP,MAAD,EAASM,OAAT,CAA5C,CAAR;AACH,GAFD;;AAGA5C,EAAAA,MAAM,CAACkB,KAAP,GAAeA,KAAf;AACAA,EAAAA,KAAK;;AACL,WAASlB,MAAT,CAAgBgD,GAAhB,EAAqB;AACjB,QAAIC,GAAG,GAAG,EAAV;AAAA,QAAcC,IAAI,GAAG,EAArB;AACAF,IAAAA,GAAG;;AACH,OAAG;AACCA,MAAAA,GAAG;AACHC,MAAAA,GAAG,IAAIV,KAAK,CAACS,GAAG,GAAGE,IAAP,CAAZ;AACAF,MAAAA,GAAG,GAAGG,IAAI,CAACC,KAAL,CAAWJ,GAAG,GAAGE,IAAjB,CAAN;AACAA,MAAAA,IAAI,GAAG,EAAP;AACH,KALD,QAKSF,GAAG,GAAG,CALf;;AAMA,WAAOC,GAAP;AACH;;AACD,SAAOjD,MAAP;AACH,CAvCc,GAAf;;AAyCA,SACIA,MADJ,EAEIhJ,SAFJ","sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nimport {\n    defaults,\n    keep_name,\n    mergeSort,\n    push_uniq,\n    make_node,\n    return_false,\n    return_this,\n    return_true,\n    string_template,\n} from \"./utils/index.js\";\nimport {\n    AST_Arrow,\n    AST_Block,\n    AST_Call,\n    AST_Catch,\n    AST_Class,\n    AST_Conditional,\n    AST_DefClass,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Dot,\n    AST_Export,\n    AST_For,\n    AST_ForIn,\n    AST_Function,\n    AST_Import,\n    AST_IterationStatement,\n    AST_Label,\n    AST_LabeledStatement,\n    AST_LabelRef,\n    AST_Lambda,\n    AST_LoopControl,\n    AST_NameMapping,\n    AST_Node,\n    AST_Scope,\n    AST_Sequence,\n    AST_String,\n    AST_Sub,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_SymbolBlockDeclaration,\n    AST_SymbolCatch,\n    AST_SymbolClass,\n    AST_SymbolConst,\n    AST_SymbolDefClass,\n    AST_SymbolDefun,\n    AST_SymbolExport,\n    AST_SymbolFunarg,\n    AST_SymbolImport,\n    AST_SymbolLambda,\n    AST_SymbolLet,\n    AST_SymbolMethod,\n    AST_SymbolRef,\n    AST_SymbolVar,\n    AST_Toplevel,\n    AST_VarDef,\n    AST_With,\n    TreeWalker,\n    walk\n} from \"./ast.js\";\nimport {\n    RESERVED_WORDS,\n    js_error,\n} from \"./parse.js\";\n\nconst MASK_EXPORT_DONT_MANGLE = 1 << 0;\nconst MASK_EXPORT_WANT_MANGLE = 1 << 1;\n\nlet function_defs = null;\nlet unmangleable_names = null;\n\nclass SymbolDef {\n    constructor(scope, orig, init) {\n        this.name = orig.name;\n        this.orig = [ orig ];\n        this.init = init;\n        this.eliminated = 0;\n        this.assignments = 0;\n        this.scope = scope;\n        this.replaced = 0;\n        this.global = false;\n        this.export = 0;\n        this.mangled_name = null;\n        this.undeclared = false;\n        this.id = SymbolDef.next_id++;\n        this.chained = false;\n        this.direct_access = false;\n        this.escaped = 0;\n        this.recursive_refs = 0;\n        this.references = [];\n        this.should_replace = undefined;\n        this.single_use = false;\n        this.fixed = false;\n        Object.seal(this);\n    }\n    fixed_value() {\n        if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;\n        return this.fixed();\n    }\n    unmangleable(options) {\n        if (!options) options = {};\n\n        if (\n            function_defs &&\n            function_defs.has(this.id) &&\n            keep_name(options.keep_fnames, this.orig[0].name)\n        ) return true;\n\n        return this.global && !options.toplevel\n            || (this.export & MASK_EXPORT_DONT_MANGLE)\n            || this.undeclared\n            || !options.eval && this.scope.pinned()\n            || (this.orig[0] instanceof AST_SymbolLambda\n                  || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name)\n            || this.orig[0] instanceof AST_SymbolMethod\n            || (this.orig[0] instanceof AST_SymbolClass\n                  || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);\n    }\n    mangle(options) {\n        const cache = options.cache && options.cache.props;\n        if (this.global && cache && cache.has(this.name)) {\n            this.mangled_name = cache.get(this.name);\n        } else if (!this.mangled_name && !this.unmangleable(options)) {\n            var s = this.scope;\n            var sym = this.orig[0];\n            if (options.ie8 && sym instanceof AST_SymbolLambda)\n                s = s.parent_scope;\n            const redefinition = redefined_catch_def(this);\n            this.mangled_name = redefinition\n                ? redefinition.mangled_name || redefinition.name\n                : s.next_mangled(options, this);\n            if (this.global && cache) {\n                cache.set(this.name, this.mangled_name);\n            }\n        }\n    }\n}\n\nSymbolDef.next_id = 1;\n\nfunction redefined_catch_def(def) {\n    if (def.orig[0] instanceof AST_SymbolCatch\n        && def.scope.is_block_scope()\n    ) {\n        return def.scope.get_defun_scope().variables.get(def.name);\n    }\n}\n\nAST_Scope.DEFMETHOD(\"figure_out_scope\", function(options, { parent_scope = null, toplevel = this } = {}) {\n    options = defaults(options, {\n        cache: null,\n        ie8: false,\n        safari10: false,\n    });\n\n    if (!(toplevel instanceof AST_Toplevel)) {\n        throw new Error(\"Invalid toplevel scope\");\n    }\n\n    // pass 1: setup scope chaining and handle definitions\n    var scope = this.parent_scope = parent_scope;\n    var labels = new Map();\n    var defun = null;\n    var in_destructuring = null;\n    var for_scopes = [];\n    var tw = new TreeWalker((node, descend) => {\n        if (node.is_block_scope()) {\n            const save_scope = scope;\n            node.block_scope = scope = new AST_Scope(node);\n            scope._block_scope = true;\n            // AST_Try in the AST sadly *is* (not has) a body itself,\n            // and its catch and finally branches are children of the AST_Try itself\n            const parent_scope = node instanceof AST_Catch\n                ? save_scope.parent_scope\n                : save_scope;\n            scope.init_scope_vars(parent_scope);\n            scope.uses_with = save_scope.uses_with;\n            scope.uses_eval = save_scope.uses_eval;\n            if (options.safari10) {\n                if (node instanceof AST_For || node instanceof AST_ForIn) {\n                    for_scopes.push(scope);\n                }\n            }\n\n            if (node instanceof AST_Switch) {\n                // XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope\n                // AST_Switch has a scope within the body, but it itself \"is a block scope\"\n                // This means the switched expression has to belong to the outer scope\n                // while the body inside belongs to the switch itself.\n                // This is pretty nasty and warrants an AST change similar to AST_Try (read above)\n                const the_block_scope = scope;\n                scope = save_scope;\n                node.expression.walk(tw);\n                scope = the_block_scope;\n                for (let i = 0; i < node.body.length; i++) {\n                    node.body[i].walk(tw);\n                }\n            } else {\n                descend();\n            }\n            scope = save_scope;\n            return true;\n        }\n        if (node instanceof AST_Destructuring) {\n            const save_destructuring = in_destructuring;\n            in_destructuring = node;\n            descend();\n            in_destructuring = save_destructuring;\n            return true;\n        }\n        if (node instanceof AST_Scope) {\n            node.init_scope_vars(scope);\n            var save_scope = scope;\n            var save_defun = defun;\n            var save_labels = labels;\n            defun = scope = node;\n            labels = new Map();\n            descend();\n            scope = save_scope;\n            defun = save_defun;\n            labels = save_labels;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (node instanceof AST_LabeledStatement) {\n            var l = node.label;\n            if (labels.has(l.name)) {\n                throw new Error(string_template(\"Label {name} defined twice\", l));\n            }\n            labels.set(l.name, l);\n            descend();\n            labels.delete(l.name);\n            return true;        // no descend again\n        }\n        if (node instanceof AST_With) {\n            for (var s = scope; s; s = s.parent_scope)\n                s.uses_with = true;\n            return;\n        }\n        if (node instanceof AST_Symbol) {\n            node.scope = scope;\n        }\n        if (node instanceof AST_Label) {\n            node.thedef = node;\n            node.references = [];\n        }\n        if (node instanceof AST_SymbolLambda) {\n            defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n        } else if (node instanceof AST_SymbolDefun) {\n            // Careful here, the scope where this should be defined is\n            // the parent scope.  The reason is that we enter a new\n            // scope when we encounter the AST_Defun node (which is\n            // instanceof AST_Scope) but we get to the symbol a bit\n            // later.\n            mark_export((node.scope = defun.parent_scope.get_defun_scope()).def_function(node, defun), 1);\n        } else if (node instanceof AST_SymbolClass) {\n            mark_export(defun.def_variable(node, defun), 1);\n        } else if (node instanceof AST_SymbolImport) {\n            scope.def_variable(node);\n        } else if (node instanceof AST_SymbolDefClass) {\n            // This deals with the name of the class being available\n            // inside the class.\n            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);\n        } else if (\n            node instanceof AST_SymbolVar\n            || node instanceof AST_SymbolLet\n            || node instanceof AST_SymbolConst\n            || node instanceof AST_SymbolCatch\n        ) {\n            var def;\n            if (node instanceof AST_SymbolBlockDeclaration) {\n                def = scope.def_variable(node, null);\n            } else {\n                def = defun.def_variable(node, node.TYPE == \"SymbolVar\" ? null : undefined);\n            }\n            if (!def.orig.every((sym) => {\n                if (sym === node) return true;\n                if (node instanceof AST_SymbolBlockDeclaration) {\n                    return sym instanceof AST_SymbolLambda;\n                }\n                return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst);\n            })) {\n                js_error(\n                    `\"${node.name}\" is redeclared`,\n                    node.start.file,\n                    node.start.line,\n                    node.start.col,\n                    node.start.pos\n                );\n            }\n            if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);\n            if (defun !== scope) {\n                node.mark_enclosed();\n                var def = scope.find_variable(node);\n                if (node.thedef !== def) {\n                    node.thedef = def;\n                    node.reference();\n                }\n            }\n        } else if (node instanceof AST_LabelRef) {\n            var sym = labels.get(node.name);\n            if (!sym) throw new Error(string_template(\"Undefined label {name} [{line},{col}]\", {\n                name: node.name,\n                line: node.start.line,\n                col: node.start.col\n            }));\n            node.thedef = sym;\n        }\n        if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {\n            js_error(\n                `\"${node.TYPE}\" statement may only appear at the top level`,\n                node.start.file,\n                node.start.line,\n                node.start.col,\n                node.start.pos\n            );\n        }\n    });\n    this.walk(tw);\n\n    function mark_export(def, level) {\n        if (in_destructuring) {\n            var i = 0;\n            do {\n                level++;\n            } while (tw.parent(i++) !== in_destructuring);\n        }\n        var node = tw.parent(level);\n        if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {\n            var exported = node.exported_definition;\n            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {\n                def.export = MASK_EXPORT_WANT_MANGLE;\n            }\n        }\n    }\n\n    // pass 2: find back references and eval\n    const is_toplevel = this instanceof AST_Toplevel;\n    if (is_toplevel) {\n        this.globals = new Map();\n    }\n\n    var tw = new TreeWalker(node => {\n        if (node instanceof AST_LoopControl && node.label) {\n            node.label.thedef.references.push(node);\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            var name = node.name;\n            if (name == \"eval\" && tw.parent() instanceof AST_Call) {\n                for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {\n                    s.uses_eval = true;\n                }\n            }\n            var sym;\n            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name\n                || !(sym = node.scope.find_variable(name))) {\n\n                sym = toplevel.def_global(node);\n                if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;\n            } else if (sym.scope instanceof AST_Lambda && name == \"arguments\") {\n                sym.scope.uses_arguments = true;\n            }\n            node.thedef = sym;\n            node.reference();\n            if (node.scope.is_block_scope()\n                && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {\n                node.scope = node.scope.get_defun_scope();\n            }\n            return true;\n        }\n        // ensure mangling works if catch reuses a scope variable\n        var def;\n        if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {\n            var s = node.scope;\n            while (s) {\n                push_uniq(s.enclosed, def);\n                if (s === def.scope) break;\n                s = s.parent_scope;\n            }\n        }\n    });\n    this.walk(tw);\n\n    // pass 3: work around IE8 and Safari catch scope bugs\n    if (options.ie8 || options.safari10) {\n        walk(this, node => {\n            if (node instanceof AST_SymbolCatch) {\n                var name = node.name;\n                var refs = node.thedef.references;\n                var scope = node.scope.get_defun_scope();\n                var def = scope.find_variable(name)\n                    || toplevel.globals.get(name)\n                    || scope.def_variable(node);\n                refs.forEach(function(ref) {\n                    ref.thedef = def;\n                    ref.reference();\n                });\n                node.thedef = def;\n                node.reference();\n                return true;\n            }\n        });\n    }\n\n    // pass 4: add symbol definitions to loop scopes\n    // Safari/Webkit bug workaround - loop init let variable shadowing argument.\n    // https://github.com/mishoo/UglifyJS2/issues/1753\n    // https://bugs.webkit.org/show_bug.cgi?id=171041\n    if (options.safari10) {\n        for (const scope of for_scopes) {\n            scope.parent_scope.variables.forEach(function(def) {\n                push_uniq(scope.enclosed, def);\n            });\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"def_global\", function(node) {\n    var globals = this.globals, name = node.name;\n    if (globals.has(name)) {\n        return globals.get(name);\n    } else {\n        var g = new SymbolDef(this, node);\n        g.undeclared = true;\n        g.global = true;\n        globals.set(name, g);\n        return g;\n    }\n});\n\nAST_Scope.DEFMETHOD(\"init_scope_vars\", function(parent_scope) {\n    this.variables = new Map();         // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n    this.functions = new Map();         // map name to AST_SymbolDefun (functions defined in this scope)\n    this.uses_with = false;             // will be set to true if this or some nested scope uses the `with` statement\n    this.uses_eval = false;             // will be set to true if this or nested scope uses the global `eval`\n    this.parent_scope = parent_scope;   // the parent scope\n    this.enclosed = [];                 // a list of variables from this or outer scope(s) that are referenced from this or inner scopes\n    this.cname = -1;                    // the current index for mangling functions/variables\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n        || (this.parent_scope && this.parent_scope.conflicting_def(name))\n    );\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def_shallow\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n    );\n});\n\nAST_Scope.DEFMETHOD(\"add_child_scope\", function (scope) {\n    // `scope` is going to be moved into `this` right now.\n    // Update the required scopes' information\n\n    if (scope.parent_scope === this) return;\n\n    scope.parent_scope = this;\n\n    // TODO uses_with, uses_eval, etc\n\n    const scope_ancestry = (() => {\n        const ancestry = [];\n        let cur = this;\n        do {\n            ancestry.push(cur);\n        } while ((cur = cur.parent_scope));\n        ancestry.reverse();\n        return ancestry;\n    })();\n\n    const new_scope_enclosed_set = new Set(scope.enclosed);\n    const to_enclose = [];\n    for (const scope_topdown of scope_ancestry) {\n        to_enclose.forEach(e => push_uniq(scope_topdown.enclosed, e));\n        for (const def of scope_topdown.variables.values()) {\n            if (new_scope_enclosed_set.has(def)) {\n                push_uniq(to_enclose, def);\n                push_uniq(scope_topdown.enclosed, def);\n            }\n        }\n    }\n});\n\nfunction find_scopes_visible_from(scopes) {\n    const found_scopes = new Set();\n\n    for (const scope of new Set(scopes)) {\n        (function bubble_up(scope) {\n            if (scope == null || found_scopes.has(scope)) return;\n\n            found_scopes.add(scope);\n\n            bubble_up(scope.parent_scope);\n        })(scope);\n    }\n\n    return [...found_scopes];\n}\n\n// Creates a symbol during compression\nAST_Scope.DEFMETHOD(\"create_symbol\", function(SymClass, {\n    source,\n    tentative_name,\n    scope,\n    conflict_scopes = [scope],\n    init = null\n} = {}) {\n    let symbol_name;\n\n    conflict_scopes = find_scopes_visible_from(conflict_scopes);\n\n    if (tentative_name) {\n        // Implement hygiene (no new names are conflicting with existing names)\n        tentative_name =\n            symbol_name =\n            tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n\n        let i = 0;\n        while (conflict_scopes.find(s => s.conflicting_def_shallow(symbol_name))) {\n            symbol_name = tentative_name + \"$\" + i++;\n        }\n    }\n\n    if (!symbol_name) {\n        throw new Error(\"No symbol name could be generated in create_symbol()\");\n    }\n\n    const symbol = make_node(SymClass, source, {\n        name: symbol_name,\n        scope\n    });\n\n    this.def_variable(symbol, init || null);\n\n    symbol.mark_enclosed();\n\n    return symbol;\n});\n\n\nAST_Node.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Class.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Lambda.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Toplevel.DEFMETHOD(\"is_block_scope\", return_false);\nAST_SwitchBranch.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Block.DEFMETHOD(\"is_block_scope\", return_true);\nAST_Scope.DEFMETHOD(\"is_block_scope\", function () {\n    return this._block_scope || false;\n});\nAST_IterationStatement.DEFMETHOD(\"is_block_scope\", return_true);\n\nAST_Lambda.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n    this.def_variable(new AST_SymbolFunarg({\n        name: \"arguments\",\n        start: this.start,\n        end: this.end\n    }));\n});\n\nAST_Arrow.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n});\n\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function() {\n    var def = this.definition();\n    var s = this.scope;\n    while (s) {\n        push_uniq(s.enclosed, def);\n        if (s === def.scope) break;\n        s = s.parent_scope;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"reference\", function() {\n    this.definition().references.push(this);\n    this.mark_enclosed();\n});\n\nAST_Scope.DEFMETHOD(\"find_variable\", function(name) {\n    if (name instanceof AST_Symbol) name = name.name;\n    return this.variables.get(name)\n        || (this.parent_scope && this.parent_scope.find_variable(name));\n});\n\nAST_Scope.DEFMETHOD(\"def_function\", function(symbol, init) {\n    var def = this.def_variable(symbol, init);\n    if (!def.init || def.init instanceof AST_Defun) def.init = init;\n    this.functions.set(symbol.name, def);\n    return def;\n});\n\nAST_Scope.DEFMETHOD(\"def_variable\", function(symbol, init) {\n    var def = this.variables.get(symbol.name);\n    if (def) {\n        def.orig.push(symbol);\n        if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {\n            def.init = init;\n        }\n    } else {\n        def = new SymbolDef(this, symbol, init);\n        this.variables.set(symbol.name, def);\n        def.global = !this.parent_scope;\n    }\n    return symbol.thedef = def;\n});\n\nfunction next_mangled(scope, options) {\n    var ext = scope.enclosed;\n    out: while (true) {\n        var m = base54(++scope.cname);\n        if (RESERVED_WORDS.has(m)) continue; // skip over \"do\"\n\n        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not\n        // shadow a name reserved from mangling.\n        if (options.reserved.has(m)) continue;\n\n        // Functions with short names might collide with base54 output\n        // and therefore cause collisions when keep_fnames is true.\n        if (unmangleable_names && unmangleable_names.has(m)) continue out;\n\n        // we must ensure that the mangled name does not shadow a name\n        // from some parent scope that is referenced in this or in\n        // inner scopes.\n        for (let i = ext.length; --i >= 0;) {\n            const def = ext[i];\n            const name = def.mangled_name || (def.unmangleable(options) && def.name);\n            if (m == name) continue out;\n        }\n        return m;\n    }\n}\n\nAST_Scope.DEFMETHOD(\"next_mangled\", function(options) {\n    return next_mangled(this, options);\n});\n\nAST_Toplevel.DEFMETHOD(\"next_mangled\", function(options) {\n    let name;\n    const mangled_names = this.mangled_names;\n    do {\n        name = next_mangled(this, options);\n    } while (mangled_names.has(name));\n    return name;\n});\n\nAST_Function.DEFMETHOD(\"next_mangled\", function(options, def) {\n    // #179, #326\n    // in Safari strict mode, something like (function x(x){...}) is a syntax error;\n    // a function expression's argument cannot shadow the function expression's name\n\n    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();\n\n    // the function's mangled_name is null when keep_fnames is true\n    var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;\n\n    while (true) {\n        var name = next_mangled(this, options);\n        if (!tricky_name || tricky_name != name)\n            return name;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"unmangleable\", function(options) {\n    var def = this.definition();\n    return !def || def.unmangleable(options);\n});\n\n// labels are always mangleable\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\n\nAST_Symbol.DEFMETHOD(\"unreferenced\", function() {\n    return !this.definition().references.length && !this.scope.pinned();\n});\n\nAST_Symbol.DEFMETHOD(\"definition\", function() {\n    return this.thedef;\n});\n\nAST_Symbol.DEFMETHOD(\"global\", function() {\n    return this.thedef.global;\n});\n\nAST_Toplevel.DEFMETHOD(\"_default_mangler_options\", function(options) {\n    options = defaults(options, {\n        eval        : false,\n        ie8         : false,\n        keep_classnames: false,\n        keep_fnames : false,\n        module      : false,\n        reserved    : [],\n        toplevel    : false,\n    });\n    if (options.module) options.toplevel = true;\n    if (!Array.isArray(options.reserved)\n        && !(options.reserved instanceof Set)\n    ) {\n        options.reserved = [];\n    }\n    options.reserved = new Set(options.reserved);\n    // Never mangle arguments\n    options.reserved.add(\"arguments\");\n    return options;\n});\n\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function(options) {\n    options = this._default_mangler_options(options);\n\n    // We only need to mangle declaration nodes.  Special logic wired\n    // into the code generator will display the mangled name if it's\n    // present (and for AST_SymbolRef-s it'll use the mangled name of\n    // the AST_SymbolDeclaration that it points to).\n    var lname = -1;\n    var to_mangle = [];\n\n    if (options.keep_fnames) {\n        function_defs = new Set();\n    }\n\n    const mangled_names = this.mangled_names = new Set();\n    if (options.cache) {\n        this.globals.forEach(collect);\n        if (options.cache.props) {\n            options.cache.props.forEach(function(mangled_name) {\n                mangled_names.add(mangled_name);\n            });\n        }\n    }\n\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_LabeledStatement) {\n            // lname is incremented when we get to the AST_Label\n            var save_nesting = lname;\n            descend();\n            lname = save_nesting;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (node instanceof AST_Scope) {\n            node.variables.forEach(collect);\n            return;\n        }\n        if (node.is_block_scope()) {\n            node.block_scope.variables.forEach(collect);\n            return;\n        }\n        if (\n            function_defs\n            && node instanceof AST_VarDef\n            && node.value instanceof AST_Lambda\n            && !node.value.name\n            && keep_name(options.keep_fnames, node.name.name)\n        ) {\n            function_defs.add(node.name.definition().id);\n            return;\n        }\n        if (node instanceof AST_Label) {\n            let name;\n            do {\n                name = base54(++lname);\n            } while (RESERVED_WORDS.has(name));\n            node.mangled_name = name;\n            return true;\n        }\n        if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {\n            to_mangle.push(node.definition());\n            return;\n        }\n    });\n\n    this.walk(tw);\n\n    if (options.keep_fnames || options.keep_classnames) {\n        unmangleable_names = new Set();\n        // Collect a set of short names which are unmangleable,\n        // for use in avoiding collisions in next_mangled.\n        to_mangle.forEach(def => {\n            if (def.name.length < 6 && def.unmangleable(options)) {\n                unmangleable_names.add(def.name);\n            }\n        });\n    }\n\n    to_mangle.forEach(def => { def.mangle(options); });\n\n    function_defs = null;\n    unmangleable_names = null;\n\n    function collect(symbol) {\n        const should_mangle = !options.reserved.has(symbol.name)\n            && !(symbol.export & MASK_EXPORT_DONT_MANGLE);\n        if (should_mangle) {\n            to_mangle.push(symbol);\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function(options) {\n    const cache = options.cache && options.cache.props;\n    const avoid = new Set();\n    options.reserved.forEach(to_avoid);\n    this.globals.forEach(add_def);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(add_def);\n        if (node instanceof AST_SymbolCatch) add_def(node.definition());\n    }));\n    return avoid;\n\n    function to_avoid(name) {\n        avoid.add(name);\n    }\n\n    function add_def(def) {\n        var name = def.name;\n        if (def.global && cache && cache.has(name)) name = cache.get(name);\n        else if (!def.unmangleable(options)) return;\n        to_avoid(name);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"expand_names\", function(options) {\n    base54.reset();\n    base54.sort();\n    options = this._default_mangler_options(options);\n    var avoid = this.find_colliding_names(options);\n    var cname = 0;\n    this.globals.forEach(rename);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(rename);\n        if (node instanceof AST_SymbolCatch) rename(node.definition());\n    }));\n\n    function next_name() {\n        var name;\n        do {\n            name = base54(cname++);\n        } while (avoid.has(name) || RESERVED_WORDS.has(name));\n        return name;\n    }\n\n    function rename(def) {\n        if (def.global && options.cache) return;\n        if (def.unmangleable(options)) return;\n        if (options.reserved.has(def.name)) return;\n        const redefinition = redefined_catch_def(def);\n        const name = def.name = redefinition ? redefinition.name : next_name();\n        def.orig.forEach(function(sym) {\n            sym.name = name;\n        });\n        def.references.forEach(function(sym) {\n            sym.name = name;\n        });\n    }\n});\n\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function() {\n    return this.expressions[this.expressions.length - 1];\n});\n\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function(options) {\n    options = this._default_mangler_options(options);\n    try {\n        AST_Node.prototype.print = function(stream, force_parens) {\n            this._print(stream, force_parens);\n            if (this instanceof AST_Symbol && !this.unmangleable(options)) {\n                base54.consider(this.name, -1);\n            } else if (options.properties) {\n                if (this instanceof AST_Dot) {\n                    base54.consider(this.property, -1);\n                } else if (this instanceof AST_Sub) {\n                    skip_string(this.property);\n                }\n            }\n        };\n        base54.consider(this.print_to_string(), 1);\n    } finally {\n        AST_Node.prototype.print = AST_Node.prototype._print;\n    }\n    base54.sort();\n\n    function skip_string(node) {\n        if (node instanceof AST_String) {\n            base54.consider(node.value, -1);\n        } else if (node instanceof AST_Conditional) {\n            skip_string(node.consequent);\n            skip_string(node.alternative);\n        } else if (node instanceof AST_Sequence) {\n            skip_string(node.tail_node());\n        }\n    }\n});\n\nconst base54 = (() => {\n    const leading = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\".split(\"\");\n    const digits = \"0123456789\".split(\"\");\n    let chars;\n    let frequency;\n    function reset() {\n        frequency = new Map();\n        leading.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n        digits.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n    }\n    base54.consider = function(str, delta) {\n        for (var i = str.length; --i >= 0;) {\n            frequency.set(str[i], frequency.get(str[i]) + delta);\n        }\n    };\n    function compare(a, b) {\n        return frequency.get(b) - frequency.get(a);\n    }\n    base54.sort = function() {\n        chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));\n    };\n    base54.reset = reset;\n    reset();\n    function base54(num) {\n        var ret = \"\", base = 54;\n        num++;\n        do {\n            num--;\n            ret += chars[num % base];\n            num = Math.floor(num / base);\n            base = 64;\n        } while (num > 0);\n        return ret;\n    }\n    return base54;\n})();\n\nexport {\n    base54,\n    SymbolDef,\n};\n"]},"metadata":{},"sourceType":"module"}