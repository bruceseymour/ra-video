{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.isSerializableProps = isSerializableProps;\nexports.SerializableError = void 0;\nconst regexpPlainIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\nfunction isSerializableProps(page, method, input) {\n  if (!isPlainObject(input)) {\n    throw new SerializableError(page, method, '', `Props must be returned as a plain object from ${method}: \\`{ props: { ... } }\\`.`);\n  }\n\n  function visit(visited, value, path) {\n    if (visited.has(value)) {\n      throw new SerializableError(page, method, path, `Circular references cannot be expressed in JSON (references: \\`${visited.get(value) || '(self)'}\\`).`);\n    }\n\n    visited.set(value, path);\n  }\n\n  function isSerializable(refs, value, path) {\n    const type = typeof value;\n\n    if ( // `null` can be serialized, but not `undefined`.\n    value === null || // n.b. `bigint`, `function`, `symbol`, and `undefined` cannot be\n    // serialized.\n    //\n    // `object` is special-cased below, as it may represent `null`, an Array,\n    // a plain object, a class, et al.\n    type === 'boolean' || type === 'number' || type === 'string') {\n      return true;\n    }\n\n    if (type === 'undefined') {\n      throw new SerializableError(page, method, path, '`undefined` cannot be serialized as JSON. Please use `null` or omit this value.');\n    }\n\n    if (isPlainObject(value)) {\n      visit(refs, value, path);\n\n      if (Object.entries(value).every(([key, nestedValue]) => {\n        const nextPath = regexpPlainIdentifier.test(key) ? `${path}.${key}` : `${path}[${JSON.stringify(key)}]`;\n        const newRefs = new Map(refs);\n        return isSerializable(newRefs, key, nextPath) && isSerializable(newRefs, nestedValue, nextPath);\n      })) {\n        return true;\n      }\n\n      throw new SerializableError(page, method, path, `invariant: Unknown error encountered in Object.`);\n    }\n\n    if (Array.isArray(value)) {\n      visit(refs, value, path);\n\n      if (value.every((nestedValue, index) => {\n        const newRefs = new Map(refs);\n        return isSerializable(newRefs, nestedValue, `${path}[${index}]`);\n      })) {\n        return true;\n      }\n\n      throw new SerializableError(page, method, path, `invariant: Unknown error encountered in Array.`);\n    } // None of these can be expressed as JSON:\n    // const type: \"bigint\" | \"symbol\" | \"object\" | \"function\"\n\n\n    throw new SerializableError(page, method, path, '`' + type + '`' + (type === 'object' ? ` (\"${Object.prototype.toString.call(value)}\")` : '') + ' cannot be serialized as JSON. Please only return JSON serializable data types.');\n  }\n\n  return isSerializable(new Map(), input, '');\n}\n\nclass SerializableError extends Error {\n  constructor(page, method, path, message) {\n    super(path ? `Error serializing \\`${path}\\` returned from \\`${method}\\` in \"${page}\".\\nReason: ${message}` : `Error serializing props returned from \\`${method}\\` in \"${page}\".\\nReason: ${message}`);\n  }\n\n}\n\nexports.SerializableError = SerializableError;","map":{"version":3,"sources":["../../lib/is-serializable-props.ts"],"names":["regexpPlainIdentifier","Object","prototype","isPlainObject","method","visited","type","value","visit","nextPath","path","key","JSON","newRefs","isSerializable","Array","index","Error","constructor","page","message"],"mappings":"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","sourcesContent":["const regexpPlainIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nfunction isPlainObject(value: any): boolean {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n\nexport function isSerializableProps(\n  page: string,\n  method: string,\n  input: any\n): true {\n  if (!isPlainObject(input)) {\n    throw new SerializableError(\n      page,\n      method,\n      '',\n      `Props must be returned as a plain object from ${method}: \\`{ props: { ... } }\\`.`\n    )\n  }\n\n  function visit(visited: Map<any, string>, value: any, path: string) {\n    if (visited.has(value)) {\n      throw new SerializableError(\n        page,\n        method,\n        path,\n        `Circular references cannot be expressed in JSON (references: \\`${\n          visited.get(value) || '(self)'\n        }\\`).`\n      )\n    }\n\n    visited.set(value, path)\n  }\n\n  function isSerializable(\n    refs: Map<any, string>,\n    value: any,\n    path: string\n  ): true {\n    const type = typeof value\n    if (\n      // `null` can be serialized, but not `undefined`.\n      value === null ||\n      // n.b. `bigint`, `function`, `symbol`, and `undefined` cannot be\n      // serialized.\n      //\n      // `object` is special-cased below, as it may represent `null`, an Array,\n      // a plain object, a class, et al.\n      type === 'boolean' ||\n      type === 'number' ||\n      type === 'string'\n    ) {\n      return true\n    }\n\n    if (type === 'undefined') {\n      throw new SerializableError(\n        page,\n        method,\n        path,\n        '`undefined` cannot be serialized as JSON. Please use `null` or omit this value.'\n      )\n    }\n\n    if (isPlainObject(value)) {\n      visit(refs, value, path)\n\n      if (\n        Object.entries(value).every(([key, nestedValue]) => {\n          const nextPath = regexpPlainIdentifier.test(key)\n            ? `${path}.${key}`\n            : `${path}[${JSON.stringify(key)}]`\n\n          const newRefs = new Map(refs)\n          return (\n            isSerializable(newRefs, key, nextPath) &&\n            isSerializable(newRefs, nestedValue, nextPath)\n          )\n        })\n      ) {\n        return true\n      }\n\n      throw new SerializableError(\n        page,\n        method,\n        path,\n        `invariant: Unknown error encountered in Object.`\n      )\n    }\n\n    if (Array.isArray(value)) {\n      visit(refs, value, path)\n\n      if (\n        value.every((nestedValue, index) => {\n          const newRefs = new Map(refs)\n          return isSerializable(newRefs, nestedValue, `${path}[${index}]`)\n        })\n      ) {\n        return true\n      }\n\n      throw new SerializableError(\n        page,\n        method,\n        path,\n        `invariant: Unknown error encountered in Array.`\n      )\n    }\n\n    // None of these can be expressed as JSON:\n    // const type: \"bigint\" | \"symbol\" | \"object\" | \"function\"\n    throw new SerializableError(\n      page,\n      method,\n      path,\n      '`' +\n        type +\n        '`' +\n        (type === 'object'\n          ? ` (\"${Object.prototype.toString.call(value)}\")`\n          : '') +\n        ' cannot be serialized as JSON. Please only return JSON serializable data types.'\n    )\n  }\n\n  return isSerializable(new Map(), input, '')\n}\n\nexport class SerializableError extends Error {\n  constructor(page: string, method: string, path: string, message: string) {\n    super(\n      path\n        ? `Error serializing \\`${path}\\` returned from \\`${method}\\` in \"${page}\".\\nReason: ${message}`\n        : `Error serializing props returned from \\`${method}\\` in \"${page}\".\\nReason: ${message}`\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}