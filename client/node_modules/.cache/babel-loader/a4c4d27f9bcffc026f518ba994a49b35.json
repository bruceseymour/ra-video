{"ast":null,"code":"import { AST_Array, AST_Atom, AST_Await, AST_BigInt, AST_Binary, AST_Block, AST_Call, AST_Catch, AST_Chain, AST_Class, AST_ClassProperty, AST_ConciseMethod, AST_Conditional, AST_Debugger, AST_Definitions, AST_Destructuring, AST_Directive, AST_Do, AST_Dot, AST_EmptyStatement, AST_Expansion, AST_Export, AST_Finally, AST_For, AST_ForIn, AST_ForOf, AST_If, AST_Import, AST_ImportMeta, AST_Jump, AST_LabeledStatement, AST_Lambda, AST_LoopControl, AST_NameMapping, AST_NewTarget, AST_Node, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrefixedTemplateString, AST_PropAccess, AST_RegExp, AST_Sequence, AST_SimpleStatement, AST_String, AST_Super, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Toplevel, AST_Try, AST_Unary, AST_VarDef, AST_While, AST_With, AST_Yield } from \"./ast.js\";\n\nconst shallow_cmp = (node1, node2) => {\n  return node1 === null && node2 === null || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2);\n};\n\nexport const equivalent_to = (tree1, tree2) => {\n  if (!shallow_cmp(tree1, tree2)) return false;\n  const walk_1_state = [tree1];\n  const walk_2_state = [tree2];\n  const walk_1_push = walk_1_state.push.bind(walk_1_state);\n  const walk_2_push = walk_2_state.push.bind(walk_2_state);\n\n  while (walk_1_state.length && walk_2_state.length) {\n    const node_1 = walk_1_state.pop();\n    const node_2 = walk_2_state.pop();\n    if (!shallow_cmp(node_1, node_2)) return false;\n\n    node_1._children_backwards(walk_1_push);\n\n    node_2._children_backwards(walk_2_push);\n\n    if (walk_1_state.length !== walk_2_state.length) {\n      // Different number of children\n      return false;\n    }\n  }\n\n  return walk_1_state.length == 0 && walk_2_state.length == 0;\n}; // Creates a shallow compare function\n\nconst mkshallow = props => {\n  const comparisons = Object.keys(props).map(key => {\n    if (props[key] === \"eq\") {\n      return `this.${key} === other.${key}`;\n    } else if (props[key] === \"exist\") {\n      return `(this.${key} == null ? other.${key} == null : this.${key} === other.${key})`;\n    } else {\n      throw new Error(`mkshallow: Unexpected instruction: ${props[key]}`);\n    }\n  }).join(\" && \");\n  return new Function(\"other\", \"return \" + comparisons);\n};\n\nconst pass_through = () => true;\n\nAST_Node.prototype.shallow_cmp = function () {\n  throw new Error(\"did not find a shallow_cmp function for \" + this.constructor.name);\n};\n\nAST_Debugger.prototype.shallow_cmp = pass_through;\nAST_Directive.prototype.shallow_cmp = mkshallow({\n  value: \"eq\"\n});\nAST_SimpleStatement.prototype.shallow_cmp = pass_through;\nAST_Block.prototype.shallow_cmp = pass_through;\nAST_EmptyStatement.prototype.shallow_cmp = pass_through;\nAST_LabeledStatement.prototype.shallow_cmp = mkshallow({\n  \"label.name\": \"eq\"\n});\nAST_Do.prototype.shallow_cmp = pass_through;\nAST_While.prototype.shallow_cmp = pass_through;\nAST_For.prototype.shallow_cmp = mkshallow({\n  init: \"exist\",\n  condition: \"exist\",\n  step: \"exist\"\n});\nAST_ForIn.prototype.shallow_cmp = pass_through;\nAST_ForOf.prototype.shallow_cmp = pass_through;\nAST_With.prototype.shallow_cmp = pass_through;\nAST_Toplevel.prototype.shallow_cmp = pass_through;\nAST_Expansion.prototype.shallow_cmp = pass_through;\nAST_Lambda.prototype.shallow_cmp = mkshallow({\n  is_generator: \"eq\",\n  async: \"eq\"\n});\nAST_Destructuring.prototype.shallow_cmp = mkshallow({\n  is_array: \"eq\"\n});\nAST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;\nAST_TemplateString.prototype.shallow_cmp = pass_through;\nAST_TemplateSegment.prototype.shallow_cmp = mkshallow({\n  \"value\": \"eq\"\n});\nAST_Jump.prototype.shallow_cmp = pass_through;\nAST_LoopControl.prototype.shallow_cmp = pass_through;\nAST_Await.prototype.shallow_cmp = pass_through;\nAST_Yield.prototype.shallow_cmp = mkshallow({\n  is_star: \"eq\"\n});\nAST_If.prototype.shallow_cmp = mkshallow({\n  alternative: \"exist\"\n});\nAST_Switch.prototype.shallow_cmp = pass_through;\nAST_SwitchBranch.prototype.shallow_cmp = pass_through;\nAST_Try.prototype.shallow_cmp = mkshallow({\n  bcatch: \"exist\",\n  bfinally: \"exist\"\n});\nAST_Catch.prototype.shallow_cmp = mkshallow({\n  argname: \"exist\"\n});\nAST_Finally.prototype.shallow_cmp = pass_through;\nAST_Definitions.prototype.shallow_cmp = pass_through;\nAST_VarDef.prototype.shallow_cmp = mkshallow({\n  value: \"exist\"\n});\nAST_NameMapping.prototype.shallow_cmp = pass_through;\nAST_Import.prototype.shallow_cmp = mkshallow({\n  imported_name: \"exist\",\n  imported_names: \"exist\"\n});\nAST_ImportMeta.prototype.shallow_cmp = pass_through;\nAST_Export.prototype.shallow_cmp = mkshallow({\n  exported_definition: \"exist\",\n  exported_value: \"exist\",\n  exported_names: \"exist\",\n  module_name: \"eq\",\n  is_default: \"eq\"\n});\nAST_Call.prototype.shallow_cmp = pass_through;\nAST_Sequence.prototype.shallow_cmp = pass_through;\nAST_PropAccess.prototype.shallow_cmp = pass_through;\nAST_Chain.prototype.shallow_cmp = pass_through;\nAST_Dot.prototype.shallow_cmp = mkshallow({\n  property: \"eq\"\n});\nAST_Unary.prototype.shallow_cmp = mkshallow({\n  operator: \"eq\"\n});\nAST_Binary.prototype.shallow_cmp = mkshallow({\n  operator: \"eq\"\n});\nAST_Conditional.prototype.shallow_cmp = pass_through;\nAST_Array.prototype.shallow_cmp = pass_through;\nAST_Object.prototype.shallow_cmp = pass_through;\nAST_ObjectProperty.prototype.shallow_cmp = pass_through;\nAST_ObjectKeyVal.prototype.shallow_cmp = mkshallow({\n  key: \"eq\"\n});\nAST_ObjectSetter.prototype.shallow_cmp = mkshallow({\n  static: \"eq\"\n});\nAST_ObjectGetter.prototype.shallow_cmp = mkshallow({\n  static: \"eq\"\n});\nAST_ConciseMethod.prototype.shallow_cmp = mkshallow({\n  static: \"eq\",\n  is_generator: \"eq\",\n  async: \"eq\"\n});\nAST_Class.prototype.shallow_cmp = mkshallow({\n  name: \"exist\",\n  extends: \"exist\"\n});\nAST_ClassProperty.prototype.shallow_cmp = mkshallow({\n  static: \"eq\"\n});\nAST_Symbol.prototype.shallow_cmp = mkshallow({\n  name: \"eq\"\n});\nAST_NewTarget.prototype.shallow_cmp = pass_through;\nAST_This.prototype.shallow_cmp = pass_through;\nAST_Super.prototype.shallow_cmp = pass_through;\nAST_String.prototype.shallow_cmp = mkshallow({\n  value: \"eq\"\n});\nAST_Number.prototype.shallow_cmp = mkshallow({\n  value: \"eq\"\n});\nAST_BigInt.prototype.shallow_cmp = mkshallow({\n  value: \"eq\"\n});\n\nAST_RegExp.prototype.shallow_cmp = function (other) {\n  return this.value.flags === other.value.flags && this.value.source === other.value.source;\n};\n\nAST_Atom.prototype.shallow_cmp = pass_through;","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/node_modules/terser/lib/equivalent-to.js"],"names":["AST_Array","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_Call","AST_Catch","AST_Chain","AST_Class","AST_ClassProperty","AST_ConciseMethod","AST_Conditional","AST_Debugger","AST_Definitions","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_EmptyStatement","AST_Expansion","AST_Export","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_If","AST_Import","AST_ImportMeta","AST_Jump","AST_LabeledStatement","AST_Lambda","AST_LoopControl","AST_NameMapping","AST_NewTarget","AST_Node","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PropAccess","AST_RegExp","AST_Sequence","AST_SimpleStatement","AST_String","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Toplevel","AST_Try","AST_Unary","AST_VarDef","AST_While","AST_With","AST_Yield","shallow_cmp","node1","node2","TYPE","equivalent_to","tree1","tree2","walk_1_state","walk_2_state","walk_1_push","push","bind","walk_2_push","length","node_1","pop","node_2","_children_backwards","mkshallow","props","comparisons","Object","keys","map","key","Error","join","Function","pass_through","prototype","constructor","name","value","init","condition","step","is_generator","async","is_array","is_star","alternative","bcatch","bfinally","argname","imported_name","imported_names","exported_definition","exported_value","exported_names","module_name","is_default","property","operator","static","extends","other","flags","source"],"mappings":"AAAA,SACIA,SADJ,EAEIC,QAFJ,EAGIC,SAHJ,EAIIC,UAJJ,EAKIC,UALJ,EAMIC,SANJ,EAOIC,QAPJ,EAQIC,SARJ,EASIC,SATJ,EAUIC,SAVJ,EAWIC,iBAXJ,EAYIC,iBAZJ,EAaIC,eAbJ,EAcIC,YAdJ,EAeIC,eAfJ,EAgBIC,iBAhBJ,EAiBIC,aAjBJ,EAkBIC,MAlBJ,EAmBIC,OAnBJ,EAoBIC,kBApBJ,EAqBIC,aArBJ,EAsBIC,UAtBJ,EAuBIC,WAvBJ,EAwBIC,OAxBJ,EAyBIC,SAzBJ,EA0BIC,SA1BJ,EA2BIC,MA3BJ,EA4BIC,UA5BJ,EA6BIC,cA7BJ,EA8BIC,QA9BJ,EA+BIC,oBA/BJ,EAgCIC,UAhCJ,EAiCIC,eAjCJ,EAkCIC,eAlCJ,EAmCIC,aAnCJ,EAoCIC,QApCJ,EAqCIC,UArCJ,EAsCIC,UAtCJ,EAuCIC,gBAvCJ,EAwCIC,gBAxCJ,EAyCIC,kBAzCJ,EA0CIC,gBA1CJ,EA2CIC,0BA3CJ,EA4CIC,cA5CJ,EA6CIC,UA7CJ,EA8CIC,YA9CJ,EA+CIC,mBA/CJ,EAgDIC,UAhDJ,EAiDIC,SAjDJ,EAkDIC,UAlDJ,EAmDIC,gBAnDJ,EAoDIC,UApDJ,EAqDIC,mBArDJ,EAsDIC,kBAtDJ,EAuDIC,QAvDJ,EAwDIC,YAxDJ,EAyDIC,OAzDJ,EA0DIC,SA1DJ,EA2DIC,UA3DJ,EA4DIC,SA5DJ,EA6DIC,QA7DJ,EA8DIC,SA9DJ,QA+DO,UA/DP;;AAiEA,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAClC,SACID,KAAK,KAAK,IAAV,IAAkBC,KAAK,KAAK,IAA5B,IACGD,KAAK,CAACE,IAAN,KAAeD,KAAK,CAACC,IAArB,IAA6BF,KAAK,CAACD,WAAN,CAAkBE,KAAlB,CAFpC;AAIH,CALD;;AAOA,OAAO,MAAME,aAAa,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAC3C,MAAI,CAACN,WAAW,CAACK,KAAD,EAAQC,KAAR,CAAhB,EAAgC,OAAO,KAAP;AAChC,QAAMC,YAAY,GAAG,CAACF,KAAD,CAArB;AACA,QAAMG,YAAY,GAAG,CAACF,KAAD,CAArB;AAEA,QAAMG,WAAW,GAAGF,YAAY,CAACG,IAAb,CAAkBC,IAAlB,CAAuBJ,YAAvB,CAApB;AACA,QAAMK,WAAW,GAAGJ,YAAY,CAACE,IAAb,CAAkBC,IAAlB,CAAuBH,YAAvB,CAApB;;AAEA,SAAOD,YAAY,CAACM,MAAb,IAAuBL,YAAY,CAACK,MAA3C,EAAmD;AAC/C,UAAMC,MAAM,GAAGP,YAAY,CAACQ,GAAb,EAAf;AACA,UAAMC,MAAM,GAAGR,YAAY,CAACO,GAAb,EAAf;AAEA,QAAI,CAACf,WAAW,CAACc,MAAD,EAASE,MAAT,CAAhB,EAAkC,OAAO,KAAP;;AAElCF,IAAAA,MAAM,CAACG,mBAAP,CAA2BR,WAA3B;;AACAO,IAAAA,MAAM,CAACC,mBAAP,CAA2BL,WAA3B;;AAEA,QAAIL,YAAY,CAACM,MAAb,KAAwBL,YAAY,CAACK,MAAzC,EAAiD;AAC7C;AACA,aAAO,KAAP;AACH;AACJ;;AAED,SAAON,YAAY,CAACM,MAAb,IAAuB,CAAvB,IAA4BL,YAAY,CAACK,MAAb,IAAuB,CAA1D;AACH,CAxBM,C,CA0BP;;AACA,MAAMK,SAAS,GAAIC,KAAD,IAAW;AACzB,QAAMC,WAAW,GAAGC,MAAM,CACrBC,IADe,CACVH,KADU,EAEfI,GAFe,CAEXC,GAAG,IAAI;AACR,QAAIL,KAAK,CAACK,GAAD,CAAL,KAAe,IAAnB,EAAyB;AACrB,aAAQ,QAAOA,GAAI,cAAaA,GAAI,EAApC;AACH,KAFD,MAEO,IAAIL,KAAK,CAACK,GAAD,CAAL,KAAe,OAAnB,EAA4B;AAC/B,aAAQ,SAAQA,GAAI,oBAAmBA,GAAI,mBAAkBA,GAAI,cAAaA,GAAI,GAAlF;AACH,KAFM,MAEA;AACH,YAAM,IAAIC,KAAJ,CAAW,sCAAqCN,KAAK,CAACK,GAAD,CAAM,EAA3D,CAAN;AACH;AACJ,GAVe,EAWfE,IAXe,CAWV,MAXU,CAApB;AAaA,SAAO,IAAIC,QAAJ,CAAa,OAAb,EAAsB,YAAYP,WAAlC,CAAP;AACH,CAfD;;AAiBA,MAAMQ,YAAY,GAAG,MAAM,IAA3B;;AAEAvD,QAAQ,CAACwD,SAAT,CAAmB7B,WAAnB,GAAiC,YAAY;AACzC,QAAM,IAAIyB,KAAJ,CAAU,6CAA6C,KAAKK,WAAL,CAAiBC,IAAxE,CAAN;AACH,CAFD;;AAIAhF,YAAY,CAAC8E,SAAb,CAAuB7B,WAAvB,GAAqC4B,YAArC;AAEA1E,aAAa,CAAC2E,SAAd,CAAwB7B,WAAxB,GAAsCkB,SAAS,CAAC;AAAEc,EAAAA,KAAK,EAAE;AAAT,CAAD,CAA/C;AAEAhD,mBAAmB,CAAC6C,SAApB,CAA8B7B,WAA9B,GAA4C4B,YAA5C;AAEArF,SAAS,CAACsF,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEAvE,kBAAkB,CAACwE,SAAnB,CAA6B7B,WAA7B,GAA2C4B,YAA3C;AAEA5D,oBAAoB,CAAC6D,SAArB,CAA+B7B,WAA/B,GAA6CkB,SAAS,CAAC;AAAE,gBAAc;AAAhB,CAAD,CAAtD;AAEA/D,MAAM,CAAC0E,SAAP,CAAiB7B,WAAjB,GAA+B4B,YAA/B;AAEA/B,SAAS,CAACgC,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEAnE,OAAO,CAACoE,SAAR,CAAkB7B,WAAlB,GAAgCkB,SAAS,CAAC;AACtCe,EAAAA,IAAI,EAAE,OADgC;AAEtCC,EAAAA,SAAS,EAAE,OAF2B;AAGtCC,EAAAA,IAAI,EAAE;AAHgC,CAAD,CAAzC;AAMAzE,SAAS,CAACmE,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEAjE,SAAS,CAACkE,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEA9B,QAAQ,CAAC+B,SAAT,CAAmB7B,WAAnB,GAAiC4B,YAAjC;AAEAnC,YAAY,CAACoC,SAAb,CAAuB7B,WAAvB,GAAqC4B,YAArC;AAEAtE,aAAa,CAACuE,SAAd,CAAwB7B,WAAxB,GAAsC4B,YAAtC;AAEA3D,UAAU,CAAC4D,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCkB,EAAAA,YAAY,EAAE,IAD2B;AAEzCC,EAAAA,KAAK,EAAE;AAFkC,CAAD,CAA5C;AAKApF,iBAAiB,CAAC4E,SAAlB,CAA4B7B,WAA5B,GAA0CkB,SAAS,CAAC;AAChDoB,EAAAA,QAAQ,EAAE;AADsC,CAAD,CAAnD;AAIA1D,0BAA0B,CAACiD,SAA3B,CAAqC7B,WAArC,GAAmD4B,YAAnD;AAEArC,kBAAkB,CAACsC,SAAnB,CAA6B7B,WAA7B,GAA2C4B,YAA3C;AAEAtC,mBAAmB,CAACuC,SAApB,CAA8B7B,WAA9B,GAA4CkB,SAAS,CAAC;AAClD,WAAS;AADyC,CAAD,CAArD;AAIAnD,QAAQ,CAAC8D,SAAT,CAAmB7B,WAAnB,GAAiC4B,YAAjC;AAEA1D,eAAe,CAAC2D,SAAhB,CAA0B7B,WAA1B,GAAwC4B,YAAxC;AAEAxF,SAAS,CAACyF,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEA7B,SAAS,CAAC8B,SAAV,CAAoB7B,WAApB,GAAkCkB,SAAS,CAAC;AACxCqB,EAAAA,OAAO,EAAE;AAD+B,CAAD,CAA3C;AAIA3E,MAAM,CAACiE,SAAP,CAAiB7B,WAAjB,GAA+BkB,SAAS,CAAC;AACrCsB,EAAAA,WAAW,EAAE;AADwB,CAAD,CAAxC;AAIArD,UAAU,CAAC0C,SAAX,CAAqB7B,WAArB,GAAmC4B,YAAnC;AAEAxC,gBAAgB,CAACyC,SAAjB,CAA2B7B,WAA3B,GAAyC4B,YAAzC;AAEAlC,OAAO,CAACmC,SAAR,CAAkB7B,WAAlB,GAAgCkB,SAAS,CAAC;AACtCuB,EAAAA,MAAM,EAAE,OAD8B;AAEtCC,EAAAA,QAAQ,EAAE;AAF4B,CAAD,CAAzC;AAKAjG,SAAS,CAACoF,SAAV,CAAoB7B,WAApB,GAAkCkB,SAAS,CAAC;AACxCyB,EAAAA,OAAO,EAAE;AAD+B,CAAD,CAA3C;AAIAnF,WAAW,CAACqE,SAAZ,CAAsB7B,WAAtB,GAAoC4B,YAApC;AAEA5E,eAAe,CAAC6E,SAAhB,CAA0B7B,WAA1B,GAAwC4B,YAAxC;AAEAhC,UAAU,CAACiC,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCc,EAAAA,KAAK,EAAE;AADkC,CAAD,CAA5C;AAIA7D,eAAe,CAAC0D,SAAhB,CAA0B7B,WAA1B,GAAwC4B,YAAxC;AAEA/D,UAAU,CAACgE,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzC0B,EAAAA,aAAa,EAAE,OAD0B;AAEzCC,EAAAA,cAAc,EAAE;AAFyB,CAAD,CAA5C;AAKA/E,cAAc,CAAC+D,SAAf,CAAyB7B,WAAzB,GAAuC4B,YAAvC;AAEArE,UAAU,CAACsE,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzC4B,EAAAA,mBAAmB,EAAE,OADoB;AAEzCC,EAAAA,cAAc,EAAE,OAFyB;AAGzCC,EAAAA,cAAc,EAAE,OAHyB;AAIzCC,EAAAA,WAAW,EAAE,IAJ4B;AAKzCC,EAAAA,UAAU,EAAE;AAL6B,CAAD,CAA5C;AAQA1G,QAAQ,CAACqF,SAAT,CAAmB7B,WAAnB,GAAiC4B,YAAjC;AAEA7C,YAAY,CAAC8C,SAAb,CAAuB7B,WAAvB,GAAqC4B,YAArC;AAEA/C,cAAc,CAACgD,SAAf,CAAyB7B,WAAzB,GAAuC4B,YAAvC;AAEAlF,SAAS,CAACmF,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEAxE,OAAO,CAACyE,SAAR,CAAkB7B,WAAlB,GAAgCkB,SAAS,CAAC;AACtCiC,EAAAA,QAAQ,EAAE;AAD4B,CAAD,CAAzC;AAIAxD,SAAS,CAACkC,SAAV,CAAoB7B,WAApB,GAAkCkB,SAAS,CAAC;AACxCkC,EAAAA,QAAQ,EAAE;AAD8B,CAAD,CAA3C;AAIA9G,UAAU,CAACuF,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCkC,EAAAA,QAAQ,EAAE;AAD+B,CAAD,CAA5C;AAIAtG,eAAe,CAAC+E,SAAhB,CAA0B7B,WAA1B,GAAwC4B,YAAxC;AAEA1F,SAAS,CAAC2F,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEArD,UAAU,CAACsD,SAAX,CAAqB7B,WAArB,GAAmC4B,YAAnC;AAEAlD,kBAAkB,CAACmD,SAAnB,CAA6B7B,WAA7B,GAA2C4B,YAA3C;AAEAnD,gBAAgB,CAACoD,SAAjB,CAA2B7B,WAA3B,GAAyCkB,SAAS,CAAC;AAC/CM,EAAAA,GAAG,EAAE;AAD0C,CAAD,CAAlD;AAIA7C,gBAAgB,CAACkD,SAAjB,CAA2B7B,WAA3B,GAAyCkB,SAAS,CAAC;AAC/CmC,EAAAA,MAAM,EAAE;AADuC,CAAD,CAAlD;AAIA7E,gBAAgB,CAACqD,SAAjB,CAA2B7B,WAA3B,GAAyCkB,SAAS,CAAC;AAC/CmC,EAAAA,MAAM,EAAE;AADuC,CAAD,CAAlD;AAIAxG,iBAAiB,CAACgF,SAAlB,CAA4B7B,WAA5B,GAA0CkB,SAAS,CAAC;AAChDmC,EAAAA,MAAM,EAAE,IADwC;AAEhDjB,EAAAA,YAAY,EAAE,IAFkC;AAGhDC,EAAAA,KAAK,EAAE;AAHyC,CAAD,CAAnD;AAMA1F,SAAS,CAACkF,SAAV,CAAoB7B,WAApB,GAAkCkB,SAAS,CAAC;AACxCa,EAAAA,IAAI,EAAE,OADkC;AAExCuB,EAAAA,OAAO,EAAE;AAF+B,CAAD,CAA3C;AAKA1G,iBAAiB,CAACiF,SAAlB,CAA4B7B,WAA5B,GAA0CkB,SAAS,CAAC;AAChDmC,EAAAA,MAAM,EAAE;AADwC,CAAD,CAAnD;AAIAhE,UAAU,CAACwC,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCa,EAAAA,IAAI,EAAE;AADmC,CAAD,CAA5C;AAIA3D,aAAa,CAACyD,SAAd,CAAwB7B,WAAxB,GAAsC4B,YAAtC;AAEApC,QAAQ,CAACqC,SAAT,CAAmB7B,WAAnB,GAAiC4B,YAAjC;AAEA1C,SAAS,CAAC2C,SAAV,CAAoB7B,WAApB,GAAkC4B,YAAlC;AAEA3C,UAAU,CAAC4C,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCc,EAAAA,KAAK,EAAE;AADkC,CAAD,CAA5C;AAIA1D,UAAU,CAACuD,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCc,EAAAA,KAAK,EAAE;AADkC,CAAD,CAA5C;AAIA3F,UAAU,CAACwF,SAAX,CAAqB7B,WAArB,GAAmCkB,SAAS,CAAC;AACzCc,EAAAA,KAAK,EAAE;AADkC,CAAD,CAA5C;;AAIAlD,UAAU,CAAC+C,SAAX,CAAqB7B,WAArB,GAAmC,UAAUuD,KAAV,EAAiB;AAChD,SACI,KAAKvB,KAAL,CAAWwB,KAAX,KAAqBD,KAAK,CAACvB,KAAN,CAAYwB,KAAjC,IACG,KAAKxB,KAAL,CAAWyB,MAAX,KAAsBF,KAAK,CAACvB,KAAN,CAAYyB,MAFzC;AAIH,CALD;;AAOAtH,QAAQ,CAAC0F,SAAT,CAAmB7B,WAAnB,GAAiC4B,YAAjC","sourcesContent":["import {\n    AST_Array,\n    AST_Atom,\n    AST_Await,\n    AST_BigInt,\n    AST_Binary,\n    AST_Block,\n    AST_Call,\n    AST_Catch,\n    AST_Chain,\n    AST_Class,\n    AST_ClassProperty,\n    AST_ConciseMethod,\n    AST_Conditional,\n    AST_Debugger,\n    AST_Definitions,\n    AST_Destructuring,\n    AST_Directive,\n    AST_Do,\n    AST_Dot,\n    AST_EmptyStatement,\n    AST_Expansion,\n    AST_Export,\n    AST_Finally,\n    AST_For,\n    AST_ForIn,\n    AST_ForOf,\n    AST_If,\n    AST_Import,\n    AST_ImportMeta,\n    AST_Jump,\n    AST_LabeledStatement,\n    AST_Lambda,\n    AST_LoopControl,\n    AST_NameMapping,\n    AST_NewTarget,\n    AST_Node,\n    AST_Number,\n    AST_Object,\n    AST_ObjectGetter,\n    AST_ObjectKeyVal,\n    AST_ObjectProperty,\n    AST_ObjectSetter,\n    AST_PrefixedTemplateString,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_String,\n    AST_Super,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_TemplateSegment,\n    AST_TemplateString,\n    AST_This,\n    AST_Toplevel,\n    AST_Try,\n    AST_Unary,\n    AST_VarDef,\n    AST_While,\n    AST_With,\n    AST_Yield\n} from \"./ast.js\";\n\nconst shallow_cmp = (node1, node2) => {\n    return (\n        node1 === null && node2 === null\n        || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2)\n    );\n};\n\nexport const equivalent_to = (tree1, tree2) => {\n    if (!shallow_cmp(tree1, tree2)) return false;\n    const walk_1_state = [tree1];\n    const walk_2_state = [tree2];\n\n    const walk_1_push = walk_1_state.push.bind(walk_1_state);\n    const walk_2_push = walk_2_state.push.bind(walk_2_state);\n\n    while (walk_1_state.length && walk_2_state.length) {\n        const node_1 = walk_1_state.pop();\n        const node_2 = walk_2_state.pop();\n\n        if (!shallow_cmp(node_1, node_2)) return false;\n\n        node_1._children_backwards(walk_1_push);\n        node_2._children_backwards(walk_2_push);\n\n        if (walk_1_state.length !== walk_2_state.length) {\n            // Different number of children\n            return false;\n        }\n    }\n\n    return walk_1_state.length == 0 && walk_2_state.length == 0;\n};\n\n// Creates a shallow compare function\nconst mkshallow = (props) => {\n    const comparisons = Object\n        .keys(props)\n        .map(key => {\n            if (props[key] === \"eq\") {\n                return `this.${key} === other.${key}`;\n            } else if (props[key] === \"exist\") {\n                return `(this.${key} == null ? other.${key} == null : this.${key} === other.${key})`;\n            } else {\n                throw new Error(`mkshallow: Unexpected instruction: ${props[key]}`);\n            }\n        })\n        .join(\" && \");\n\n    return new Function(\"other\", \"return \" + comparisons);\n};\n\nconst pass_through = () => true;\n\nAST_Node.prototype.shallow_cmp = function () {\n    throw new Error(\"did not find a shallow_cmp function for \" + this.constructor.name);\n};\n\nAST_Debugger.prototype.shallow_cmp = pass_through;\n\nAST_Directive.prototype.shallow_cmp = mkshallow({ value: \"eq\" });\n\nAST_SimpleStatement.prototype.shallow_cmp = pass_through;\n\nAST_Block.prototype.shallow_cmp = pass_through;\n\nAST_EmptyStatement.prototype.shallow_cmp = pass_through;\n\nAST_LabeledStatement.prototype.shallow_cmp = mkshallow({ \"label.name\": \"eq\" });\n\nAST_Do.prototype.shallow_cmp = pass_through;\n\nAST_While.prototype.shallow_cmp = pass_through;\n\nAST_For.prototype.shallow_cmp = mkshallow({\n    init: \"exist\",\n    condition: \"exist\",\n    step: \"exist\"\n});\n\nAST_ForIn.prototype.shallow_cmp = pass_through;\n\nAST_ForOf.prototype.shallow_cmp = pass_through;\n\nAST_With.prototype.shallow_cmp = pass_through;\n\nAST_Toplevel.prototype.shallow_cmp = pass_through;\n\nAST_Expansion.prototype.shallow_cmp = pass_through;\n\nAST_Lambda.prototype.shallow_cmp = mkshallow({\n    is_generator: \"eq\",\n    async: \"eq\"\n});\n\nAST_Destructuring.prototype.shallow_cmp = mkshallow({\n    is_array: \"eq\"\n});\n\nAST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateSegment.prototype.shallow_cmp = mkshallow({\n    \"value\": \"eq\"\n});\n\nAST_Jump.prototype.shallow_cmp = pass_through;\n\nAST_LoopControl.prototype.shallow_cmp = pass_through;\n\nAST_Await.prototype.shallow_cmp = pass_through;\n\nAST_Yield.prototype.shallow_cmp = mkshallow({\n    is_star: \"eq\"\n});\n\nAST_If.prototype.shallow_cmp = mkshallow({\n    alternative: \"exist\"\n});\n\nAST_Switch.prototype.shallow_cmp = pass_through;\n\nAST_SwitchBranch.prototype.shallow_cmp = pass_through;\n\nAST_Try.prototype.shallow_cmp = mkshallow({\n    bcatch: \"exist\",\n    bfinally: \"exist\"\n});\n\nAST_Catch.prototype.shallow_cmp = mkshallow({\n    argname: \"exist\"\n});\n\nAST_Finally.prototype.shallow_cmp = pass_through;\n\nAST_Definitions.prototype.shallow_cmp = pass_through;\n\nAST_VarDef.prototype.shallow_cmp = mkshallow({\n    value: \"exist\"\n});\n\nAST_NameMapping.prototype.shallow_cmp = pass_through;\n\nAST_Import.prototype.shallow_cmp = mkshallow({\n    imported_name: \"exist\",\n    imported_names: \"exist\"\n});\n\nAST_ImportMeta.prototype.shallow_cmp = pass_through;\n\nAST_Export.prototype.shallow_cmp = mkshallow({\n    exported_definition: \"exist\",\n    exported_value: \"exist\",\n    exported_names: \"exist\",\n    module_name: \"eq\",\n    is_default: \"eq\",\n});\n\nAST_Call.prototype.shallow_cmp = pass_through;\n\nAST_Sequence.prototype.shallow_cmp = pass_through;\n\nAST_PropAccess.prototype.shallow_cmp = pass_through;\n\nAST_Chain.prototype.shallow_cmp = pass_through;\n\nAST_Dot.prototype.shallow_cmp = mkshallow({\n    property: \"eq\"\n});\n\nAST_Unary.prototype.shallow_cmp = mkshallow({\n    operator: \"eq\"\n});\n\nAST_Binary.prototype.shallow_cmp = mkshallow({\n    operator: \"eq\"\n});\n\nAST_Conditional.prototype.shallow_cmp = pass_through;\n\nAST_Array.prototype.shallow_cmp = pass_through;\n\nAST_Object.prototype.shallow_cmp = pass_through;\n\nAST_ObjectProperty.prototype.shallow_cmp = pass_through;\n\nAST_ObjectKeyVal.prototype.shallow_cmp = mkshallow({\n    key: \"eq\"\n});\n\nAST_ObjectSetter.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_ObjectGetter.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_ConciseMethod.prototype.shallow_cmp = mkshallow({\n    static: \"eq\",\n    is_generator: \"eq\",\n    async: \"eq\",\n});\n\nAST_Class.prototype.shallow_cmp = mkshallow({\n    name: \"exist\",\n    extends: \"exist\",\n});\n\nAST_ClassProperty.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_Symbol.prototype.shallow_cmp = mkshallow({\n    name: \"eq\"\n});\n\nAST_NewTarget.prototype.shallow_cmp = pass_through;\n\nAST_This.prototype.shallow_cmp = pass_through;\n\nAST_Super.prototype.shallow_cmp = pass_through;\n\nAST_String.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_Number.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_BigInt.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_RegExp.prototype.shallow_cmp = function (other) {\n    return (\n        this.value.flags === other.value.flags\n        && this.value.source === other.value.source\n    );\n};\n\nAST_Atom.prototype.shallow_cmp = pass_through;\n"]},"metadata":{},"sourceType":"module"}