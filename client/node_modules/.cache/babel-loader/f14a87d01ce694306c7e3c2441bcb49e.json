{"ast":null,"code":"/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst isDependencyInstalled = require('../isDependencyInstalled');\n\nconst {\n  createElement,\n  appendChild,\n  nextNode,\n  firstChildByTag\n} = require('../NodeUtils');\n\nconst {\n  URL\n} = require('url');\n\nconst {\n  skipNodeAndChildren\n} = require('../HtmlDomHelper');\n\nconst PathResolver = require('../PathResolver');\n\nconst PIXEL_TARGET = 60;\nconst MAX_BLURRED_PLACEHOLDERS = 100;\nconst DEFAULT_CACHED_PLACEHOLDERS = 30;\nconst CACHE_ALL_PLACEHOLDERS = -1;\nconst ESCAPE_TABLE = {\n  '#': '%23',\n  '%': '%25',\n  ':': '%3A',\n  '<': '%3C',\n  '>': '%3E',\n  '\"': \"'\"\n};\nconst ESCAPE_REGEX = new RegExp(Object.keys(ESCAPE_TABLE).join('|'), 'g');\n\nfunction escaper(match) {\n  return ESCAPE_TABLE[match];\n}\n/**\n * Adds placeholders for certain amp-img's and posters for amp-videos that are\n * blurry versions of the corresponding original source. The blur will be\n * displayed as the <amp-img> is rendering, and will fade out once the element\n * is loaded. The current requirements of appending a blurry placeholder is for\n * the element is to be a JPEG that is either responsive or a poster for an\n * amp-video.\n *\n * This transformer supports the following option:\n *\n * * `blurredPlaceholders`: Enables blurry image placeholder generation. Default is `false`.\n * * `imageBasePath`: specifies a base path used to resolve an image during build. You can\n *    also pass a function `(imgSrc, params) => '../img/' + imgSrc` for calculating the image path.\n * * `maxBlurredPlaceholders`: Specifies the max number of blurred images. Defaults to 5.\n * * `blurredPlaceholdersCacheSize`: Specifies the max number of blurred images to be cached\n *   to avoid expensive recalculation. Set to 0 if caching should be disabled. Set to -1 if\n *   all placeholders should be cached (good for static sites). Defaults to 30.\n *\n * Important: blurry image placeholder computation is expensive. Make sure to\n * only use it for static or cached pages.\n */\n\n\nclass AddBlurryImagePlaceholders {\n  constructor(config) {\n    this.log_ = config.log.tag('AddBlurryImagePlaceholders'); // setup implementation only if placeholder generation is enabled\n\n    this.blurredPlaceholders_ = !!config.blurredPlaceholders;\n\n    if (!this.blurredPlaceholders_) {\n      this.log_.debug('disabled');\n      return;\n    } // check whether all required dependencies are installed\n\n\n    if (!isDependencyInstalled('jimp') || !isDependencyInstalled('lru-cache')) {\n      this.log_.warn('jimp and lru-cache need to be installed via `npm install jimp lru-cache` ' + 'for this transformer to work'); // we can't generate placeholders\n\n      this.blurredPlaceholders_ = false;\n      return;\n    }\n\n    this.jimp = require('jimp'); // use provided upper placeholder limit for fallback to default\n\n    this.maxBlurredPlaceholders_ = config.maxBlurredPlaceholders || MAX_BLURRED_PLACEHOLDERS; // used for resolving image files\n\n    this.pathResolver_ = new PathResolver(config.imageBasePath); // setup caching\n\n    const maxCacheSize = config.blurredPlaceholdersCacheSize || DEFAULT_CACHED_PLACEHOLDERS; // use a Map if all placeholders should be cached\n\n    if (maxCacheSize === CACHE_ALL_PLACEHOLDERS) {\n      this.log_.debug('caching all placeholders');\n      this.cache_ = new Map();\n    } else if (maxCacheSize > 0) {\n      const LRU = require('lru-cache');\n\n      this.log_.debug('using LRU cache for regularily used placeholders', maxCacheSize); // use a LRU cache otherwise\n\n      this.cache_ = new LRU({\n        max: maxCacheSize\n      });\n    } else {\n      this.log_.debug('caching disabled');\n    }\n  }\n  /**\n   * Parses the document to add blurred placedholders in all appropriate\n   * locations.\n   * @param {Object} runtime parameters\n   * @return {Array} An array of promises that all represents the resolution of\n   * a blurred placeholder being added in an appropriate place.\n   */\n\n\n  transform(root, params) {\n    // Check if placeholders should be generated\n    if (!this.blurredPlaceholders_) {\n      return;\n    }\n\n    const html = firstChildByTag(root, 'html');\n    const body = firstChildByTag(html, 'body');\n    const promises = [];\n    let placeholders = 0;\n\n    for (let node = body; node !== null; node = nextNode(node)) {\n      const {\n        tagName\n      } = node;\n      let src;\n\n      if (tagName === 'template') {\n        node = skipNodeAndChildren(node);\n        continue;\n      }\n\n      if (tagName === 'amp-img') {\n        src = node.attribs.src;\n      }\n\n      if (tagName === 'amp-video' && node.attribs.poster) {\n        src = node.attribs.poster;\n      }\n\n      if (this.shouldAddBlurryPlaceholder_(node, src, tagName)) {\n        placeholders++;\n        const promise = this.addBlurryPlaceholder_(src, params).then(img => {\n          node.attribs.noloading = '';\n          appendChild(node, img);\n        });\n        promises.push(promise);\n\n        if (placeholders >= this.maxBlurredPlaceholders_) {\n          break;\n        }\n      }\n    }\n\n    return Promise.all(promises);\n  }\n  /**\n   * Adds a child image that is a blurry placeholder.\n   * @param {String} src The image that the bitmap is based on.\n   * @return {!Promise} A promise that signifies that the img has been updated\n   * to have correct attributes to be a blurred placeholder along with the\n   * placeholder itself.\n   * @private\n   */\n\n\n  async addBlurryPlaceholder_(src, params) {\n    const img = createElement('img', {\n      class: 'i-amphtml-blurry-placeholder',\n      placeholder: '',\n      src,\n      alt: ''\n    });\n\n    try {\n      const dataURI = await this.getCachedDataURI(src, params);\n      let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\"\n                      xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                      viewBox=\"0 0 ${dataURI.width} ${dataURI.height}\">\n                      <filter id=\"b\" color-interpolation-filters=\"sRGB\">\n                        <feGaussianBlur stdDeviation=\".5\"></feGaussianBlur>\n                        <feComponentTransfer>\n                          <feFuncA type=\"discrete\" tableValues=\"1 1\"></feFuncA>\n                        </feComponentTransfer>\n                      </filter>\n                      <image filter=\"url(#b)\" x=\"0\" y=\"0\"\n                        height=\"100%\" width=\"100%\"\n                        xlink:href=\"${dataURI.src}\">\n                      </image>\n                    </svg>`; // Optimizes dataURI length by deleting line breaks, and\n      // removing unnecessary spaces.\n\n      svg = svg.replace(/\\s+/g, ' ');\n      svg = svg.replace(/> </g, '><');\n      svg = svg.replace(ESCAPE_REGEX, escaper);\n      img.attribs.src = 'data:image/svg+xml;charset=utf-8,' + svg;\n      this.log_.debug(src, '[SUCCESS]');\n    } catch (err) {\n      this.log_.debug(src, '[FAIL]');\n      this.log_.error(err.message);\n    }\n\n    return img;\n  }\n  /**\n   * Returns a cached dataURI if exists, otherwise creates a new one.\n   */\n\n\n  getCachedDataURI(src, params) {\n    const resolvedSrc = this.pathResolver_.resolve(src, params);\n\n    if (this.cache_) {\n      const dataURIPromise = this.cache_.get(resolvedSrc);\n\n      if (dataURIPromise) {\n        this.log_.debug(src, '[CACHE HIT]');\n        return dataURIPromise;\n      }\n\n      this.log_.debug(src, '[CACHE MISS]');\n    }\n\n    const dataURIPromise = this.getDataURI_(resolvedSrc);\n\n    if (this.cache_) {\n      // we cache the promise to ensure that multiple requests for the same image\n      // still use the cache\n      this.cache_.set(resolvedSrc, dataURIPromise);\n    }\n\n    return dataURIPromise;\n  }\n  /**\n   * Creates the bitmap in a dataURI format.\n   * @param {string} the img src value\n   * placeholder.\n   * @return {!Promise} A promise that is resolved once the img's src is updated\n   * to be a dataURI of a bitmap including width and height.\n   * @private\n   */\n\n\n  async getDataURI_(src) {\n    const image = await this.jimp.read(src);\n    const imgDimension = this.getBitmapDimensions_(image.bitmap.width, image.bitmap.height);\n    image.resize(imgDimension.width, imgDimension.height, this.jimp.RESIZE_BEZIER);\n    const result = {\n      src: await image.getBase64Async('image/png'),\n      width: imgDimension.width,\n      height: imgDimension.height\n    };\n    return result;\n  }\n  /**\n   * Calculates the correct dimensions for the bitmap.\n   * @param {Node} img The DOM element that will need a bitmap.\n   * placeholder.\n   * @return {Record} The aspect ratio of the bitmap of the image.\n   * @private\n   */\n\n\n  getBitmapDimensions_(imgWidth, imgHeight) {\n    // Aims for a bitmap of ~P pixels (w * h = ~P).\n    // Gets the ratio of the width to the height. (r = w0 / h0 = w / h)\n    const ratioWH = imgWidth / imgHeight; // Express the width in terms of height by multiply the ratio by the\n    // height. (h * r = (w / h) * h)\n    // Plug this representation of the width into the original equation.\n    // (h * r * h = ~P).\n    // Divide the bitmap size by the ratio to get the all expressions using\n    // height on one side. (h * h = ~P / r)\n\n    let bitmapHeight = PIXEL_TARGET / ratioWH; // Take the square root of the height instances to find the singular value\n    // for the height. (h = sqrt(~P / r))\n\n    bitmapHeight = Math.sqrt(bitmapHeight); // Divide the goal total pixel amount by the height to get the width.\n    // (w = ~P / h).\n\n    const bitmapWidth = PIXEL_TARGET / bitmapHeight;\n    return {\n      width: Math.round(bitmapWidth),\n      height: Math.round(bitmapHeight)\n    };\n  }\n  /**\n   * Checks if an element has a placeholder.\n   * @param {Node} node The DOM element that is being checked for a placeholder.\n   * @return {boolean} Whether or not the element already has a placeholder\n   * child.\n   * @private\n   */\n\n\n  hasPlaceholder_(node) {\n    return node.childNodes.find(child => {\n      return child.attribs && child.attribs.placeholder !== undefined;\n    }) !== undefined;\n  }\n  /**\n   * Checks if an image should have a blurred image placeholder.\n   * The current criteria for determining if a blurry image placeholder should\n   * be appended is as follows:\n   * - The source for the image should be a JPEG.\n   * - If the element is:\n   *    - an amp-img using a responsive layout (responsive, fill or intrinsic)\n   *    - an amp-video with a poster\n   *\n   * This criteria was found to be the most common places where a blurry image\n   * placeholder would likely want to be used through manual examination of\n   * existing AMP pages.\n   * @param {Node} node The DOM element that is being checked to see if it\n   * should have a blurred placeholder.\n   * @param {string} src The image source that is being checked.\n   * @param {string} tagName The type of element that is being checked.\n   * @return {boolean} Whether or not the element should have a blurred\n   * placeholder child.\n   * @private\n   */\n\n\n  shouldAddBlurryPlaceholder_(node, src, tagName) {\n    // Ensures current placeholders are not overridden.\n    if (!src) {\n      return false;\n    }\n\n    if (this.hasPlaceholder_(node)) {\n      return false;\n    } // Non-JPEG images are not commonly featured in a role where blurred\n    // image placeholders would be wanted.\n\n\n    const url = new URL(src, 'https://example.com');\n\n    if (!url.pathname.endsWith('.jpg') && !url.pathname.endsWith('jpeg')) {\n      return false;\n    } // Images or videos with noloading attributes should not have any indicators that they\n    // are loading.\n\n\n    if (node.attribs.noloading != null) {\n      return false;\n    } // Checks if the image is a poster or a responsive image as these are the\n    // two most common cases where blurred placeholders would be wanted.\n\n\n    const isPoster = tagName == 'amp-video';\n    const isResponsiveImgWithLoading = tagName == 'amp-img' && (node.attribs.layout == 'intrinsic' || node.attribs.layout == 'responsive' || node.attribs.layout == 'fill');\n    return isPoster || isResponsiveImgWithLoading;\n  }\n\n}\n/** @module AddBlurryImagePlaceholders */\n\n\nmodule.exports = AddBlurryImagePlaceholders;","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/lib/transformers/AddBlurryImagePlaceholders.js"],"names":["isDependencyInstalled","require","createElement","appendChild","nextNode","firstChildByTag","URL","skipNodeAndChildren","PathResolver","PIXEL_TARGET","MAX_BLURRED_PLACEHOLDERS","DEFAULT_CACHED_PLACEHOLDERS","CACHE_ALL_PLACEHOLDERS","ESCAPE_TABLE","ESCAPE_REGEX","RegExp","Object","keys","join","escaper","match","AddBlurryImagePlaceholders","constructor","config","log_","log","tag","blurredPlaceholders_","blurredPlaceholders","debug","warn","jimp","maxBlurredPlaceholders_","maxBlurredPlaceholders","pathResolver_","imageBasePath","maxCacheSize","blurredPlaceholdersCacheSize","cache_","Map","LRU","max","transform","root","params","html","body","promises","placeholders","node","tagName","src","attribs","poster","shouldAddBlurryPlaceholder_","promise","addBlurryPlaceholder_","then","img","noloading","push","Promise","all","class","placeholder","alt","dataURI","getCachedDataURI","svg","width","height","replace","err","error","message","resolvedSrc","resolve","dataURIPromise","get","getDataURI_","set","image","read","imgDimension","getBitmapDimensions_","bitmap","resize","RESIZE_BEZIER","result","getBase64Async","imgWidth","imgHeight","ratioWH","bitmapHeight","Math","sqrt","bitmapWidth","round","hasPlaceholder_","childNodes","find","child","undefined","url","pathname","endsWith","isPoster","isResponsiveImgWithLoading","layout","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst isDependencyInstalled = require('../isDependencyInstalled');\n\nconst {createElement, appendChild, nextNode, firstChildByTag} = require('../NodeUtils');\nconst {URL} = require('url');\n\nconst {skipNodeAndChildren} = require('../HtmlDomHelper');\nconst PathResolver = require('../PathResolver');\n\nconst PIXEL_TARGET = 60;\nconst MAX_BLURRED_PLACEHOLDERS = 100;\nconst DEFAULT_CACHED_PLACEHOLDERS = 30;\nconst CACHE_ALL_PLACEHOLDERS = -1;\n\nconst ESCAPE_TABLE = {\n  '#': '%23',\n  '%': '%25',\n  ':': '%3A',\n  '<': '%3C',\n  '>': '%3E',\n  '\"': \"'\",\n};\nconst ESCAPE_REGEX = new RegExp(Object.keys(ESCAPE_TABLE).join('|'), 'g');\nfunction escaper(match) {\n  return ESCAPE_TABLE[match];\n}\n\n/**\n * Adds placeholders for certain amp-img's and posters for amp-videos that are\n * blurry versions of the corresponding original source. The blur will be\n * displayed as the <amp-img> is rendering, and will fade out once the element\n * is loaded. The current requirements of appending a blurry placeholder is for\n * the element is to be a JPEG that is either responsive or a poster for an\n * amp-video.\n *\n * This transformer supports the following option:\n *\n * * `blurredPlaceholders`: Enables blurry image placeholder generation. Default is `false`.\n * * `imageBasePath`: specifies a base path used to resolve an image during build. You can\n *    also pass a function `(imgSrc, params) => '../img/' + imgSrc` for calculating the image path.\n * * `maxBlurredPlaceholders`: Specifies the max number of blurred images. Defaults to 5.\n * * `blurredPlaceholdersCacheSize`: Specifies the max number of blurred images to be cached\n *   to avoid expensive recalculation. Set to 0 if caching should be disabled. Set to -1 if\n *   all placeholders should be cached (good for static sites). Defaults to 30.\n *\n * Important: blurry image placeholder computation is expensive. Make sure to\n * only use it for static or cached pages.\n */\nclass AddBlurryImagePlaceholders {\n  constructor(config) {\n    this.log_ = config.log.tag('AddBlurryImagePlaceholders');\n\n    // setup implementation only if placeholder generation is enabled\n    this.blurredPlaceholders_ = !!config.blurredPlaceholders;\n    if (!this.blurredPlaceholders_) {\n      this.log_.debug('disabled');\n      return;\n    }\n\n    // check whether all required dependencies are installed\n    if (!isDependencyInstalled('jimp') || !isDependencyInstalled('lru-cache')) {\n      this.log_.warn(\n        'jimp and lru-cache need to be installed via `npm install jimp lru-cache` ' +\n          'for this transformer to work'\n      );\n      // we can't generate placeholders\n      this.blurredPlaceholders_ = false;\n      return;\n    }\n    this.jimp = require('jimp');\n\n    // use provided upper placeholder limit for fallback to default\n    this.maxBlurredPlaceholders_ = config.maxBlurredPlaceholders || MAX_BLURRED_PLACEHOLDERS;\n    // used for resolving image files\n    this.pathResolver_ = new PathResolver(config.imageBasePath);\n\n    // setup caching\n    const maxCacheSize = config.blurredPlaceholdersCacheSize || DEFAULT_CACHED_PLACEHOLDERS;\n    // use a Map if all placeholders should be cached\n    if (maxCacheSize === CACHE_ALL_PLACEHOLDERS) {\n      this.log_.debug('caching all placeholders');\n      this.cache_ = new Map();\n    } else if (maxCacheSize > 0) {\n      const LRU = require('lru-cache');\n      this.log_.debug('using LRU cache for regularily used placeholders', maxCacheSize);\n      // use a LRU cache otherwise\n      this.cache_ = new LRU({\n        max: maxCacheSize,\n      });\n    } else {\n      this.log_.debug('caching disabled');\n    }\n  }\n\n  /**\n   * Parses the document to add blurred placedholders in all appropriate\n   * locations.\n   * @param {Object} runtime parameters\n   * @return {Array} An array of promises that all represents the resolution of\n   * a blurred placeholder being added in an appropriate place.\n   */\n  transform(root, params) {\n    // Check if placeholders should be generated\n    if (!this.blurredPlaceholders_) {\n      return;\n    }\n    const html = firstChildByTag(root, 'html');\n    const body = firstChildByTag(html, 'body');\n    const promises = [];\n    let placeholders = 0;\n    for (let node = body; node !== null; node = nextNode(node)) {\n      const {tagName} = node;\n      let src;\n      if (tagName === 'template') {\n        node = skipNodeAndChildren(node);\n        continue;\n      }\n      if (tagName === 'amp-img') {\n        src = node.attribs.src;\n      }\n      if (tagName === 'amp-video' && node.attribs.poster) {\n        src = node.attribs.poster;\n      }\n\n      if (this.shouldAddBlurryPlaceholder_(node, src, tagName)) {\n        placeholders++;\n        const promise = this.addBlurryPlaceholder_(src, params).then((img) => {\n          node.attribs.noloading = '';\n          appendChild(node, img);\n        });\n        promises.push(promise);\n\n        if (placeholders >= this.maxBlurredPlaceholders_) {\n          break;\n        }\n      }\n    }\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Adds a child image that is a blurry placeholder.\n   * @param {String} src The image that the bitmap is based on.\n   * @return {!Promise} A promise that signifies that the img has been updated\n   * to have correct attributes to be a blurred placeholder along with the\n   * placeholder itself.\n   * @private\n   */\n  async addBlurryPlaceholder_(src, params) {\n    const img = createElement('img', {\n      class: 'i-amphtml-blurry-placeholder',\n      placeholder: '',\n      src,\n      alt: '',\n    });\n    try {\n      const dataURI = await this.getCachedDataURI(src, params);\n      let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\"\n                      xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                      viewBox=\"0 0 ${dataURI.width} ${dataURI.height}\">\n                      <filter id=\"b\" color-interpolation-filters=\"sRGB\">\n                        <feGaussianBlur stdDeviation=\".5\"></feGaussianBlur>\n                        <feComponentTransfer>\n                          <feFuncA type=\"discrete\" tableValues=\"1 1\"></feFuncA>\n                        </feComponentTransfer>\n                      </filter>\n                      <image filter=\"url(#b)\" x=\"0\" y=\"0\"\n                        height=\"100%\" width=\"100%\"\n                        xlink:href=\"${dataURI.src}\">\n                      </image>\n                    </svg>`;\n\n      // Optimizes dataURI length by deleting line breaks, and\n      // removing unnecessary spaces.\n      svg = svg.replace(/\\s+/g, ' ');\n      svg = svg.replace(/> </g, '><');\n      svg = svg.replace(ESCAPE_REGEX, escaper);\n\n      img.attribs.src = 'data:image/svg+xml;charset=utf-8,' + svg;\n      this.log_.debug(src, '[SUCCESS]');\n    } catch (err) {\n      this.log_.debug(src, '[FAIL]');\n      this.log_.error(err.message);\n    }\n    return img;\n  }\n\n  /**\n   * Returns a cached dataURI if exists, otherwise creates a new one.\n   */\n  getCachedDataURI(src, params) {\n    const resolvedSrc = this.pathResolver_.resolve(src, params);\n    if (this.cache_) {\n      const dataURIPromise = this.cache_.get(resolvedSrc);\n      if (dataURIPromise) {\n        this.log_.debug(src, '[CACHE HIT]');\n        return dataURIPromise;\n      }\n      this.log_.debug(src, '[CACHE MISS]');\n    }\n    const dataURIPromise = this.getDataURI_(resolvedSrc);\n    if (this.cache_) {\n      // we cache the promise to ensure that multiple requests for the same image\n      // still use the cache\n      this.cache_.set(resolvedSrc, dataURIPromise);\n    }\n    return dataURIPromise;\n  }\n\n  /**\n   * Creates the bitmap in a dataURI format.\n   * @param {string} the img src value\n   * placeholder.\n   * @return {!Promise} A promise that is resolved once the img's src is updated\n   * to be a dataURI of a bitmap including width and height.\n   * @private\n   */\n  async getDataURI_(src) {\n    const image = await this.jimp.read(src);\n    const imgDimension = this.getBitmapDimensions_(image.bitmap.width, image.bitmap.height);\n    image.resize(imgDimension.width, imgDimension.height, this.jimp.RESIZE_BEZIER);\n    const result = {\n      src: await image.getBase64Async('image/png'),\n      width: imgDimension.width,\n      height: imgDimension.height,\n    };\n    return result;\n  }\n\n  /**\n   * Calculates the correct dimensions for the bitmap.\n   * @param {Node} img The DOM element that will need a bitmap.\n   * placeholder.\n   * @return {Record} The aspect ratio of the bitmap of the image.\n   * @private\n   */\n  getBitmapDimensions_(imgWidth, imgHeight) {\n    // Aims for a bitmap of ~P pixels (w * h = ~P).\n    // Gets the ratio of the width to the height. (r = w0 / h0 = w / h)\n    const ratioWH = imgWidth / imgHeight;\n    // Express the width in terms of height by multiply the ratio by the\n    // height. (h * r = (w / h) * h)\n    // Plug this representation of the width into the original equation.\n    // (h * r * h = ~P).\n    // Divide the bitmap size by the ratio to get the all expressions using\n    // height on one side. (h * h = ~P / r)\n    let bitmapHeight = PIXEL_TARGET / ratioWH;\n    // Take the square root of the height instances to find the singular value\n    // for the height. (h = sqrt(~P / r))\n    bitmapHeight = Math.sqrt(bitmapHeight);\n    // Divide the goal total pixel amount by the height to get the width.\n    // (w = ~P / h).\n    const bitmapWidth = PIXEL_TARGET / bitmapHeight;\n    return {width: Math.round(bitmapWidth), height: Math.round(bitmapHeight)};\n  }\n\n  /**\n   * Checks if an element has a placeholder.\n   * @param {Node} node The DOM element that is being checked for a placeholder.\n   * @return {boolean} Whether or not the element already has a placeholder\n   * child.\n   * @private\n   */\n  hasPlaceholder_(node) {\n    return (\n      node.childNodes.find((child) => {\n        return child.attribs && child.attribs.placeholder !== undefined;\n      }) !== undefined\n    );\n  }\n\n  /**\n   * Checks if an image should have a blurred image placeholder.\n   * The current criteria for determining if a blurry image placeholder should\n   * be appended is as follows:\n   * - The source for the image should be a JPEG.\n   * - If the element is:\n   *    - an amp-img using a responsive layout (responsive, fill or intrinsic)\n   *    - an amp-video with a poster\n   *\n   * This criteria was found to be the most common places where a blurry image\n   * placeholder would likely want to be used through manual examination of\n   * existing AMP pages.\n   * @param {Node} node The DOM element that is being checked to see if it\n   * should have a blurred placeholder.\n   * @param {string} src The image source that is being checked.\n   * @param {string} tagName The type of element that is being checked.\n   * @return {boolean} Whether or not the element should have a blurred\n   * placeholder child.\n   * @private\n   */\n  shouldAddBlurryPlaceholder_(node, src, tagName) {\n    // Ensures current placeholders are not overridden.\n    if (!src) {\n      return false;\n    }\n    if (this.hasPlaceholder_(node)) {\n      return false;\n    }\n\n    // Non-JPEG images are not commonly featured in a role where blurred\n    // image placeholders would be wanted.\n    const url = new URL(src, 'https://example.com');\n    if (!url.pathname.endsWith('.jpg') && !url.pathname.endsWith('jpeg')) {\n      return false;\n    }\n\n    // Images or videos with noloading attributes should not have any indicators that they\n    // are loading.\n    if (node.attribs.noloading != null) {\n      return false;\n    }\n\n    // Checks if the image is a poster or a responsive image as these are the\n    // two most common cases where blurred placeholders would be wanted.\n    const isPoster = tagName == 'amp-video';\n    const isResponsiveImgWithLoading =\n      tagName == 'amp-img' &&\n      (node.attribs.layout == 'intrinsic' ||\n        node.attribs.layout == 'responsive' ||\n        node.attribs.layout == 'fill');\n    return isPoster || isResponsiveImgWithLoading;\n  }\n}\n\n/** @module AddBlurryImagePlaceholders */\nmodule.exports = AddBlurryImagePlaceholders;\n"]},"metadata":{},"sourceType":"script"}