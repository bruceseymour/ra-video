{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _compression = _interopRequireDefault(require(\"next/dist/compiled/compression\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _httpProxy = _interopRequireDefault(require(\"next/dist/compiled/http-proxy\"));\n\nvar _path = require(\"path\");\n\nvar _querystring = require(\"querystring\");\n\nvar _url = require(\"url\");\n\nvar _loadCustomRoutes = require(\"../../lib/load-custom-routes\");\n\nvar _coalescedFunction = require(\"../../lib/coalesced-function\");\n\nvar _constants = require(\"../lib/constants\");\n\nvar _utils = require(\"../lib/router/utils\");\n\nvar envConfig = _interopRequireWildcard(require(\"../lib/runtime-config\"));\n\nvar _utils2 = require(\"../lib/utils\");\n\nvar _apiUtils = require(\"./api-utils\");\n\nvar _config = _interopRequireWildcard(require(\"./config\"));\n\nvar _pathMatch = _interopRequireDefault(require(\"../lib/router/utils/path-match\"));\n\nvar _recursiveReaddirSync = require(\"./lib/recursive-readdir-sync\");\n\nvar _loadComponents = require(\"./load-components\");\n\nvar _normalizePagePath = require(\"./normalize-page-path\");\n\nvar _render = require(\"./render\");\n\nvar _require = require(\"./require\");\n\nvar _router = _interopRequireWildcard(require(\"./router\"));\n\nvar _prepareDestination = _interopRequireWildcard(require(\"../lib/router/utils/prepare-destination\"));\n\nvar _sendPayload = require(\"./send-payload\");\n\nvar _serveStatic = require(\"./serve-static\");\n\nvar _incrementalCache = require(\"./incremental-cache\");\n\nvar _utils3 = require(\"./utils\");\n\nvar _env = require(\"@next/env\");\n\nrequire(\"./node-polyfill-fetch\");\n\nvar _normalizeTrailingSlash = require(\"../../client/normalize-trailing-slash\");\n\nvar _getRouteFromAssetPath = _interopRequireDefault(require(\"../lib/router/utils/get-route-from-asset-path\"));\n\nvar _denormalizePagePath = require(\"./denormalize-page-path\");\n\nvar _accept = _interopRequireDefault(require(\"@hapi/accept\"));\n\nvar _normalizeLocalePath = require(\"../lib/i18n/normalize-locale-path\");\n\nvar _detectLocaleCookie = require(\"../lib/i18n/detect-locale-cookie\");\n\nvar Log = _interopRequireWildcard(require(\"../../build/output/log\"));\n\nvar _imageOptimizer = require(\"./image-optimizer\");\n\nvar _detectDomainLocale = require(\"../lib/i18n/detect-domain-locale\");\n\nvar _cookie = _interopRequireDefault(require(\"next/dist/compiled/cookie\"));\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../lib/router/utils/escape-path-delimiters\"));\n\nvar _utils4 = require(\"../../build/webpack/loaders/next-serverless-loader/utils\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst getCustomRouteMatcher = (0, _pathMatch.default)(true);\n\nclass Server {\n  constructor({\n    dir = '.',\n    quiet = false,\n    conf = null,\n    dev = false,\n    minimalMode = false,\n    customServer = true\n  } = {}) {\n    var _this$nextConfig$expe, _this$nextConfig$i18n, _this$nextConfig$i18n2;\n\n    this.dir = void 0;\n    this.quiet = void 0;\n    this.nextConfig = void 0;\n    this.distDir = void 0;\n    this.pagesDir = void 0;\n    this.publicDir = void 0;\n    this.hasStaticDir = void 0;\n    this.serverBuildDir = void 0;\n    this.pagesManifest = void 0;\n    this.buildId = void 0;\n    this.minimalMode = void 0;\n    this.renderOpts = void 0;\n    this.compression = void 0;\n    this.onErrorMiddleware = void 0;\n    this.incrementalCache = void 0;\n    this.router = void 0;\n    this.dynamicRoutes = void 0;\n    this.customRoutes = void 0;\n    this._cachedPreviewManifest = void 0;\n    this.customErrorNo404Warn = (0, _utils2.execOnce)(() => {\n      console.warn(_chalk.default.bold.yellow(`Warning: `) + _chalk.default.yellow(`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://err.sh/next.js/custom-error-no-custom-404`));\n    });\n    this._validFilesystemPathSet = null;\n    this.dir = (0, _path.resolve)(dir);\n    this.quiet = quiet;\n    const phase = this.currentPhase();\n    (0, _env.loadEnvConfig)(this.dir, dev, Log);\n    this.nextConfig = (0, _config.default)(phase, this.dir, conf);\n    this.distDir = (0, _path.join)(this.dir, this.nextConfig.distDir);\n    this.publicDir = (0, _path.join)(this.dir, _constants.CLIENT_PUBLIC_FILES_PATH);\n    this.hasStaticDir = _fs.default.existsSync((0, _path.join)(this.dir, 'static')); // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress\n    } = this.nextConfig;\n    this.buildId = this.readBuildId();\n    this.minimalMode = minimalMode;\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase,\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: (_this$nextConfig$expe = this.nextConfig.experimental.amp) == null ? void 0 : _this$nextConfig$expe.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: this.nextConfig.experimental.optimizeFonts && !dev,\n      fontManifest: this.nextConfig.experimental.optimizeFonts && !dev ? (0, _require.requireFontManifest)(this.distDir, this._isLikeServerless) : null,\n      optimizeImages: this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      domainLocales: (_this$nextConfig$i18n = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n.domains\n    }; // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig;\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = (0, _compression.default)();\n    } // Initialize next/config with the environment configuration\n\n\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig\n    });\n    this.serverBuildDir = (0, _path.join)(this.distDir, this._isLikeServerless ? _constants.SERVERLESS_DIRECTORY : _constants.SERVER_DIRECTORY);\n    const pagesManifestPath = (0, _path.join)(this.serverBuildDir, _constants.PAGES_MANIFEST);\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath);\n    }\n\n    this.customRoutes = this.getCustomRoutes();\n    this.router = new _router.default(this.generateRoutes());\n    this.setAssetPrefix(assetPrefix); // call init-server middleware, this is also handled\n    // individually in serverless bundles when deployed\n\n    if (!dev && this.nextConfig.experimental.plugins) {\n      const initServer = require((0, _path.join)(this.serverBuildDir, 'init-server.js')).default;\n\n      this.onErrorMiddleware = require((0, _path.join)(this.serverBuildDir, 'on-error-server.js')).default;\n      initServer();\n    }\n\n    this.incrementalCache = new _incrementalCache.IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: (0, _path.join)(this.distDir, this._isLikeServerless ? _constants.SERVERLESS_DIRECTORY : _constants.SERVER_DIRECTORY, 'pages'),\n      locales: (_this$nextConfig$i18n2 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n2.locales,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.sprFlushToDisk\n    });\n    /**\n    * This sets environment variable to be used at the time of SSR by head.tsx.\n    * Using this from process.env allows targetting both serverless and SSR by calling\n    * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n    * TODO(atcastle@): Remove this when experimental.optimizeImages are being clened up.\n    */\n\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);\n    }\n\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true);\n    }\n\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);\n    }\n  }\n\n  currentPhase() {\n    return _constants.PHASE_PRODUCTION_SERVER;\n  }\n\n  logError(err) {\n    if (this.onErrorMiddleware) {\n      this.onErrorMiddleware({\n        err\n      });\n    }\n\n    if (this.quiet) return;\n    console.error(err);\n  }\n\n  async handleRequest(req, res, parsedUrl) {\n    var _req$url, _req$url2;\n\n    (0, _apiUtils.setLazyProp)({\n      req: req\n    }, 'cookies', (0, _apiUtils.getCookieParser)(req)); // Parse url if parsedUrl not provided\n\n    if (!parsedUrl || typeof parsedUrl !== 'object') {\n      const url = req.url;\n      parsedUrl = (0, _url.parse)(url, true);\n    } // Parse the querystring ourselves if the user doesn't handle querystring parsing\n\n\n    if (typeof parsedUrl.query === 'string') {\n      parsedUrl.query = (0, _querystring.parse)(parsedUrl.query);\n    }\n\n    ;\n    req.__NEXT_INIT_QUERY = Object.assign({}, parsedUrl.query);\n    const {\n      basePath,\n      i18n\n    } = this.nextConfig;\n\n    if (basePath && (_req$url = req.url) != null && _req$url.startsWith(basePath)) {\n      // store original URL to allow checking if basePath was\n      // provided or not\n      ;\n      req._nextHadBasePath = true;\n      req.url = req.url.replace(basePath, '') || '/';\n    }\n\n    if (i18n && !((_req$url2 = req.url) != null && _req$url2.startsWith('/_next'))) {\n      // get pathname from URL with basePath stripped for locale detection\n      let {\n        pathname,\n        ...parsed\n      } = (0, _url.parse)(req.url || '/');\n      pathname = pathname || '/';\n      let defaultLocale = i18n.defaultLocale;\n      let detectedLocale = (0, _detectLocaleCookie.detectLocaleCookie)(req, i18n.locales);\n      let acceptPreferredLocale = i18n.localeDetection !== false ? _accept.default.language(req.headers['accept-language'], i18n.locales) : detectedLocale;\n      const {\n        host\n      } = (req == null ? void 0 : req.headers) || {}; // remove port from host and remove port if present\n\n      const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n      const detectedDomain = (0, _detectDomainLocale.detectDomainLocale)(i18n.domains, hostname);\n\n      if (detectedDomain) {\n        defaultLocale = detectedDomain.defaultLocale;\n        detectedLocale = defaultLocale;\n      } // if not domain specific locale use accept-language preferred\n\n\n      detectedLocale = detectedLocale || acceptPreferredLocale;\n      let localeDomainRedirect;\n      req.__nextHadTrailingSlash = pathname.endsWith('/');\n\n      if (pathname === '/') {\n        ;\n        req.__nextHadTrailingSlash = this.nextConfig.trailingSlash;\n      }\n\n      const localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(pathname, i18n.locales);\n\n      if (localePathResult.detectedLocale) {\n        detectedLocale = localePathResult.detectedLocale;\n        req.url = (0, _url.format)({ ...parsed,\n          pathname: localePathResult.pathname\n        });\n        req.__nextStrippedLocale = true;\n      } // If a detected locale is a domain specific locale and we aren't already\n      // on that domain and path prefix redirect to it to prevent duplicate\n      // content from multiple domains\n\n\n      if (detectedDomain && pathname === '/') {\n        const localeToCheck = acceptPreferredLocale; // const localeToCheck = localePathResult.detectedLocale\n        //   ? detectedLocale\n        //   : acceptPreferredLocale\n\n        const matchedDomain = (0, _detectDomainLocale.detectDomainLocale)(i18n.domains, undefined, localeToCheck);\n\n        if (matchedDomain && (matchedDomain.domain !== detectedDomain.domain || localeToCheck !== matchedDomain.defaultLocale)) {\n          localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${matchedDomain.domain}/${localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck}`;\n        }\n      }\n\n      const denormalizedPagePath = (0, _denormalizePagePath.denormalizePagePath)(pathname || '/');\n      const detectedDefaultLocale = !detectedLocale || detectedLocale.toLowerCase() === defaultLocale.toLowerCase();\n      const shouldStripDefaultLocale = false; // detectedDefaultLocale &&\n      // denormalizedPagePath.toLowerCase() ===\n      //   `/${i18n.defaultLocale.toLowerCase()}`\n\n      const shouldAddLocalePrefix = !detectedDefaultLocale && denormalizedPagePath === '/';\n      detectedLocale = detectedLocale || i18n.defaultLocale;\n\n      if (i18n.localeDetection !== false && (localeDomainRedirect || shouldAddLocalePrefix || shouldStripDefaultLocale)) {\n        // set the NEXT_LOCALE cookie when a user visits the default locale\n        // with the locale prefix so that they aren't redirected back to\n        // their accept-language preferred locale\n        if (shouldStripDefaultLocale && acceptPreferredLocale !== defaultLocale) {\n          const previous = res.getHeader('set-cookie');\n          res.setHeader('set-cookie', [...(typeof previous === 'string' ? [previous] : Array.isArray(previous) ? previous : []), _cookie.default.serialize('NEXT_LOCALE', defaultLocale, {\n            httpOnly: true,\n            path: '/'\n          })]);\n        }\n\n        res.setHeader('Location', localeDomainRedirect ? localeDomainRedirect : (0, _url.format)({ // make sure to include any query values when redirecting\n          ...parsed,\n          pathname: shouldStripDefaultLocale ? basePath || `/` : `${basePath || ''}/${detectedLocale}`\n        }));\n        res.statusCode = _constants.TEMPORARY_REDIRECT_STATUS;\n        res.end();\n        return;\n      }\n\n      parsedUrl.query.__nextDefaultLocale = (detectedDomain == null ? void 0 : detectedDomain.defaultLocale) || i18n.defaultLocale;\n      parsedUrl.query.__nextLocale = localePathResult.detectedLocale || (detectedDomain == null ? void 0 : detectedDomain.defaultLocale) || defaultLocale;\n    }\n\n    if (this.minimalMode && req.headers['x-matched-path'] && typeof req.headers['x-matched-path'] === 'string') {\n      var _req$url3, _req$headers$xMatche;\n\n      const reqUrlIsDataUrl = (_req$url3 = req.url) == null ? void 0 : _req$url3.includes('/_next/data');\n      const matchedPathIsDataUrl = (_req$headers$xMatche = req.headers['x-matched-path']) == null ? void 0 : _req$headers$xMatche.includes('/_next/data');\n      const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl;\n      let parsedPath = (0, _url.parse)(isDataUrl ? req.url : req.headers['x-matched-path'], true);\n      const {\n        pathname,\n        query\n      } = parsedPath;\n      let matchedPathname = pathname;\n      const matchedPathnameNoExt = isDataUrl ? matchedPathname.replace(/\\.json$/, '') : matchedPathname; // interpolate dynamic params and normalize URL if needed\n\n      if ((0, _utils.isDynamicRoute)(matchedPathnameNoExt)) {\n        const utils = (0, _utils4.getUtils)({\n          pageIsDynamic: true,\n          page: matchedPathnameNoExt,\n          i18n: this.nextConfig.i18n,\n          basePath: this.nextConfig.basePath,\n          rewrites: this.customRoutes.rewrites\n        });\n        let params = {};\n        const paramsResult = utils.normalizeDynamicRouteParams({ ...parsedUrl.query,\n          ...query\n        });\n\n        if (paramsResult.hasValidParams) {\n          params = paramsResult.params;\n        } else if (req.headers['x-now-route-matches']) {\n          const opts = {};\n          params = utils.getParamsFromRouteMatches(req, opts, parsedUrl.query.__nextLocale || '');\n\n          if (opts.locale) {\n            parsedUrl.query.__nextLocale = opts.locale;\n          }\n        } else {\n          params = utils.dynamicRouteMatcher(matchedPathname);\n        }\n\n        if (params) {\n          matchedPathname = utils.interpolateDynamicPath(matchedPathname, params);\n          req.url = utils.interpolateDynamicPath(req.url, params);\n        }\n\n        if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n          req.url = (0, _url.format)({ ...parsedPath,\n            pathname: matchedPathname\n          });\n        }\n\n        Object.assign(parsedUrl.query, params);\n        utils.normalizeVercelUrl(req, true);\n      }\n\n      parsedUrl.pathname = `${basePath || ''}${parsedUrl.query.__nextLocale || ''}${matchedPathname}`;\n    }\n\n    res.statusCode = 200;\n\n    try {\n      return await this.run(req, res, parsedUrl);\n    } catch (err) {\n      this.logError(err);\n      res.statusCode = 500;\n      res.end('Internal Server Error');\n    }\n  }\n\n  getRequestHandler() {\n    return this.handleRequest.bind(this);\n  }\n\n  setAssetPrefix(prefix) {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : '';\n  } // Backwards compatibility\n\n\n  async prepare() {} // Backwards compatibility\n\n\n  async close() {}\n\n  setImmutableAssetCacheControl(res) {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  }\n\n  getCustomRoutes() {\n    return require((0, _path.join)(this.distDir, _constants.ROUTES_MANIFEST));\n  }\n\n  getPrerenderManifest() {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest;\n    }\n\n    const manifest = require((0, _path.join)(this.distDir, _constants.PRERENDER_MANIFEST));\n\n    return this._cachedPreviewManifest = manifest;\n  }\n\n  getPreviewProps() {\n    return this.getPrerenderManifest().preview;\n  }\n\n  generateRoutes() {\n    var _this$nextConfig$i18n4;\n\n    const server = this;\n    const publicRoutes = _fs.default.existsSync(this.publicDir) ? this.generatePublicRoutes() : [];\n    const staticFilesRoute = this.hasStaticDir ? [{\n      // It's very important to keep this route's param optional.\n      // (but it should support as many params as needed, separated by '/')\n      // Otherwise this will lead to a pretty simple DOS attack.\n      // See more: https://github.com/vercel/next.js/issues/2617\n      match: (0, _router.route)('/static/:path*'),\n      name: 'static catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        const p = (0, _path.join)(this.dir, 'static', ...params.path);\n        await this.serveStatic(req, res, p, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }] : [];\n    const fsRoutes = [{\n      match: (0, _router.route)('/_next/static/:path*'),\n      type: 'route',\n      name: '_next/static catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        // make sure to 404 for /_next/static itself\n        if (!params.path) {\n          await this.render404(req, res, parsedUrl);\n          return {\n            finished: true\n          };\n        }\n\n        if (params.path[0] === _constants.CLIENT_STATIC_FILES_RUNTIME || params.path[0] === 'chunks' || params.path[0] === 'css' || params.path[0] === 'media' || params.path[0] === this.buildId || params.path[0] === 'pages' || params.path[1] === 'pages') {\n          this.setImmutableAssetCacheControl(res);\n        }\n\n        const p = (0, _path.join)(this.distDir, _constants.CLIENT_STATIC_FILES_PATH, ...(params.path || []));\n        await this.serveStatic(req, res, p, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, {\n      match: (0, _router.route)('/_next/data/:path*'),\n      type: 'route',\n      name: '_next/data catchall',\n      fn: async (req, res, params, _parsedUrl) => {\n        // Make sure to 404 for /_next/data/ itself and\n        // we also want to 404 if the buildId isn't correct\n        if (!params.path || params.path[0] !== this.buildId) {\n          await this.render404(req, res, _parsedUrl);\n          return {\n            finished: true\n          };\n        } // remove buildId from URL\n\n\n        params.path.shift(); // show 404 if it doesn't end with .json\n\n        if (!params.path[params.path.length - 1].endsWith('.json')) {\n          await this.render404(req, res, _parsedUrl);\n          return {\n            finished: true\n          };\n        } // re-create page's pathname\n\n\n        let pathname = `/${params.path.join('/')}`;\n        pathname = (0, _getRouteFromAssetPath.default)(pathname, '.json');\n        const {\n          i18n\n        } = this.nextConfig;\n\n        if (i18n) {\n          const {\n            host\n          } = (req == null ? void 0 : req.headers) || {}; // remove port from host and remove port if present\n\n          const hostname = host == null ? void 0 : host.split(':')[0].toLowerCase();\n          const localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(pathname, i18n.locales);\n          const {\n            defaultLocale\n          } = (0, _detectDomainLocale.detectDomainLocale)(i18n.domains, hostname) || {};\n          let detectedLocale = '';\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname;\n            detectedLocale = localePathResult.detectedLocale;\n          }\n\n          _parsedUrl.query.__nextLocale = detectedLocale;\n          _parsedUrl.query.__nextDefaultLocale = defaultLocale || i18n.defaultLocale;\n\n          if (!detectedLocale) {\n            _parsedUrl.query.__nextLocale = _parsedUrl.query.__nextDefaultLocale;\n            await this.render404(req, res, _parsedUrl);\n            return {\n              finished: true\n            };\n          }\n        }\n\n        const parsedUrl = (0, _url.parse)(pathname, true);\n        await this.render(req, res, pathname, { ..._parsedUrl.query,\n          _nextDataReq: '1'\n        }, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, {\n      match: (0, _router.route)('/_next/image'),\n      type: 'route',\n      name: '_next/image catchall',\n      fn: (req, res, _params, parsedUrl) => (0, _imageOptimizer.imageOptimizer)(server, req, res, parsedUrl)\n    }, {\n      match: (0, _router.route)('/_next/:path*'),\n      type: 'route',\n      name: '_next catchall',\n      // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n      fn: async (req, res, _params, parsedUrl) => {\n        await this.render404(req, res, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, ...publicRoutes, ...staticFilesRoute];\n\n    const getCustomRoute = (r, type) => {\n      const match = getCustomRouteMatcher(r.source);\n      return { ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({\n          finished: false\n        })\n      };\n    }; // Headers come very first\n\n\n    const headers = this.customRoutes.headers.map(r => {\n      const headerRoute = getCustomRoute(r, 'header');\n      return {\n        match: headerRoute.match,\n        type: headerRoute.type,\n        name: `${headerRoute.type} ${headerRoute.source} header route`,\n        fn: async (_req, res, params, _parsedUrl) => {\n          const hasParams = Object.keys(params).length > 0;\n\n          for (const header of headerRoute.headers) {\n            let {\n              key,\n              value\n            } = header;\n\n            if (hasParams) {\n              key = (0, _prepareDestination.compileNonPath)(key, params);\n              value = (0, _prepareDestination.compileNonPath)(value, params);\n            }\n\n            res.setHeader(key, value);\n          }\n\n          return {\n            finished: false\n          };\n        }\n      };\n    }); // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n\n    const stringifyQuery = (req, query) => {\n      const initialQueryValues = Object.values(req.__NEXT_INIT_QUERY);\n      return (0, _querystring.stringify)(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some(val => val === value)) {\n            return encodeURIComponent(value);\n          }\n\n          return value;\n        }\n\n      });\n    };\n\n    const redirects = this.minimalMode ? [] : this.customRoutes.redirects.map(redirect => {\n      const redirectRoute = getCustomRoute(redirect, 'redirect');\n      return {\n        internal: redirectRoute.internal,\n        type: redirectRoute.type,\n        match: redirectRoute.match,\n        statusCode: redirectRoute.statusCode,\n        name: `Redirect route ${redirectRoute.source}`,\n        fn: async (req, res, params, parsedUrl) => {\n          const {\n            parsedDestination\n          } = (0, _prepareDestination.default)(redirectRoute.destination, params, parsedUrl.query, false);\n          const {\n            query\n          } = parsedDestination;\n          delete parsedDestination.query;\n          parsedDestination.search = stringifyQuery(req, query);\n          const updatedDestination = (0, _url.format)(parsedDestination);\n          res.setHeader('Location', updatedDestination);\n          res.statusCode = (0, _loadCustomRoutes.getRedirectStatus)(redirectRoute); // Since IE11 doesn't support the 308 header add backwards\n          // compatibility using refresh header\n\n          if (res.statusCode === 308) {\n            res.setHeader('Refresh', `0;url=${updatedDestination}`);\n          }\n\n          res.end();\n          return {\n            finished: true\n          };\n        }\n      };\n    });\n    const rewrites = this.customRoutes.rewrites.map(rewrite => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite');\n      return { ...rewriteRoute,\n        check: true,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const {\n            newUrl,\n            parsedDestination\n          } = (0, _prepareDestination.default)(rewriteRoute.destination, params, parsedUrl.query, true); // external rewrite, proxy it\n\n          if (parsedDestination.protocol) {\n            const {\n              query\n            } = parsedDestination;\n            delete parsedDestination.query;\n            parsedDestination.search = stringifyQuery(req, query);\n            const target = (0, _url.format)(parsedDestination);\n            const proxy = new _httpProxy.default({\n              target,\n              changeOrigin: true,\n              ignorePath: true\n            });\n            proxy.web(req, res);\n            proxy.on('error', err => {\n              console.error(`Error occurred proxying ${target}`, err);\n            });\n            return {\n              finished: true\n            };\n          }\n\n          ;\n          req._nextRewroteUrl = newUrl;\n          req._nextDidRewrite = req._nextRewroteUrl !== req.url;\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query\n          };\n        }\n      };\n    });\n    const catchAllRoute = {\n      match: (0, _router.route)('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let {\n          pathname,\n          query\n        } = parsedUrl;\n\n        if (!pathname) {\n          throw new Error('pathname is undefined');\n        } // next.js core assumes page path without trailing slash\n\n\n        pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n\n        if (this.nextConfig.i18n) {\n          var _this$nextConfig$i18n3;\n\n          const localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(pathname, (_this$nextConfig$i18n3 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n3.locales);\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname;\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale;\n          }\n        }\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          const handled = await this.handleApiRequest(req, res, pathname, query);\n\n          if (handled) {\n            return {\n              finished: true\n            };\n          }\n        }\n\n        await this.render(req, res, pathname, query, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    };\n    const {\n      useFileSystemPublicRoutes\n    } = this.nextConfig;\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes();\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites,\n      redirects,\n      catchAllRoute,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: ((_this$nextConfig$i18n4 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n4.locales) || []\n    };\n  }\n\n  async getPagePath(pathname) {\n    return (0, _require.getPagePath)(pathname, this.distDir, this._isLikeServerless, this.renderOpts.dev);\n  }\n\n  async hasPage(pathname) {\n    let found = false;\n\n    try {\n      found = !!(await this.getPagePath(pathname));\n    } catch (_) {}\n\n    return found;\n  }\n\n  async _beforeCatchAllRender(_req, _res, _params, _parsedUrl) {\n    return false;\n  } // Used to build API page in development\n\n\n  async ensureApiPage(_pathname) {}\n  /**\n  * Resolves `API` request, in development builds on demand\n  * @param req http request\n  * @param res http response\n  * @param pathname path of request\n  */\n\n\n  async handleApiRequest(req, res, pathname, query) {\n    let page = pathname;\n    let params = false;\n    let pageFound = await this.hasPage(page);\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname);\n\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page;\n          pageFound = true;\n          break;\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false;\n    } // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n\n\n    await this.ensureApiPage(page);\n    let builtPagePath;\n\n    try {\n      builtPagePath = await this.getPagePath(page);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false;\n      }\n\n      throw err;\n    }\n\n    const pageModule = await require(builtPagePath);\n    query = { ...query,\n      ...params\n    };\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query);\n        await pageModule.default(req, res);\n        return true;\n      }\n    }\n\n    await (0, _apiUtils.apiResolver)(req, res, query, pageModule, this.renderOpts.previewProps, false, this.onErrorMiddleware);\n    return true;\n  }\n\n  generatePublicRoutes() {\n    const publicFiles = new Set((0, _recursiveReaddirSync.recursiveReadDirSync)(this.publicDir).map(p => encodeURI(p.replace(/\\\\/g, '/'))));\n    return [{\n      match: (0, _router.route)('/:path*'),\n      name: 'public folder catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        const pathParts = params.path || [];\n        const {\n          basePath\n        } = this.nextConfig; // if basePath is defined require it be present\n\n        if (basePath) {\n          const basePathParts = basePath.split('/'); // remove first empty value\n\n          basePathParts.shift();\n\n          if (!basePathParts.every((part, idx) => {\n            return part === pathParts[idx];\n          })) {\n            return {\n              finished: false\n            };\n          }\n\n          pathParts.splice(0, basePathParts.length);\n        }\n\n        const path = `/${pathParts.join('/')}`;\n\n        if (publicFiles.has(path)) {\n          await this.serveStatic(req, res, (0, _path.join)(this.publicDir, ...pathParts), parsedUrl);\n          return {\n            finished: true\n          };\n        }\n\n        return {\n          finished: false\n        };\n      }\n    }];\n  }\n\n  getDynamicRoutes() {\n    const addedPages = new Set();\n    return (0, _utils.getSortedRoutes)(Object.keys(this.pagesManifest).map(page => {\n      var _this$nextConfig$i18n5;\n\n      return (0, _normalizeLocalePath.normalizeLocalePath)(page, (_this$nextConfig$i18n5 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n5.locales).pathname;\n    })).map(page => {\n      if (addedPages.has(page) || !(0, _utils.isDynamicRoute)(page)) return null;\n      addedPages.add(page);\n      return {\n        page,\n        match: (0, _utils.getRouteMatcher)((0, _utils.getRouteRegex)(page))\n      };\n    }).filter(item => Boolean(item));\n  }\n\n  handleCompression(req, res) {\n    if (this.compression) {\n      this.compression(req, res, () => {});\n    }\n  }\n\n  async run(req, res, parsedUrl) {\n    this.handleCompression(req, res);\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl);\n\n      if (matched) {\n        return;\n      }\n    } catch (err) {\n      if (err.code === 'DECODE_FAILED') {\n        res.statusCode = 400;\n        return this.renderError(null, req, res, '/_error', {});\n      }\n\n      throw err;\n    }\n\n    await this.render404(req, res, parsedUrl);\n  }\n\n  async sendHTML(req, res, html) {\n    const {\n      generateEtags,\n      poweredByHeader\n    } = this.renderOpts;\n    return (0, _sendPayload.sendPayload)(req, res, html, 'html', {\n      generateEtags,\n      poweredByHeader\n    });\n  }\n\n  async render(req, res, pathname, query = {}, parsedUrl) {\n    if (!pathname.startsWith('/')) {\n      console.warn(`Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://err.sh/next.js/render-no-starting-slash`);\n    }\n\n    if (this.renderOpts.customServer && pathname === '/index' && !(await this.hasPage('/index'))) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/';\n    }\n\n    const url = req.url; // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n\n    if (!query._nextDataReq && (url.match(/^\\/_next\\//) || this.hasStaticDir && url.match(/^\\/static\\//))) {\n      return this.handleRequest(req, res, parsedUrl);\n    }\n\n    if ((0, _utils3.isBlockedPage)(pathname)) {\n      return this.render404(req, res, parsedUrl);\n    }\n\n    const html = await this.renderToHTML(req, res, pathname, query); // Request was ended by the user\n\n    if (html === null) {\n      return;\n    }\n\n    return this.sendHTML(req, res, html);\n  }\n\n  async findPageComponents(pathname, query = {}, params = null) {\n    let paths = [// try serving a static AMP version first\n    query.amp ? (0, _normalizePagePath.normalizePagePath)(pathname) + '.amp' : null, pathname].filter(Boolean);\n\n    if (query.__nextLocale) {\n      paths = [...paths.map(path => `/${query.__nextLocale}${path === '/' ? '' : path}`), ...paths];\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await (0, _loadComponents.loadComponents)(this.distDir, pagePath, !this.renderOpts.dev && this._isLikeServerless); // if loading an static HTML file the locale is required\n        // to be present since all HTML files are output under their locale\n\n        if (query.__nextLocale && typeof components.Component === 'string' && !(pagePath != null && pagePath.startsWith(`/${query.__nextLocale}`))) {\n          const err = new Error('NOT_FOUND');\n          err.code = 'ENOENT';\n          throw err;\n        }\n\n        return {\n          components,\n          query: { ...(components.getStaticProps ? {\n              amp: query.amp,\n              _nextDataReq: query._nextDataReq,\n              __nextLocale: query.__nextLocale,\n              __nextDefaultLocale: query.__nextDefaultLocale\n            } : query),\n            ...(params || {})\n          }\n        };\n      } catch (err) {\n        if (err.code !== 'ENOENT') throw err;\n      }\n    }\n\n    return null;\n  }\n\n  async getStaticPaths(pathname) {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined; // Read whether or not fallback should exist from the manifest.\n\n    const fallbackField = this.getPrerenderManifest().dynamicRoutes[pathname].fallback;\n    return {\n      staticPaths,\n      fallbackMode: typeof fallbackField === 'string' ? 'static' : fallbackField === null ? 'blocking' : false\n    };\n  }\n\n  async renderToHTMLWithComponents(req, res, pathname, {\n    components,\n    query\n  }, opts) {\n    var _this$nextConfig$i18n6, _this$nextConfig$i18n7;\n\n    const is404Page = pathname === '/404';\n    const isLikeServerless = typeof components.Component === 'object' && typeof components.Component.renderReqToHTML === 'function';\n    const isSSG = !!components.getStaticProps;\n    const isServerProps = !!components.getServerSideProps;\n    const hasStaticPaths = !!components.getStaticPaths; // Toggle whether or not this is a Data request\n\n    const isDataReq = !!query._nextDataReq && (isSSG || isServerProps);\n    delete query._nextDataReq; // we need to ensure the status code if /404 is visited directly\n\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404;\n    } // handle static page\n\n\n    if (typeof components.Component === 'string') {\n      return components.Component;\n    }\n\n    if (!query.amp) {\n      delete query.amp;\n    }\n\n    const locale = query.__nextLocale;\n    const defaultLocale = isSSG ? (_this$nextConfig$i18n6 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n6.defaultLocale : query.__nextDefaultLocale;\n    const {\n      i18n\n    } = this.nextConfig;\n    const locales = i18n == null ? void 0 : i18n.locales;\n    let previewData;\n    let isPreviewMode = false;\n\n    if (isServerProps || isSSG) {\n      previewData = (0, _apiUtils.tryGetPreviewData)(req, res, this.renderOpts.previewProps);\n      isPreviewMode = previewData !== false;\n    } // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n\n\n    let urlPathname = (0, _url.parse)(req.url || '').pathname || '/';\n    let resolvedUrlPathname = req._nextRewroteUrl ? req._nextRewroteUrl : urlPathname;\n    urlPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(urlPathname);\n    resolvedUrlPathname = (0, _normalizeLocalePath.normalizeLocalePath)((0, _normalizeTrailingSlash.removePathTrailingSlash)(resolvedUrlPathname), (_this$nextConfig$i18n7 = this.nextConfig.i18n) == null ? void 0 : _this$nextConfig$i18n7.locales).pathname;\n\n    const stripNextDataPath = path => {\n      if (path.includes(this.buildId)) {\n        path = (0, _denormalizePagePath.denormalizePagePath)((path.split(this.buildId).pop() || '/').replace(/\\.json$/, ''));\n      }\n\n      if (this.nextConfig.i18n) {\n        return (0, _normalizeLocalePath.normalizeLocalePath)(path, locales).pathname;\n      }\n\n      return path;\n    };\n\n    const handleRedirect = pageData => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH\n      };\n      const statusCode = (0, _loadCustomRoutes.getRedirectStatus)(redirect);\n      const {\n        basePath\n      } = this.nextConfig;\n\n      if (basePath && redirect.basePath !== false) {\n        redirect.destination = `${basePath}${redirect.destination}`;\n      }\n\n      if (statusCode === _constants.PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`);\n      }\n\n      res.statusCode = statusCode;\n      res.setHeader('Location', redirect.destination);\n      res.end();\n    }; // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n\n\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname);\n      urlPathname = stripNextDataPath(urlPathname);\n    }\n\n    let ssgCacheKey = isPreviewMode || !isSSG || this.minimalMode ? undefined // Preview mode bypasses the cache\n    : `${locale ? `/${locale}` : ''}${(pathname === '/' || resolvedUrlPathname === '/') && locale ? '' : resolvedUrlPathname}${query.amp ? '.amp' : ''}`;\n\n    if (is404Page && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${query.amp ? '.amp' : ''}`;\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey.split('/').map(seg => {\n        try {\n          seg = (0, _escapePathDelimiters.default)(decodeURIComponent(seg), true);\n        } catch (_) {\n          // An improperly encoded URL was provided, this is considered\n          // a bad request (400)\n          const err = new Error('failed to decode param');\n          err.code = 'DECODE_FAILED';\n          throw err;\n        }\n\n        return seg;\n      }).join('/');\n    } // Complete the response with cached data if its present\n\n\n    const cachedData = ssgCacheKey ? await this.incrementalCache.get(ssgCacheKey) : undefined;\n\n    if (cachedData) {\n      var _cachedData$pageData, _cachedData$pageData$;\n\n      const data = isDataReq ? JSON.stringify(cachedData.pageData) : cachedData.html;\n      const revalidateOptions = !this.renderOpts.dev ? {\n        private: isPreviewMode,\n        stateful: false,\n        // GSP response\n        revalidate: cachedData.curRevalidate !== undefined ? cachedData.curRevalidate :\n        /* default to minimum revalidate (this should be an invariant) */\n        1\n      } : undefined;\n\n      if (!isDataReq && (_cachedData$pageData = cachedData.pageData) != null && (_cachedData$pageData$ = _cachedData$pageData.pageProps) != null && _cachedData$pageData$.__N_REDIRECT) {\n        await handleRedirect(cachedData.pageData);\n      } else if (cachedData.isNotFound) {\n        if (revalidateOptions) {\n          (0, _sendPayload.setRevalidateHeaders)(res, revalidateOptions);\n        }\n\n        if (isDataReq) {\n          res.statusCode = 404;\n          res.end('{\"notFound\":true}');\n        } else {\n          await this.render404(req, res, {\n            pathname,\n            query\n          });\n        }\n      } else {\n        (0, _sendPayload.sendPayload)(req, res, data, isDataReq ? 'json' : 'html', {\n          generateEtags: this.renderOpts.generateEtags,\n          poweredByHeader: this.renderOpts.poweredByHeader\n        }, revalidateOptions);\n      } // Stop the request chain here if the data we sent was up-to-date\n\n\n      if (!cachedData.isStale) {\n        return null;\n      }\n    } // If we're here, that means data is missing or it's stale.\n\n\n    const maybeCoalesceInvoke = ssgCacheKey ? fn => (0, _coalescedFunction.withCoalescedInvoke)(fn).bind(null, ssgCacheKey, []) : fn => async () => {\n      const value = await fn();\n      return {\n        isOrigin: true,\n        value\n      };\n    };\n    const doRender = maybeCoalesceInvoke(async () => {\n      let pageData;\n      let html;\n      let sprRevalidate;\n      let isNotFound;\n      let isRedirect;\n      let renderResult; // handle serverless\n\n      if (isLikeServerless) {\n        renderResult = await components.Component.renderReqToHTML(req, res, 'passthrough', {\n          locale,\n          locales,\n          defaultLocale,\n          fontManifest: this.renderOpts.fontManifest,\n          domainLocales: this.renderOpts.domainLocales\n        });\n        html = renderResult.html;\n        pageData = renderResult.renderOpts.pageData;\n        sprRevalidate = renderResult.renderOpts.revalidate;\n        isNotFound = renderResult.renderOpts.isNotFound;\n        isRedirect = renderResult.renderOpts.isRedirect;\n      } else {\n        const origQuery = (0, _url.parse)(req.url || '', true).query;\n        const hadTrailingSlash = urlPathname !== '/' && this.nextConfig.trailingSlash;\n        const resolvedUrl = (0, _url.format)({\n          pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n          // make sure to only add query values from original URL\n          query: origQuery\n        });\n        const renderOpts = { ...components,\n          ...opts,\n          isDataReq,\n          resolvedUrl,\n          locale,\n          locales,\n          defaultLocale,\n          // For getServerSideProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on\n          // asPath\n          resolvedAsPath: isServerProps ? (0, _url.format)({\n            // we use the original URL pathname less the _next/data prefix if\n            // present\n            pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n            query: origQuery\n          }) : resolvedUrl\n        };\n        renderResult = await (0, _render.renderToHTML)(req, res, pathname, query, renderOpts);\n        html = renderResult; // TODO: change this to a different passing mechanism\n\n        pageData = renderOpts.pageData;\n        sprRevalidate = renderOpts.revalidate;\n        isNotFound = renderOpts.isNotFound;\n        isRedirect = renderOpts.isRedirect;\n      }\n\n      return {\n        html,\n        pageData,\n        sprRevalidate,\n        isNotFound,\n        isRedirect\n      };\n    });\n    const isProduction = !this.renderOpts.dev;\n    const isDynamicPathname = (0, _utils.isDynamicRoute)(pathname);\n    const didRespond = (0, _utils2.isResSent)(res);\n    const {\n      staticPaths,\n      fallbackMode\n    } = hasStaticPaths ? await this.getStaticPaths(pathname) : {\n      staticPaths: undefined,\n      fallbackMode: false\n    }; // When we did not respond from cache, we need to choose to block on\n    // rendering or return a skeleton.\n    //\n    // * Data requests always block.\n    //\n    // * Blocking mode fallback always blocks.\n    //\n    // * Preview mode toggles all pages to be resolved in a blocking manner.\n    //\n    // * Non-dynamic pages should block (though this is an impossible\n    //   case in production).\n    //\n    // * Dynamic pages should return their skeleton if not defined in\n    //   getStaticPaths, then finish the data request on the client-side.\n    //\n\n    if (this.minimalMode !== true && fallbackMode !== 'blocking' && ssgCacheKey && !didRespond && !isPreviewMode && isDynamicPathname && ( // Development should trigger fallback when the path is not in\n    // `getStaticPaths`\n    isProduction || !staticPaths || !staticPaths.includes( // we use ssgCacheKey here as it is normalized to match the\n    // encoding from getStaticPaths along with including the locale\n    query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey))) {\n      if ( // In development, fall through to render to handle missing\n      // getStaticPaths.\n      (isProduction || staticPaths) && // When fallback isn't present, abort this render so we 404\n      fallbackMode !== 'static') {\n        throw new NoFallbackError();\n      }\n\n      if (!isDataReq) {\n        let html; // Production already emitted the fallback as static HTML.\n\n        if (isProduction) {\n          html = await this.incrementalCache.getFallback(locale ? `/${locale}${pathname}` : pathname);\n        } // We need to generate the fallback on-demand for development.\n        else {\n            query.__nextFallback = 'true';\n\n            if (isLikeServerless) {\n              prepareServerlessUrl(req, query);\n            }\n\n            const {\n              value: renderResult\n            } = await doRender();\n            html = renderResult.html;\n          }\n\n        (0, _sendPayload.sendPayload)(req, res, html, 'html', {\n          generateEtags: this.renderOpts.generateEtags,\n          poweredByHeader: this.renderOpts.poweredByHeader\n        });\n        return null;\n      }\n    }\n\n    const {\n      isOrigin,\n      value: {\n        html,\n        pageData,\n        sprRevalidate,\n        isNotFound,\n        isRedirect\n      }\n    } = await doRender();\n    let resHtml = html;\n    const revalidateOptions = !this.renderOpts.dev || isServerProps && !isDataReq ? {\n      private: isPreviewMode,\n      stateful: !isSSG,\n      revalidate: sprRevalidate\n    } : undefined;\n\n    if (!(0, _utils2.isResSent)(res) && !isNotFound && (isSSG || isDataReq || isServerProps)) {\n      if (isRedirect && !isDataReq) {\n        await handleRedirect(pageData);\n      } else {\n        (0, _sendPayload.sendPayload)(req, res, isDataReq ? JSON.stringify(pageData) : html, isDataReq ? 'json' : 'html', {\n          generateEtags: this.renderOpts.generateEtags,\n          poweredByHeader: this.renderOpts.poweredByHeader\n        }, revalidateOptions);\n      }\n\n      resHtml = null;\n    } // Update the cache if the head request and cacheable\n\n\n    if (isOrigin && ssgCacheKey) {\n      await this.incrementalCache.set(ssgCacheKey, {\n        html: html,\n        pageData,\n        isNotFound,\n        isRedirect\n      }, sprRevalidate);\n    }\n\n    if (!(0, _utils2.isResSent)(res) && isNotFound) {\n      if (revalidateOptions) {\n        (0, _sendPayload.setRevalidateHeaders)(res, revalidateOptions);\n      }\n\n      if (isDataReq) {\n        res.statusCode = 404;\n        res.end('{\"notFound\":true}');\n      } else {\n        await this.render404(req, res, {\n          pathname,\n          query\n        });\n      }\n    }\n\n    return resHtml;\n  }\n\n  async renderToHTML(req, res, pathname, query = {}) {\n    try {\n      const result = await this.findPageComponents(pathname, query);\n\n      if (result) {\n        try {\n          return await this.renderToHTMLWithComponents(req, res, pathname, result, { ...this.renderOpts\n          });\n        } catch (err) {\n          if (!(err instanceof NoFallbackError)) {\n            throw err;\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname);\n\n          if (!params) {\n            continue;\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(dynamicRoute.page, query, params);\n\n          if (dynamicRouteResult) {\n            try {\n              return await this.renderToHTMLWithComponents(req, res, dynamicRoute.page, dynamicRouteResult, { ...this.renderOpts,\n                params\n              });\n            } catch (err) {\n              if (!(err instanceof NoFallbackError)) {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      this.logError(err);\n\n      if (err && err.code === 'DECODE_FAILED') {\n        res.statusCode = 400;\n        return await this.renderErrorToHTML(err, req, res, pathname, query);\n      }\n\n      res.statusCode = 500;\n      return await this.renderErrorToHTML(err, req, res, pathname, query);\n    }\n\n    res.statusCode = 404;\n    return await this.renderErrorToHTML(null, req, res, pathname, query);\n  }\n\n  async renderError(err, req, res, pathname, query = {}, setHeaders = true) {\n    if (setHeaders) {\n      res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n    }\n\n    const html = await this.renderErrorToHTML(err, req, res, pathname, query);\n\n    if (html === null) {\n      return;\n    }\n\n    return this.sendHTML(req, res, html);\n  }\n\n  async renderErrorToHTML(err, req, res, _pathname, query = {}) {\n    let result = null;\n    const is404 = res.statusCode === 404;\n    let using404Page = false; // use static 404 page if available and is 404 response\n\n    if (is404) {\n      result = await this.findPageComponents('/404', query);\n      using404Page = result !== null;\n    }\n\n    if (!result) {\n      result = await this.findPageComponents('/_error', query);\n    }\n\n    if (process.env.NODE_ENV !== 'production' && !using404Page && (await this.hasPage('/_error')) && !(await this.hasPage('/404'))) {\n      this.customErrorNo404Warn();\n    }\n\n    let html;\n\n    try {\n      try {\n        html = await this.renderToHTMLWithComponents(req, res, using404Page ? '/404' : '/_error', result, { ...this.renderOpts,\n          err\n        });\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page');\n        }\n\n        throw maybeFallbackError;\n      }\n    } catch (renderToHtmlError) {\n      console.error(renderToHtmlError);\n      res.statusCode = 500;\n      html = 'Internal Server Error';\n    }\n\n    return html;\n  }\n\n  async render404(req, res, parsedUrl, setHeaders = true) {\n    const url = req.url;\n    const {\n      pathname,\n      query\n    } = parsedUrl ? parsedUrl : (0, _url.parse)(url, true);\n    const {\n      i18n\n    } = this.nextConfig;\n\n    if (i18n) {\n      query.__nextLocale = query.__nextLocale || i18n.defaultLocale;\n      query.__nextDefaultLocale = query.__nextDefaultLocale || i18n.defaultLocale;\n    }\n\n    res.statusCode = 404;\n    return this.renderError(null, req, res, pathname, query, setHeaders);\n  }\n\n  async serveStatic(req, res, path, parsedUrl) {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl);\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405;\n      res.setHeader('Allow', ['GET', 'HEAD']);\n      return this.renderError(null, req, res, path);\n    }\n\n    try {\n      await (0, _serveStatic.serveStatic)(req, res, path);\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl);\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412;\n        return this.renderError(err, req, res, path);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  getFilesystemPaths() {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet;\n    }\n\n    const pathUserFilesStatic = (0, _path.join)(this.dir, 'static');\n    let userFilesStatic = [];\n\n    if (this.hasStaticDir && _fs.default.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = (0, _recursiveReaddirSync.recursiveReadDirSync)(pathUserFilesStatic).map(f => (0, _path.join)('.', 'static', f));\n    }\n\n    let userFilesPublic = [];\n\n    if (this.publicDir && _fs.default.existsSync(this.publicDir)) {\n      userFilesPublic = (0, _recursiveReaddirSync.recursiveReadDirSync)(this.publicDir).map(f => (0, _path.join)('.', 'public', f));\n    }\n\n    let nextFilesStatic = [];\n    nextFilesStatic = (0, _recursiveReaddirSync.recursiveReadDirSync)((0, _path.join)(this.distDir, 'static')).map(f => (0, _path.join)('.', (0, _path.relative)(this.dir, this.distDir), 'static', f));\n    return this._validFilesystemPathSet = new Set([...nextFilesStatic, ...userFilesPublic, ...userFilesStatic]);\n  }\n\n  isServeableUrl(untrustedFileUrl) {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n    let decodedUntrustedFilePath;\n\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl);\n    } catch (_unused) {\n      return false;\n    } // (2) Resolve \"up paths\" to determine real request\n\n\n    const untrustedFilePath = (0, _path.resolve)(decodedUntrustedFilePath); // don't allow null bytes anywhere in the file path\n\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false;\n    } // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n\n\n    if ((untrustedFilePath.startsWith((0, _path.join)(this.distDir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path.join)(this.dir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path.join)(this.dir, 'public') + _path.sep)) === false) {\n      return false;\n    } // Check against the real filesystem paths\n\n\n    const filesystemUrls = this.getFilesystemPaths();\n    const resolved = (0, _path.relative)(this.dir, untrustedFilePath);\n    return filesystemUrls.has(resolved);\n  }\n\n  readBuildId() {\n    const buildIdFile = (0, _path.join)(this.distDir, _constants.BUILD_ID_FILE);\n\n    try {\n      return _fs.default.readFileSync(buildIdFile, 'utf8').trim();\n    } catch (err) {\n      if (!_fs.default.existsSync(buildIdFile)) {\n        throw new Error(`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://err.sh/vercel/next.js/production-start-no-build-id`);\n      }\n\n      throw err;\n    }\n  }\n\n  get _isLikeServerless() {\n    return (0, _config.isTargetLikeServerless)(this.nextConfig.target);\n  }\n\n}\n\nexports.default = Server;\n\nfunction prepareServerlessUrl(req, query) {\n  const curUrl = (0, _url.parse)(req.url, true);\n  req.url = (0, _url.format)({ ...curUrl,\n    search: undefined,\n    query: { ...curUrl.query,\n      ...query\n    }\n  });\n}\n\nclass NoFallbackError extends Error {}","map":{"version":3,"sources":["../../../next-server/server/next-server.ts"],"names":["getCustomRouteMatcher","Server","dir","quiet","nextConfig","distDir","pagesDir","publicDir","hasStaticDir","serverBuildDir","pagesManifest","buildId","minimalMode","renderOpts","compression","onErrorMiddleware","incrementalCache","router","dynamicRoutes","customRoutes","constructor","conf","dev","customServer","phase","CLIENT_PUBLIC_FILES_PATH","fs","serverRuntimeConfig","poweredByHeader","canonicalBase","previewProps","ampOptimizerConfig","basePath","images","JSON","optimizeFonts","fontManifest","optimizeImages","optimizeCss","domainLocales","Object","compress","envConfig","SERVERLESS_DIRECTORY","SERVER_DIRECTORY","pagesManifestPath","PAGES_MANIFEST","require","Router","initServer","IncrementalCache","locales","flushToDisk","process","currentPhase","PHASE_PRODUCTION_SERVER","logError","console","req","url","parsedUrl","i18n","pathname","defaultLocale","detectedLocale","acceptPreferredLocale","accept","hostname","host","detectedDomain","localePathResult","localeToCheck","matchedDomain","localeDomainRedirect","domain","denormalizedPagePath","detectedDefaultLocale","shouldStripDefaultLocale","shouldAddLocalePrefix","previous","res","Array","cookie","httpOnly","path","TEMPORARY_REDIRECT_STATUS","reqUrlIsDataUrl","matchedPathIsDataUrl","isDataUrl","parsedPath","matchedPathname","matchedPathnameNoExt","utils","pageIsDynamic","page","rewrites","params","paramsResult","opts","getRequestHandler","setAssetPrefix","prefix","setImmutableAssetCacheControl","getCustomRoutes","ROUTES_MANIFEST","getPrerenderManifest","manifest","PRERENDER_MANIFEST","getPreviewProps","generateRoutes","server","publicRoutes","staticFilesRoute","match","name","fn","p","finished","fsRoutes","type","CLIENT_STATIC_FILES_RUNTIME","CLIENT_STATIC_FILES_PATH","_parsedUrl","_nextDataReq","getCustomRoute","r","headers","headerRoute","source","hasParams","key","value","stringifyQuery","initialQueryValues","encodeURIComponent","val","redirects","redirect","redirectRoute","internal","statusCode","parsedDestination","updatedDestination","rewrite","rewriteRoute","check","target","proxy","Proxy","changeOrigin","ignorePath","err","query","catchAllRoute","handled","pageChecker","found","pageFound","dynamicRoute","builtPagePath","pageModule","prepareServerlessUrl","generatePublicRoutes","publicFiles","encodeURI","pathParts","basePathParts","part","getDynamicRoutes","addedPages","item","Boolean","handleCompression","matched","html","paths","__nextLocale","components","pagePath","amp","__nextDefaultLocale","staticPaths","fallbackField","fallbackMode","is404Page","isLikeServerless","isSSG","isServerProps","hasStaticPaths","isDataReq","locale","isPreviewMode","previewData","urlPathname","resolvedUrlPathname","stripNextDataPath","handleRedirect","pageData","destination","PERMANENT_REDIRECT_STATUS","ssgCacheKey","undefined","seg","decodeURIComponent","cachedData","data","revalidateOptions","private","stateful","revalidate","generateEtags","maybeCoalesceInvoke","isOrigin","doRender","renderResult","sprRevalidate","isNotFound","isRedirect","origQuery","hadTrailingSlash","resolvedUrl","resolvedAsPath","isProduction","isDynamicPathname","didRespond","resHtml","result","dynamicRouteResult","setHeaders","chalk","is404","using404Page","maybeFallbackError","getFilesystemPaths","pathUserFilesStatic","userFilesStatic","f","userFilesPublic","nextFilesStatic","isServeableUrl","decodedUntrustedFilePath","untrustedFilePath","sep","filesystemUrls","resolved","readBuildId","buildIdFile","BUILD_ID_FILE","curUrl","search","Error"],"mappings":"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","sourcesContent":["import compression from 'next/dist/compiled/compression'\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport Proxy from 'next/dist/compiled/http-proxy'\nimport { join, relative, resolve, sep } from 'path'\nimport {\n  parse as parseQs,\n  stringify as stringifyQs,\n  ParsedUrlQuery,\n} from 'querystring'\nimport { format as formatUrl, parse as parseUrl, UrlWithParsedQuery } from 'url'\nimport { PrerenderManifest } from '../../build'\nimport {\n  getRedirectStatus,\n  Header,\n  Redirect,\n  Rewrite,\n  RouteType,\n  CustomRoutes,\n} from '../../lib/load-custom-routes'\nimport { withCoalescedInvoke } from '../../lib/coalesced-function'\nimport {\n  BUILD_ID_FILE,\n  CLIENT_PUBLIC_FILES_PATH,\n  CLIENT_STATIC_FILES_PATH,\n  CLIENT_STATIC_FILES_RUNTIME,\n  PAGES_MANIFEST,\n  PERMANENT_REDIRECT_STATUS,\n  PHASE_PRODUCTION_SERVER,\n  PRERENDER_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVERLESS_DIRECTORY,\n  SERVER_DIRECTORY,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n} from '../lib/router/utils'\nimport * as envConfig from '../lib/runtime-config'\nimport { isResSent, NextApiRequest, NextApiResponse } from '../lib/utils'\nimport {\n  apiResolver,\n  setLazyProp,\n  getCookieParser,\n  tryGetPreviewData,\n  __ApiPreviewProps,\n} from './api-utils'\nimport loadConfig, {\n  DomainLocales,\n  isTargetLikeServerless,\n  NextConfig,\n} from './config'\nimport pathMatch from '../lib/router/utils/path-match'\nimport { recursiveReadDirSync } from './lib/recursive-readdir-sync'\nimport { loadComponents, LoadComponentsReturnType } from './load-components'\nimport { normalizePagePath } from './normalize-page-path'\nimport { RenderOpts, RenderOptsPartial, renderToHTML } from './render'\nimport { getPagePath, requireFontManifest } from './require'\nimport Router, {\n  DynamicRoutes,\n  PageChecker,\n  Params,\n  route,\n  Route,\n} from './router'\nimport prepareDestination, {\n  compileNonPath,\n} from '../lib/router/utils/prepare-destination'\nimport { sendPayload, setRevalidateHeaders } from './send-payload'\nimport { serveStatic } from './serve-static'\nimport { IncrementalCache } from './incremental-cache'\nimport { execOnce } from '../lib/utils'\nimport { isBlockedPage } from './utils'\nimport { loadEnvConfig } from '@next/env'\nimport './node-polyfill-fetch'\nimport { PagesManifest } from '../../build/webpack/plugins/pages-manifest-plugin'\nimport { removePathTrailingSlash } from '../../client/normalize-trailing-slash'\nimport getRouteFromAssetPath from '../lib/router/utils/get-route-from-asset-path'\nimport { FontManifest } from './font-utils'\nimport { denormalizePagePath } from './denormalize-page-path'\nimport accept from '@hapi/accept'\nimport { normalizeLocalePath } from '../lib/i18n/normalize-locale-path'\nimport { detectLocaleCookie } from '../lib/i18n/detect-locale-cookie'\nimport * as Log from '../../build/output/log'\nimport { imageOptimizer } from './image-optimizer'\nimport { detectDomainLocale } from '../lib/i18n/detect-domain-locale'\nimport cookie from 'next/dist/compiled/cookie'\nimport escapePathDelimiters from '../lib/router/utils/escape-path-delimiters'\nimport { getUtils } from '../../build/webpack/loaders/next-serverless-loader/utils'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\ntype Middleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: Error) => void\n) => void\n\ntype FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: ParsedUrlQuery\n}\n\ntype DynamicRouteItem = {\n  page: string\n  match: ReturnType<typeof getRouteMatcher>\n}\n\nexport type ServerConstructor = {\n  /**\n   * Where the Next project is located - @default '.'\n   */\n  dir?: string\n  /**\n   * Hide error messages containing server information - @default false\n   */\n  quiet?: boolean\n  /**\n   * Object what you would use in next.config.js - @default {}\n   */\n  conf?: NextConfig | null\n  dev?: boolean\n  customServer?: boolean\n}\n\nexport default class Server {\n  dir: string\n  quiet: boolean\n  nextConfig: NextConfig\n  distDir: string\n  pagesDir?: string\n  publicDir: string\n  hasStaticDir: boolean\n  serverBuildDir: string\n  pagesManifest?: PagesManifest\n  buildId: string\n  minimalMode: boolean\n  renderOpts: {\n    poweredByHeader: boolean\n    buildId: string\n    generateEtags: boolean\n    runtimeConfig?: { [key: string]: any }\n    assetPrefix?: string\n    canonicalBase: string\n    dev?: boolean\n    previewProps: __ApiPreviewProps\n    customServer?: boolean\n    ampOptimizerConfig?: { [key: string]: any }\n    basePath: string\n    optimizeFonts: boolean\n    images: string\n    fontManifest: FontManifest\n    optimizeImages: boolean\n    optimizeCss: any\n    locale?: string\n    locales?: string[]\n    defaultLocale?: string\n    domainLocales?: DomainLocales\n  }\n  private compression?: Middleware\n  private onErrorMiddleware?: ({ err }: { err: Error }) => Promise<void>\n  private incrementalCache: IncrementalCache\n  router: Router\n  protected dynamicRoutes?: DynamicRoutes\n  protected customRoutes: CustomRoutes\n\n  public constructor({\n    dir = '.',\n    quiet = false,\n    conf = null,\n    dev = false,\n    minimalMode = false,\n    customServer = true,\n  }: ServerConstructor & { minimalMode?: boolean } = {}) {\n    this.dir = resolve(dir)\n    this.quiet = quiet\n    const phase = this.currentPhase()\n    loadEnvConfig(this.dir, dev, Log)\n\n    this.nextConfig = loadConfig(phase, this.dir, conf)\n    this.distDir = join(this.dir, this.nextConfig.distDir)\n    this.publicDir = join(this.dir, CLIENT_PUBLIC_FILES_PATH)\n    this.hasStaticDir = fs.existsSync(join(this.dir, 'static'))\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress,\n    } = this.nextConfig\n\n    this.buildId = this.readBuildId()\n    this.minimalMode = minimalMode\n\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase,\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: this.nextConfig.experimental.optimizeFonts && !dev,\n      fontManifest:\n        this.nextConfig.experimental.optimizeFonts && !dev\n          ? requireFontManifest(this.distDir, this._isLikeServerless)\n          : null,\n      optimizeImages: this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      domainLocales: this.nextConfig.i18n?.domains,\n    }\n\n    // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = compression() as Middleware\n    }\n\n    // Initialize next/config with the environment configuration\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.serverBuildDir = join(\n      this.distDir,\n      this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY\n    )\n    const pagesManifestPath = join(this.serverBuildDir, PAGES_MANIFEST)\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath)\n    }\n\n    this.customRoutes = this.getCustomRoutes()\n    this.router = new Router(this.generateRoutes())\n    this.setAssetPrefix(assetPrefix)\n\n    // call init-server middleware, this is also handled\n    // individually in serverless bundles when deployed\n    if (!dev && this.nextConfig.experimental.plugins) {\n      const initServer = require(join(this.serverBuildDir, 'init-server.js'))\n        .default\n      this.onErrorMiddleware = require(join(\n        this.serverBuildDir,\n        'on-error-server.js'\n      )).default\n      initServer()\n    }\n\n    this.incrementalCache = new IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: join(\n        this.distDir,\n        this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY,\n        'pages'\n      ),\n      locales: this.nextConfig.i18n?.locales,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.sprFlushToDisk,\n    })\n\n    /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targetting both serverless and SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n     * TODO(atcastle@): Remove this when experimental.optimizeImages are being clened up.\n     */\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)\n    }\n  }\n\n  protected currentPhase(): string {\n    return PHASE_PRODUCTION_SERVER\n  }\n\n  public logError(err: Error): void {\n    if (this.onErrorMiddleware) {\n      this.onErrorMiddleware({ err })\n    }\n    if (this.quiet) return\n    console.error(err)\n  }\n\n  private async handleRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    setLazyProp({ req: req as any }, 'cookies', getCookieParser(req))\n\n    // Parse url if parsedUrl not provided\n    if (!parsedUrl || typeof parsedUrl !== 'object') {\n      const url: any = req.url\n      parsedUrl = parseUrl(url, true)\n    }\n\n    // Parse the querystring ourselves if the user doesn't handle querystring parsing\n    if (typeof parsedUrl.query === 'string') {\n      parsedUrl.query = parseQs(parsedUrl.query)\n    }\n    ;(req as any).__NEXT_INIT_QUERY = Object.assign({}, parsedUrl.query)\n\n    const { basePath, i18n } = this.nextConfig\n\n    if (basePath && req.url?.startsWith(basePath)) {\n      // store original URL to allow checking if basePath was\n      // provided or not\n      ;(req as any)._nextHadBasePath = true\n      req.url = req.url!.replace(basePath, '') || '/'\n    }\n\n    if (i18n && !req.url?.startsWith('/_next')) {\n      // get pathname from URL with basePath stripped for locale detection\n      let { pathname, ...parsed } = parseUrl(req.url || '/')\n      pathname = pathname || '/'\n\n      let defaultLocale = i18n.defaultLocale\n      let detectedLocale = detectLocaleCookie(req, i18n.locales)\n      let acceptPreferredLocale =\n        i18n.localeDetection !== false\n          ? accept.language(req.headers['accept-language'], i18n.locales)\n          : detectedLocale\n\n      const { host } = req?.headers || {}\n      // remove port from host and remove port if present\n      const hostname = host?.split(':')[0].toLowerCase()\n\n      const detectedDomain = detectDomainLocale(i18n.domains, hostname)\n      if (detectedDomain) {\n        defaultLocale = detectedDomain.defaultLocale\n        detectedLocale = defaultLocale\n      }\n\n      // if not domain specific locale use accept-language preferred\n      detectedLocale = detectedLocale || acceptPreferredLocale\n\n      let localeDomainRedirect: string | undefined\n      ;(req as any).__nextHadTrailingSlash = pathname!.endsWith('/')\n\n      if (pathname === '/') {\n        ;(req as any).__nextHadTrailingSlash = this.nextConfig.trailingSlash\n      }\n      const localePathResult = normalizeLocalePath(pathname!, i18n.locales)\n\n      if (localePathResult.detectedLocale) {\n        detectedLocale = localePathResult.detectedLocale\n        req.url = formatUrl({\n          ...parsed,\n          pathname: localePathResult.pathname,\n        })\n        ;(req as any).__nextStrippedLocale = true\n      }\n\n      // If a detected locale is a domain specific locale and we aren't already\n      // on that domain and path prefix redirect to it to prevent duplicate\n      // content from multiple domains\n      if (detectedDomain && pathname === '/') {\n        const localeToCheck = acceptPreferredLocale\n        // const localeToCheck = localePathResult.detectedLocale\n        //   ? detectedLocale\n        //   : acceptPreferredLocale\n\n        const matchedDomain = detectDomainLocale(\n          i18n.domains,\n          undefined,\n          localeToCheck\n        )\n\n        if (\n          matchedDomain &&\n          (matchedDomain.domain !== detectedDomain.domain ||\n            localeToCheck !== matchedDomain.defaultLocale)\n        ) {\n          localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${\n            matchedDomain.domain\n          }/${\n            localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck\n          }`\n        }\n      }\n\n      const denormalizedPagePath = denormalizePagePath(pathname || '/')\n      const detectedDefaultLocale =\n        !detectedLocale ||\n        detectedLocale.toLowerCase() === defaultLocale.toLowerCase()\n      const shouldStripDefaultLocale = false\n      // detectedDefaultLocale &&\n      // denormalizedPagePath.toLowerCase() ===\n      //   `/${i18n.defaultLocale.toLowerCase()}`\n\n      const shouldAddLocalePrefix =\n        !detectedDefaultLocale && denormalizedPagePath === '/'\n\n      detectedLocale = detectedLocale || i18n.defaultLocale\n\n      if (\n        i18n.localeDetection !== false &&\n        (localeDomainRedirect ||\n          shouldAddLocalePrefix ||\n          shouldStripDefaultLocale)\n      ) {\n        // set the NEXT_LOCALE cookie when a user visits the default locale\n        // with the locale prefix so that they aren't redirected back to\n        // their accept-language preferred locale\n        if (\n          shouldStripDefaultLocale &&\n          acceptPreferredLocale !== defaultLocale\n        ) {\n          const previous = res.getHeader('set-cookie')\n\n          res.setHeader('set-cookie', [\n            ...(typeof previous === 'string'\n              ? [previous]\n              : Array.isArray(previous)\n              ? previous\n              : []),\n            cookie.serialize('NEXT_LOCALE', defaultLocale, {\n              httpOnly: true,\n              path: '/',\n            }),\n          ])\n        }\n\n        res.setHeader(\n          'Location',\n          localeDomainRedirect\n            ? localeDomainRedirect\n            : formatUrl({\n                // make sure to include any query values when redirecting\n                ...parsed,\n                pathname: shouldStripDefaultLocale\n                  ? basePath || `/`\n                  : `${basePath || ''}/${detectedLocale}`,\n              })\n        )\n        res.statusCode = TEMPORARY_REDIRECT_STATUS\n        res.end()\n        return\n      }\n\n      parsedUrl.query.__nextDefaultLocale =\n        detectedDomain?.defaultLocale || i18n.defaultLocale\n\n      parsedUrl.query.__nextLocale =\n        localePathResult.detectedLocale ||\n        detectedDomain?.defaultLocale ||\n        defaultLocale\n    }\n\n    if (\n      this.minimalMode &&\n      req.headers['x-matched-path'] &&\n      typeof req.headers['x-matched-path'] === 'string'\n    ) {\n      const reqUrlIsDataUrl = req.url?.includes('/_next/data')\n      const matchedPathIsDataUrl = req.headers['x-matched-path']?.includes(\n        '/_next/data'\n      )\n      const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl\n\n      let parsedPath = parseUrl(\n        isDataUrl ? req.url! : (req.headers['x-matched-path'] as string),\n        true\n      )\n      const { pathname, query } = parsedPath\n      let matchedPathname = pathname as string\n\n      const matchedPathnameNoExt = isDataUrl\n        ? matchedPathname.replace(/\\.json$/, '')\n        : matchedPathname\n\n      // interpolate dynamic params and normalize URL if needed\n      if (isDynamicRoute(matchedPathnameNoExt)) {\n        const utils = getUtils({\n          pageIsDynamic: true,\n          page: matchedPathnameNoExt,\n          i18n: this.nextConfig.i18n,\n          basePath: this.nextConfig.basePath,\n          rewrites: this.customRoutes.rewrites,\n        })\n\n        let params: ParsedUrlQuery | false = {}\n        const paramsResult = utils.normalizeDynamicRouteParams({\n          ...parsedUrl.query,\n          ...query,\n        })\n\n        if (paramsResult.hasValidParams) {\n          params = paramsResult.params\n        } else if (req.headers['x-now-route-matches']) {\n          const opts: Record<string, string> = {}\n          params = utils.getParamsFromRouteMatches(\n            req,\n            opts,\n            (parsedUrl.query.__nextLocale as string | undefined) || ''\n          )\n\n          if (opts.locale) {\n            parsedUrl.query.__nextLocale = opts.locale\n          }\n        } else {\n          params = utils.dynamicRouteMatcher!(matchedPathname)\n        }\n\n        if (params) {\n          matchedPathname = utils.interpolateDynamicPath(\n            matchedPathname,\n            params\n          )\n\n          req.url = utils.interpolateDynamicPath(req.url!, params)\n        }\n\n        if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n          req.url = formatUrl({\n            ...parsedPath,\n            pathname: matchedPathname,\n          })\n        }\n        Object.assign(parsedUrl.query, params)\n        utils.normalizeVercelUrl(req, true)\n      }\n      parsedUrl.pathname = `${basePath || ''}${\n        parsedUrl.query.__nextLocale || ''\n      }${matchedPathname}`\n    }\n\n    res.statusCode = 200\n    try {\n      return await this.run(req, res, parsedUrl)\n    } catch (err) {\n      this.logError(err)\n      res.statusCode = 500\n      res.end('Internal Server Error')\n    }\n  }\n\n  public getRequestHandler() {\n    return this.handleRequest.bind(this)\n  }\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  // Backwards compatibility\n  public async prepare(): Promise<void> {}\n\n  // Backwards compatibility\n  protected async close(): Promise<void> {}\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')\n  }\n\n  protected getCustomRoutes(): CustomRoutes {\n    return require(join(this.distDir, ROUTES_MANIFEST))\n  }\n\n  private _cachedPreviewManifest: PrerenderManifest | undefined\n  protected getPrerenderManifest(): PrerenderManifest {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest\n    }\n    const manifest = require(join(this.distDir, PRERENDER_MANIFEST))\n    return (this._cachedPreviewManifest = manifest)\n  }\n\n  protected getPreviewProps(): __ApiPreviewProps {\n    return this.getPrerenderManifest().preview\n  }\n\n  protected generateRoutes(): {\n    basePath: string\n    headers: Route[]\n    rewrites: Route[]\n    fsRoutes: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    dynamicRoutes: DynamicRoutes | undefined\n    locales: string[]\n  } {\n    const server: Server = this\n    const publicRoutes = fs.existsSync(this.publicDir)\n      ? this.generatePublicRoutes()\n      : []\n\n    const staticFilesRoute = this.hasStaticDir\n      ? [\n          {\n            // It's very important to keep this route's param optional.\n            // (but it should support as many params as needed, separated by '/')\n            // Otherwise this will lead to a pretty simple DOS attack.\n            // See more: https://github.com/vercel/next.js/issues/2617\n            match: route('/static/:path*'),\n            name: 'static catchall',\n            fn: async (req, res, params, parsedUrl) => {\n              const p = join(this.dir, 'static', ...params.path)\n              await this.serveStatic(req, res, p, parsedUrl)\n              return {\n                finished: true,\n              }\n            },\n          } as Route,\n        ]\n      : []\n\n    const fsRoutes: Route[] = [\n      {\n        match: route('/_next/static/:path*'),\n        type: 'route',\n        name: '_next/static catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          // make sure to 404 for /_next/static itself\n          if (!params.path) {\n            await this.render404(req, res, parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          if (\n            params.path[0] === CLIENT_STATIC_FILES_RUNTIME ||\n            params.path[0] === 'chunks' ||\n            params.path[0] === 'css' ||\n            params.path[0] === 'media' ||\n            params.path[0] === this.buildId ||\n            params.path[0] === 'pages' ||\n            params.path[1] === 'pages'\n          ) {\n            this.setImmutableAssetCacheControl(res)\n          }\n          const p = join(\n            this.distDir,\n            CLIENT_STATIC_FILES_PATH,\n            ...(params.path || [])\n          )\n          await this.serveStatic(req, res, p, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/data/:path*'),\n        type: 'route',\n        name: '_next/data catchall',\n        fn: async (req, res, params, _parsedUrl) => {\n          // Make sure to 404 for /_next/data/ itself and\n          // we also want to 404 if the buildId isn't correct\n          if (!params.path || params.path[0] !== this.buildId) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n          // remove buildId from URL\n          params.path.shift()\n\n          // show 404 if it doesn't end with .json\n          if (!params.path[params.path.length - 1].endsWith('.json')) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          // re-create page's pathname\n          let pathname = `/${params.path.join('/')}`\n          pathname = getRouteFromAssetPath(pathname, '.json')\n\n          const { i18n } = this.nextConfig\n\n          if (i18n) {\n            const { host } = req?.headers || {}\n            // remove port from host and remove port if present\n            const hostname = host?.split(':')[0].toLowerCase()\n            const localePathResult = normalizeLocalePath(pathname, i18n.locales)\n            const { defaultLocale } =\n              detectDomainLocale(i18n.domains, hostname) || {}\n\n            let detectedLocale = ''\n\n            if (localePathResult.detectedLocale) {\n              pathname = localePathResult.pathname\n              detectedLocale = localePathResult.detectedLocale\n            }\n\n            _parsedUrl.query.__nextLocale = detectedLocale!\n            _parsedUrl.query.__nextDefaultLocale =\n              defaultLocale || i18n.defaultLocale\n\n            if (!detectedLocale) {\n              _parsedUrl.query.__nextLocale =\n                _parsedUrl.query.__nextDefaultLocale\n              await this.render404(req, res, _parsedUrl)\n              return { finished: true }\n            }\n          }\n\n          const parsedUrl = parseUrl(pathname, true)\n\n          await this.render(\n            req,\n            res,\n            pathname,\n            { ..._parsedUrl.query, _nextDataReq: '1' },\n            parsedUrl\n          )\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/image'),\n        type: 'route',\n        name: '_next/image catchall',\n        fn: (req, res, _params, parsedUrl) =>\n          imageOptimizer(server, req, res, parsedUrl),\n      },\n      {\n        match: route('/_next/:path*'),\n        type: 'route',\n        name: '_next catchall',\n        // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n        fn: async (req, res, _params, parsedUrl) => {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      ...publicRoutes,\n      ...staticFilesRoute,\n    ]\n\n    const getCustomRoute = (\n      r: Rewrite | Redirect | Header,\n      type: RouteType\n    ) => {\n      const match = getCustomRouteMatcher(r.source)\n\n      return {\n        ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({ finished: false }),\n      } as Route & Rewrite & Header\n    }\n\n    // Headers come very first\n    const headers = this.customRoutes.headers.map((r) => {\n      const headerRoute = getCustomRoute(r, 'header')\n      return {\n        match: headerRoute.match,\n        type: headerRoute.type,\n        name: `${headerRoute.type} ${headerRoute.source} header route`,\n        fn: async (_req, res, params, _parsedUrl) => {\n          const hasParams = Object.keys(params).length > 0\n\n          for (const header of (headerRoute as Header).headers) {\n            let { key, value } = header\n            if (hasParams) {\n              key = compileNonPath(key, params)\n              value = compileNonPath(value, params)\n            }\n            res.setHeader(key, value)\n          }\n          return { finished: false }\n        },\n      } as Route\n    })\n\n    // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n    const stringifyQuery = (req: IncomingMessage, query: ParsedUrlQuery) => {\n      const initialQueryValues = Object.values((req as any).__NEXT_INIT_QUERY)\n\n      return stringifyQs(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some((val) => val === value)) {\n            return encodeURIComponent(value)\n          }\n          return value\n        },\n      })\n    }\n\n    const redirects = this.minimalMode\n      ? []\n      : this.customRoutes.redirects.map((redirect) => {\n          const redirectRoute = getCustomRoute(redirect, 'redirect')\n          return {\n            internal: redirectRoute.internal,\n            type: redirectRoute.type,\n            match: redirectRoute.match,\n            statusCode: redirectRoute.statusCode,\n            name: `Redirect route ${redirectRoute.source}`,\n            fn: async (req, res, params, parsedUrl) => {\n              const { parsedDestination } = prepareDestination(\n                redirectRoute.destination,\n                params,\n                parsedUrl.query,\n                false\n              )\n\n              const { query } = parsedDestination\n              delete (parsedDestination as any).query\n\n              parsedDestination.search = stringifyQuery(req, query)\n\n              const updatedDestination = formatUrl(parsedDestination)\n\n              res.setHeader('Location', updatedDestination)\n              res.statusCode = getRedirectStatus(redirectRoute as Redirect)\n\n              // Since IE11 doesn't support the 308 header add backwards\n              // compatibility using refresh header\n              if (res.statusCode === 308) {\n                res.setHeader('Refresh', `0;url=${updatedDestination}`)\n              }\n\n              res.end()\n              return {\n                finished: true,\n              }\n            },\n          } as Route\n        })\n\n    const rewrites = this.customRoutes.rewrites.map((rewrite) => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite')\n      return {\n        ...rewriteRoute,\n        check: true,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const { newUrl, parsedDestination } = prepareDestination(\n            rewriteRoute.destination,\n            params,\n            parsedUrl.query,\n            true\n          )\n\n          // external rewrite, proxy it\n          if (parsedDestination.protocol) {\n            const { query } = parsedDestination\n            delete (parsedDestination as any).query\n            parsedDestination.search = stringifyQuery(req, query)\n\n            const target = formatUrl(parsedDestination)\n            const proxy = new Proxy({\n              target,\n              changeOrigin: true,\n              ignorePath: true,\n            })\n            proxy.web(req, res)\n\n            proxy.on('error', (err: Error) => {\n              console.error(`Error occurred proxying ${target}`, err)\n            })\n            return {\n              finished: true,\n            }\n          }\n          ;(req as any)._nextRewroteUrl = newUrl\n          ;(req as any)._nextDidRewrite =\n            (req as any)._nextRewroteUrl !== req.url\n\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query,\n          }\n        },\n      } as Route\n    })\n\n    const catchAllRoute: Route = {\n      match: route('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let { pathname, query } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // next.js core assumes page path without trailing slash\n        pathname = removePathTrailingSlash(pathname)\n\n        if (this.nextConfig.i18n) {\n          const localePathResult = normalizeLocalePath(\n            pathname,\n            this.nextConfig.i18n?.locales\n          )\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n          }\n        }\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          const handled = await this.handleApiRequest(\n            req as NextApiRequest,\n            res as NextApiResponse,\n            pathname,\n            query\n          )\n          if (handled) {\n            return { finished: true }\n          }\n        }\n\n        await this.render(req, res, pathname, query, parsedUrl)\n        return {\n          finished: true,\n        }\n      },\n    }\n\n    const { useFileSystemPublicRoutes } = this.nextConfig\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes()\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites,\n      redirects,\n      catchAllRoute,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: this.nextConfig.i18n?.locales || [],\n    }\n  }\n\n  private async getPagePath(pathname: string): Promise<string> {\n    return getPagePath(\n      pathname,\n      this.distDir,\n      this._isLikeServerless,\n      this.renderOpts.dev\n    )\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let found = false\n    try {\n      found = !!(await this.getPagePath(pathname))\n    } catch (_) {}\n\n    return found\n  }\n\n  protected async _beforeCatchAllRender(\n    _req: IncomingMessage,\n    _res: ServerResponse,\n    _params: Params,\n    _parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    return false\n  }\n\n  // Used to build API page in development\n  protected async ensureApiPage(_pathname: string): Promise<void> {}\n\n  /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */\n  private async handleApiRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery\n  ): Promise<boolean> {\n    let page = pathname\n    let params: Params | boolean = false\n    let pageFound = await this.hasPage(page)\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname)\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page\n          pageFound = true\n          break\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false\n    }\n    // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n    await this.ensureApiPage(page)\n\n    let builtPagePath\n    try {\n      builtPagePath = await this.getPagePath(page)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false\n      }\n      throw err\n    }\n\n    const pageModule = await require(builtPagePath)\n    query = { ...query, ...params }\n\n    delete query.__nextLocale\n    delete query.__nextDefaultLocale\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query)\n        await pageModule.default(req, res)\n        return true\n      }\n    }\n\n    await apiResolver(\n      req,\n      res,\n      query,\n      pageModule,\n      this.renderOpts.previewProps,\n      false,\n      this.onErrorMiddleware\n    )\n    return true\n  }\n\n  protected generatePublicRoutes(): Route[] {\n    const publicFiles = new Set(\n      recursiveReadDirSync(this.publicDir).map((p) =>\n        encodeURI(p.replace(/\\\\/g, '/'))\n      )\n    )\n\n    return [\n      {\n        match: route('/:path*'),\n        name: 'public folder catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          const pathParts: string[] = params.path || []\n          const { basePath } = this.nextConfig\n\n          // if basePath is defined require it be present\n          if (basePath) {\n            const basePathParts = basePath.split('/')\n            // remove first empty value\n            basePathParts.shift()\n\n            if (\n              !basePathParts.every((part: string, idx: number) => {\n                return part === pathParts[idx]\n              })\n            ) {\n              return { finished: false }\n            }\n\n            pathParts.splice(0, basePathParts.length)\n          }\n\n          const path = `/${pathParts.join('/')}`\n\n          if (publicFiles.has(path)) {\n            await this.serveStatic(\n              req,\n              res,\n              join(this.publicDir, ...pathParts),\n              parsedUrl\n            )\n            return {\n              finished: true,\n            }\n          }\n          return {\n            finished: false,\n          }\n        },\n      } as Route,\n    ]\n  }\n\n  protected getDynamicRoutes(): Array<DynamicRouteItem> {\n    const addedPages = new Set<string>()\n\n    return getSortedRoutes(\n      Object.keys(this.pagesManifest!).map(\n        (page) =>\n          normalizeLocalePath(page, this.nextConfig.i18n?.locales).pathname\n      )\n    )\n      .map((page) => {\n        if (addedPages.has(page) || !isDynamicRoute(page)) return null\n        addedPages.add(page)\n        return {\n          page,\n          match: getRouteMatcher(getRouteRegex(page)),\n        }\n      })\n      .filter((item): item is DynamicRouteItem => Boolean(item))\n  }\n\n  private handleCompression(req: IncomingMessage, res: ServerResponse): void {\n    if (this.compression) {\n      this.compression(req, res, () => {})\n    }\n  }\n\n  protected async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    this.handleCompression(req, res)\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl)\n      if (matched) {\n        return\n      }\n    } catch (err) {\n      if (err.code === 'DECODE_FAILED') {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n      throw err\n    }\n\n    await this.render404(req, res, parsedUrl)\n  }\n\n  protected async sendHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    html: string\n  ): Promise<void> {\n    const { generateEtags, poweredByHeader } = this.renderOpts\n    return sendPayload(req, res, html, 'html', {\n      generateEtags,\n      poweredByHeader,\n    })\n  }\n\n  public async render(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://err.sh/next.js/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.renderOpts.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    const url: any = req.url\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !query._nextDataReq &&\n      (url.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && url.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    const html = await this.renderToHTML(req, res, pathname, query)\n    // Request was ended by the user\n    if (html === null) {\n      return\n    }\n\n    return this.sendHTML(req, res, html)\n  }\n\n  private async findPageComponents(\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    params: Params | null = null\n  ): Promise<FindComponentsResult | null> {\n    let paths = [\n      // try serving a static AMP version first\n      query.amp ? normalizePagePath(pathname) + '.amp' : null,\n      pathname,\n    ].filter(Boolean)\n\n    if (query.__nextLocale) {\n      paths = [\n        ...paths.map(\n          (path) => `/${query.__nextLocale}${path === '/' ? '' : path}`\n        ),\n        ...paths,\n      ]\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await loadComponents(\n          this.distDir,\n          pagePath!,\n          !this.renderOpts.dev && this._isLikeServerless\n        )\n        // if loading an static HTML file the locale is required\n        // to be present since all HTML files are output under their locale\n        if (\n          query.__nextLocale &&\n          typeof components.Component === 'string' &&\n          !pagePath?.startsWith(`/${query.__nextLocale}`)\n        ) {\n          const err = new Error('NOT_FOUND')\n          ;(err as any).code = 'ENOENT'\n          throw err\n        }\n\n        return {\n          components,\n          query: {\n            ...(components.getStaticProps\n              ? {\n                  amp: query.amp,\n                  _nextDataReq: query._nextDataReq,\n                  __nextLocale: query.__nextLocale,\n                  __nextDefaultLocale: query.__nextDefaultLocale,\n                }\n              : query),\n            ...(params || {}),\n          },\n        }\n      } catch (err) {\n        if (err.code !== 'ENOENT') throw err\n      }\n    }\n    return null\n  }\n\n  protected async getStaticPaths(\n    pathname: string\n  ): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: 'static' | 'blocking' | false\n  }> {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined\n\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField = this.getPrerenderManifest().dynamicRoutes[pathname]\n      .fallback\n\n    return {\n      staticPaths,\n      fallbackMode:\n        typeof fallbackField === 'string'\n          ? 'static'\n          : fallbackField === null\n          ? 'blocking'\n          : false,\n    }\n  }\n\n  private async renderToHTMLWithComponents(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    { components, query }: FindComponentsResult,\n    opts: RenderOptsPartial\n  ): Promise<string | null> {\n    const is404Page = pathname === '/404'\n\n    const isLikeServerless =\n      typeof components.Component === 'object' &&\n      typeof (components.Component as any).renderReqToHTML === 'function'\n    const isSSG = !!components.getStaticProps\n    const isServerProps = !!components.getServerSideProps\n    const hasStaticPaths = !!components.getStaticPaths\n\n    // Toggle whether or not this is a Data request\n    const isDataReq = !!query._nextDataReq && (isSSG || isServerProps)\n    delete query._nextDataReq\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return components.Component\n    }\n\n    if (!query.amp) {\n      delete query.amp\n    }\n\n    const locale = query.__nextLocale as string\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : (query.__nextDefaultLocale as string)\n\n    const { i18n } = this.nextConfig\n    const locales = i18n?.locales\n\n    let previewData: string | false | object | undefined\n    let isPreviewMode = false\n\n    if (isServerProps || isSSG) {\n      previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps)\n      isPreviewMode = previewData !== false\n    }\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname = (req as any)._nextRewroteUrl\n      ? (req as any)._nextRewroteUrl\n      : urlPathname\n\n    urlPathname = removePathTrailingSlash(urlPathname)\n    resolvedUrlPathname = normalizeLocalePath(\n      removePathTrailingSlash(resolvedUrlPathname),\n      this.nextConfig.i18n?.locales\n    ).pathname\n\n    const stripNextDataPath = (path: string) => {\n      if (path.includes(this.buildId)) {\n        path = denormalizePagePath(\n          (path.split(this.buildId).pop() || '/').replace(/\\.json$/, '')\n        )\n      }\n\n      if (this.nextConfig.i18n) {\n        return normalizeLocalePath(path, locales).pathname\n      }\n      return path\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (basePath && redirect.basePath !== false) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (statusCode === PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`)\n      }\n\n      res.statusCode = statusCode\n      res.setHeader('Location', redirect.destination)\n      res.end()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname)\n      urlPathname = stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey =\n      isPreviewMode || !isSSG || this.minimalMode\n        ? undefined // Preview mode bypasses the cache\n        : `${locale ? `/${locale}` : ''}${\n            (pathname === '/' || resolvedUrlPathname === '/') && locale\n              ? ''\n              : resolvedUrlPathname\n          }${query.amp ? '.amp' : ''}`\n\n    if (is404Page && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey\n        .split('/')\n        .map((seg) => {\n          try {\n            seg = escapePathDelimiters(decodeURIComponent(seg), true)\n          } catch (_) {\n            // An improperly encoded URL was provided, this is considered\n            // a bad request (400)\n            const err: Error & { code?: string } = new Error(\n              'failed to decode param'\n            )\n            err.code = 'DECODE_FAILED'\n            throw err\n          }\n          return seg\n        })\n        .join('/')\n    }\n\n    // Complete the response with cached data if its present\n    const cachedData = ssgCacheKey\n      ? await this.incrementalCache.get(ssgCacheKey)\n      : undefined\n\n    if (cachedData) {\n      const data = isDataReq\n        ? JSON.stringify(cachedData.pageData)\n        : cachedData.html\n\n      const revalidateOptions = !this.renderOpts.dev\n        ? {\n            private: isPreviewMode,\n            stateful: false, // GSP response\n            revalidate:\n              cachedData.curRevalidate !== undefined\n                ? cachedData.curRevalidate\n                : /* default to minimum revalidate (this should be an invariant) */ 1,\n          }\n        : undefined\n\n      if (!isDataReq && cachedData.pageData?.pageProps?.__N_REDIRECT) {\n        await handleRedirect(cachedData.pageData)\n      } else if (cachedData.isNotFound) {\n        if (revalidateOptions) {\n          setRevalidateHeaders(res, revalidateOptions)\n        }\n        if (isDataReq) {\n          res.statusCode = 404\n          res.end('{\"notFound\":true}')\n        } else {\n          await this.render404(req, res, {\n            pathname,\n            query,\n          } as UrlWithParsedQuery)\n        }\n      } else {\n        sendPayload(\n          req,\n          res,\n          data,\n          isDataReq ? 'json' : 'html',\n          {\n            generateEtags: this.renderOpts.generateEtags,\n            poweredByHeader: this.renderOpts.poweredByHeader,\n          },\n          revalidateOptions\n        )\n      }\n\n      // Stop the request chain here if the data we sent was up-to-date\n      if (!cachedData.isStale) {\n        return null\n      }\n    }\n\n    // If we're here, that means data is missing or it's stale.\n    const maybeCoalesceInvoke = ssgCacheKey\n      ? (fn: any) => withCoalescedInvoke(fn).bind(null, ssgCacheKey!, [])\n      : (fn: any) => async () => {\n          const value = await fn()\n          return { isOrigin: true, value }\n        }\n\n    const doRender = maybeCoalesceInvoke(\n      async (): Promise<{\n        html: string | null\n        pageData: any\n        sprRevalidate: number | false\n        isNotFound?: boolean\n        isRedirect?: boolean\n      }> => {\n        let pageData: any\n        let html: string | null\n        let sprRevalidate: number | false\n        let isNotFound: boolean | undefined\n        let isRedirect: boolean | undefined\n\n        let renderResult\n        // handle serverless\n        if (isLikeServerless) {\n          renderResult = await (components.Component as any).renderReqToHTML(\n            req,\n            res,\n            'passthrough',\n            {\n              locale,\n              locales,\n              defaultLocale,\n              fontManifest: this.renderOpts.fontManifest,\n              domainLocales: this.renderOpts.domainLocales,\n            }\n          )\n\n          html = renderResult.html\n          pageData = renderResult.renderOpts.pageData\n          sprRevalidate = renderResult.renderOpts.revalidate\n          isNotFound = renderResult.renderOpts.isNotFound\n          isRedirect = renderResult.renderOpts.isRedirect\n        } else {\n          const origQuery = parseUrl(req.url || '', true).query\n          const hadTrailingSlash =\n            urlPathname !== '/' && this.nextConfig.trailingSlash\n\n          const resolvedUrl = formatUrl({\n            pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n            // make sure to only add query values from original URL\n            query: origQuery,\n          })\n\n          const renderOpts: RenderOpts = {\n            ...components,\n            ...opts,\n            isDataReq,\n            resolvedUrl,\n            locale,\n            locales,\n            defaultLocale,\n            // For getServerSideProps we need to ensure we use the original URL\n            // and not the resolved URL to prevent a hydration mismatch on\n            // asPath\n            resolvedAsPath: isServerProps\n              ? formatUrl({\n                  // we use the original URL pathname less the _next/data prefix if\n                  // present\n                  pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                  query: origQuery,\n                })\n              : resolvedUrl,\n          }\n\n          renderResult = await renderToHTML(\n            req,\n            res,\n            pathname,\n            query,\n            renderOpts\n          )\n\n          html = renderResult\n          // TODO: change this to a different passing mechanism\n          pageData = (renderOpts as any).pageData\n          sprRevalidate = (renderOpts as any).revalidate\n          isNotFound = (renderOpts as any).isNotFound\n          isRedirect = (renderOpts as any).isRedirect\n        }\n\n        return { html, pageData, sprRevalidate, isNotFound, isRedirect }\n      }\n    )\n\n    const isProduction = !this.renderOpts.dev\n    const isDynamicPathname = isDynamicRoute(pathname)\n    const didRespond = isResSent(res)\n\n    const { staticPaths, fallbackMode } = hasStaticPaths\n      ? await this.getStaticPaths(pathname)\n      : { staticPaths: undefined, fallbackMode: false }\n\n    // When we did not respond from cache, we need to choose to block on\n    // rendering or return a skeleton.\n    //\n    // * Data requests always block.\n    //\n    // * Blocking mode fallback always blocks.\n    //\n    // * Preview mode toggles all pages to be resolved in a blocking manner.\n    //\n    // * Non-dynamic pages should block (though this is an impossible\n    //   case in production).\n    //\n    // * Dynamic pages should return their skeleton if not defined in\n    //   getStaticPaths, then finish the data request on the client-side.\n    //\n    if (\n      this.minimalMode !== true &&\n      fallbackMode !== 'blocking' &&\n      ssgCacheKey &&\n      !didRespond &&\n      !isPreviewMode &&\n      isDynamicPathname &&\n      // Development should trigger fallback when the path is not in\n      // `getStaticPaths`\n      (isProduction ||\n        !staticPaths ||\n        !staticPaths.includes(\n          // we use ssgCacheKey here as it is normalized to match the\n          // encoding from getStaticPaths along with including the locale\n          query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey\n        ))\n    ) {\n      if (\n        // In development, fall through to render to handle missing\n        // getStaticPaths.\n        (isProduction || staticPaths) &&\n        // When fallback isn't present, abort this render so we 404\n        fallbackMode !== 'static'\n      ) {\n        throw new NoFallbackError()\n      }\n\n      if (!isDataReq) {\n        let html: string\n\n        // Production already emitted the fallback as static HTML.\n        if (isProduction) {\n          html = await this.incrementalCache.getFallback(\n            locale ? `/${locale}${pathname}` : pathname\n          )\n        }\n        // We need to generate the fallback on-demand for development.\n        else {\n          query.__nextFallback = 'true'\n          if (isLikeServerless) {\n            prepareServerlessUrl(req, query)\n          }\n          const { value: renderResult } = await doRender()\n          html = renderResult.html\n        }\n\n        sendPayload(req, res, html, 'html', {\n          generateEtags: this.renderOpts.generateEtags,\n          poweredByHeader: this.renderOpts.poweredByHeader,\n        })\n        return null\n      }\n    }\n\n    const {\n      isOrigin,\n      value: { html, pageData, sprRevalidate, isNotFound, isRedirect },\n    } = await doRender()\n    let resHtml = html\n\n    const revalidateOptions =\n      !this.renderOpts.dev || (isServerProps && !isDataReq)\n        ? {\n            private: isPreviewMode,\n            stateful: !isSSG,\n            revalidate: sprRevalidate,\n          }\n        : undefined\n\n    if (\n      !isResSent(res) &&\n      !isNotFound &&\n      (isSSG || isDataReq || isServerProps)\n    ) {\n      if (isRedirect && !isDataReq) {\n        await handleRedirect(pageData)\n      } else {\n        sendPayload(\n          req,\n          res,\n          isDataReq ? JSON.stringify(pageData) : html,\n          isDataReq ? 'json' : 'html',\n          {\n            generateEtags: this.renderOpts.generateEtags,\n            poweredByHeader: this.renderOpts.poweredByHeader,\n          },\n          revalidateOptions\n        )\n      }\n      resHtml = null\n    }\n\n    // Update the cache if the head request and cacheable\n    if (isOrigin && ssgCacheKey) {\n      await this.incrementalCache.set(\n        ssgCacheKey,\n        { html: html!, pageData, isNotFound, isRedirect },\n        sprRevalidate\n      )\n    }\n\n    if (!isResSent(res) && isNotFound) {\n      if (revalidateOptions) {\n        setRevalidateHeaders(res, revalidateOptions)\n      }\n      if (isDataReq) {\n        res.statusCode = 404\n        res.end('{\"notFound\":true}')\n      } else {\n        await this.render404(req, res, {\n          pathname,\n          query,\n        } as UrlWithParsedQuery)\n      }\n    }\n    return resHtml\n  }\n\n  public async renderToHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    try {\n      const result = await this.findPageComponents(pathname, query)\n      if (result) {\n        try {\n          return await this.renderToHTMLWithComponents(\n            req,\n            res,\n            pathname,\n            result,\n            { ...this.renderOpts }\n          )\n        } catch (err) {\n          if (!(err instanceof NoFallbackError)) {\n            throw err\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname)\n          if (!params) {\n            continue\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(\n            dynamicRoute.page,\n            query,\n            params\n          )\n          if (dynamicRouteResult) {\n            try {\n              return await this.renderToHTMLWithComponents(\n                req,\n                res,\n                dynamicRoute.page,\n                dynamicRouteResult,\n                { ...this.renderOpts, params }\n              )\n            } catch (err) {\n              if (!(err instanceof NoFallbackError)) {\n                throw err\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      this.logError(err)\n\n      if (err && err.code === 'DECODE_FAILED') {\n        res.statusCode = 400\n        return await this.renderErrorToHTML(err, req, res, pathname, query)\n      }\n      res.statusCode = 500\n      return await this.renderErrorToHTML(err, req, res, pathname, query)\n    }\n    res.statusCode = 404\n    return await this.renderErrorToHTML(null, req, res, pathname, query)\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n    const html = await this.renderErrorToHTML(err, req, res, pathname, query)\n    if (html === null) {\n      return\n    }\n    return this.sendHTML(req, res, html)\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    console.warn(\n      chalk.bold.yellow(`Warning: `) +\n        chalk.yellow(\n          `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://err.sh/next.js/custom-error-no-custom-404`\n        )\n    )\n  })\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    _pathname: string,\n    query: ParsedUrlQuery = {}\n  ) {\n    let result: null | FindComponentsResult = null\n\n    const is404 = res.statusCode === 404\n    let using404Page = false\n\n    // use static 404 page if available and is 404 response\n    if (is404) {\n      result = await this.findPageComponents('/404', query)\n      using404Page = result !== null\n    }\n\n    if (!result) {\n      result = await this.findPageComponents('/_error', query)\n    }\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      !using404Page &&\n      (await this.hasPage('/_error')) &&\n      !(await this.hasPage('/404'))\n    ) {\n      this.customErrorNo404Warn()\n    }\n\n    let html: string | null\n    try {\n      try {\n        html = await this.renderToHTMLWithComponents(\n          req,\n          res,\n          using404Page ? '/404' : '/_error',\n          result!,\n          {\n            ...this.renderOpts,\n            err,\n          }\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (renderToHtmlError) {\n      console.error(renderToHtmlError)\n      res.statusCode = 500\n      html = 'Internal Server Error'\n    }\n    return html\n  }\n\n  public async render404(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: UrlWithParsedQuery,\n    setHeaders = true\n  ): Promise<void> {\n    const url: any = req.url\n    const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(url, true)\n    const { i18n } = this.nextConfig\n\n    if (i18n) {\n      query.__nextLocale = query.__nextLocale || i18n.defaultLocale\n      query.__nextDefaultLocale =\n        query.__nextDefaultLocale || i18n.defaultLocale\n    }\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n\n  public async serveStatic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    path: string,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      return this.renderError(null, req, res, path)\n    }\n\n    try {\n      await serveStatic(req, res, path)\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl)\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412\n        return this.renderError(err, req, res, path)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  private _validFilesystemPathSet: Set<string> | null = null\n  private getFilesystemPaths(): Set<string> {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet\n    }\n\n    const pathUserFilesStatic = join(this.dir, 'static')\n    let userFilesStatic: string[] = []\n    if (this.hasStaticDir && fs.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = recursiveReadDirSync(pathUserFilesStatic).map((f) =>\n        join('.', 'static', f)\n      )\n    }\n\n    let userFilesPublic: string[] = []\n    if (this.publicDir && fs.existsSync(this.publicDir)) {\n      userFilesPublic = recursiveReadDirSync(this.publicDir).map((f) =>\n        join('.', 'public', f)\n      )\n    }\n\n    let nextFilesStatic: string[] = []\n    nextFilesStatic = recursiveReadDirSync(\n      join(this.distDir, 'static')\n    ).map((f) => join('.', relative(this.dir, this.distDir), 'static', f))\n\n    return (this._validFilesystemPathSet = new Set<string>([\n      ...nextFilesStatic,\n      ...userFilesPublic,\n      ...userFilesStatic,\n    ]))\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = resolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n    if (\n      (untrustedFilePath.startsWith(join(this.distDir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'public') + sep)) === false\n    ) {\n      return false\n    }\n\n    // Check against the real filesystem paths\n    const filesystemUrls = this.getFilesystemPaths()\n    const resolved = relative(this.dir, untrustedFilePath)\n    return filesystemUrls.has(resolved)\n  }\n\n  protected readBuildId(): string {\n    const buildIdFile = join(this.distDir, BUILD_ID_FILE)\n    try {\n      return fs.readFileSync(buildIdFile, 'utf8').trim()\n    } catch (err) {\n      if (!fs.existsSync(buildIdFile)) {\n        throw new Error(\n          `Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://err.sh/vercel/next.js/production-start-no-build-id`\n        )\n      }\n\n      throw err\n    }\n  }\n\n  protected get _isLikeServerless(): boolean {\n    return isTargetLikeServerless(this.nextConfig.target)\n  }\n}\n\nfunction prepareServerlessUrl(\n  req: IncomingMessage,\n  query: ParsedUrlQuery\n): void {\n  const curUrl = parseUrl(req.url!, true)\n  req.url = formatUrl({\n    ...curUrl,\n    search: undefined,\n    query: {\n      ...curUrl.query,\n      ...query,\n    },\n  })\n}\n\nclass NoFallbackError extends Error {}\n"]},"metadata":{},"sourceType":"script"}