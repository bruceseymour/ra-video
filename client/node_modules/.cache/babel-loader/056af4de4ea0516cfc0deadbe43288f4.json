{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getUtils = getUtils;\nexports.vercelHeader = void 0;\n\nvar _url = require(\"url\");\n\nvar _querystring = require(\"querystring\");\n\nvar _normalizeLocalePath = require(\"../../../../next-server/lib/i18n/normalize-locale-path\");\n\nvar _pathMatch = _interopRequireDefault(require(\"../../../../next-server/lib/router/utils/path-match\"));\n\nvar _routeRegex = require(\"../../../../next-server/lib/router/utils/route-regex\");\n\nvar _routeMatcher = require(\"../../../../next-server/lib/router/utils/route-matcher\");\n\nvar _prepareDestination = _interopRequireDefault(require(\"../../../../next-server/lib/router/utils/prepare-destination\"));\n\nvar _accept = _interopRequireDefault(require(\"@hapi/accept\"));\n\nvar _detectLocaleCookie = require(\"../../../../next-server/lib/i18n/detect-locale-cookie\");\n\nvar _detectDomainLocale = require(\"../../../../next-server/lib/i18n/detect-domain-locale\");\n\nvar _denormalizePagePath = require(\"../../../../next-server/server/denormalize-page-path\");\n\nvar _cookie = _interopRequireDefault(require(\"next/dist/compiled/cookie\"));\n\nvar _constants = require(\"../../../../next-server/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst getCustomRouteMatcher = (0, _pathMatch.default)(true);\nconst vercelHeader = 'x-vercel-id';\nexports.vercelHeader = vercelHeader;\n\nfunction getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic\n}) {\n  let defaultRouteRegex;\n  let dynamicRouteMatcher;\n  let defaultRouteMatches;\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = (0, _routeRegex.getRouteRegex)(page);\n    dynamicRouteMatcher = (0, _routeMatcher.getRouteMatcher)(defaultRouteRegex);\n    defaultRouteMatches = dynamicRouteMatcher(page);\n  }\n\n  function handleRewrites(parsedUrl) {\n    for (const rewrite of rewrites) {\n      const matcher = getCustomRouteMatcher(rewrite.source);\n      const params = matcher(parsedUrl.pathname);\n\n      if (params) {\n        const {\n          parsedDestination\n        } = (0, _prepareDestination.default)(rewrite.destination, params, parsedUrl.query, true);\n        Object.assign(parsedUrl.query, parsedDestination.query);\n        delete parsedDestination.query;\n        Object.assign(parsedUrl, parsedDestination);\n        let fsPathname = parsedUrl.pathname;\n\n        if (basePath) {\n          fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/';\n        }\n\n        if (i18n) {\n          const destLocalePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(fsPathname, i18n.locales);\n          fsPathname = destLocalePathResult.pathname;\n          parsedUrl.query.nextInternalLocale = destLocalePathResult.detectedLocale || params.nextInternalLocale;\n        }\n\n        if (fsPathname === page) {\n          break;\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname);\n\n          if (dynamicParams) {\n            parsedUrl.query = { ...parsedUrl.query,\n              ...dynamicParams\n            };\n            break;\n          }\n        }\n      }\n    }\n\n    return parsedUrl;\n  }\n\n  function handleBasePath(req, parsedUrl) {\n    // always strip the basePath if configured since it is required\n    req.url = req.url.replace(new RegExp(`^${basePath}`), '') || '/';\n    parsedUrl.pathname = parsedUrl.pathname.replace(new RegExp(`^${basePath}`), '') || '/';\n  }\n\n  function getParamsFromRouteMatches(req, renderOpts, detectedLocale) {\n    return (0, _routeMatcher.getRouteMatcher)(function () {\n      const {\n        groups,\n        routeKeys\n      } = defaultRouteRegex;\n      return {\n        re: {\n          // Simulate a RegExp match from the \\`req.url\\` input\n          exec: str => {\n            const obj = (0, _querystring.parse)(str); // favor named matches if available\n\n            const routeKeyNames = Object.keys(routeKeys || {});\n\n            const filterLocaleItem = val => {\n              if (i18n) {\n                // locale items can be included in route-matches\n                // for fallback SSG pages so ensure they are\n                // filtered\n                const isCatchAll = Array.isArray(val);\n\n                const _val = isCatchAll ? val[0] : val;\n\n                if (typeof _val === 'string' && i18n.locales.some(item => {\n                  if (item.toLowerCase() === _val.toLowerCase()) {\n                    detectedLocale = item;\n                    renderOpts.locale = detectedLocale;\n                    return true;\n                  }\n\n                  return false;\n                })) {\n                  // remove the locale item from the match\n                  if (isCatchAll) {\n                    ;\n                    val.splice(0, 1);\n                  } // the value is only a locale item and\n                  // shouldn't be added\n\n\n                  return isCatchAll ? val.length === 0 : true;\n                }\n              }\n\n              return false;\n            };\n\n            if (routeKeyNames.every(name => obj[name])) {\n              return routeKeyNames.reduce((prev, keyName) => {\n                const paramName = routeKeys == null ? void 0 : routeKeys[keyName];\n\n                if (paramName && !filterLocaleItem(obj[keyName])) {\n                  prev[groups[paramName].pos] = obj[keyName];\n                }\n\n                return prev;\n              }, {});\n            }\n\n            return Object.keys(obj).reduce((prev, key) => {\n              if (!filterLocaleItem(obj[key])) {\n                return Object.assign(prev, {\n                  [key]: obj[key]\n                });\n              }\n\n              return prev;\n            }, {});\n          }\n        },\n        groups\n      };\n    }())(req.headers['x-now-route-matches']);\n  }\n\n  function interpolateDynamicPath(pathname, params) {\n    if (!defaultRouteRegex) return pathname;\n\n    for (const param of Object.keys(defaultRouteRegex.groups)) {\n      const {\n        optional,\n        repeat\n      } = defaultRouteRegex.groups[param];\n      let builtParam = `[${repeat ? '...' : ''}${param}]`;\n\n      if (optional) {\n        builtParam = `[${builtParam}]`;\n      }\n\n      const paramIdx = pathname.indexOf(builtParam);\n\n      if (paramIdx > -1) {\n        let paramValue;\n\n        if (Array.isArray(params[param])) {\n          paramValue = params[param].join('/');\n        } else {\n          paramValue = params[param];\n        }\n\n        pathname = pathname.substr(0, paramIdx) + encodeURI(paramValue || '') + pathname.substr(paramIdx + builtParam.length);\n      }\n    }\n\n    return pathname;\n  }\n\n  function normalizeVercelUrl(req, trustQuery) {\n    // make sure to normalize req.url on Vercel to strip dynamic params\n    // from the query which are added during routing\n    if (pageIsDynamic && trustQuery && defaultRouteRegex) {\n      const _parsedUrl = (0, _url.parse)(req.url, true);\n\n      delete _parsedUrl.search;\n\n      for (const param of Object.keys(defaultRouteRegex.groups)) {\n        delete _parsedUrl.query[param];\n      }\n\n      req.url = (0, _url.format)(_parsedUrl);\n    }\n  }\n\n  function normalizeDynamicRouteParams(params) {\n    let hasValidParams = true;\n    if (!defaultRouteRegex) return {\n      params,\n      hasValidParams\n    };\n    params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {\n      let value = params[key]; // if the value matches the default value we can't rely\n      // on the parsed params, this is used to signal if we need\n      // to parse x-now-route-matches or not\n\n      const isDefaultValue = Array.isArray(value) ? value.every((val, idx) => val === defaultRouteMatches[key][idx]) : value === defaultRouteMatches[key];\n\n      if (isDefaultValue || typeof value === 'undefined') {\n        hasValidParams = false;\n      } // non-provided optional values should be undefined so normalize\n      // them to undefined\n\n\n      if (defaultRouteRegex.groups[key].optional && (!value || Array.isArray(value) && value.length === 1 && ( // fallback optional catch-all SSG pages have\n      // [[...paramName]] for the root path on Vercel\n      value[0] === 'index' || value[0] === `[[...${key}]]`))) {\n        value = undefined;\n        delete params[key];\n      } // query values from the proxy aren't already split into arrays\n      // so make sure to normalize catch-all values\n\n\n      if (value && typeof value === 'string' && defaultRouteRegex.groups[key].repeat) {\n        value = value.split('/');\n      }\n\n      if (value) {\n        prev[key] = value;\n      }\n\n      return prev;\n    }, {});\n    return {\n      params,\n      hasValidParams\n    };\n  }\n\n  function handleLocale(req, res, parsedUrl, routeNoAssetPath, shouldNotRedirect) {\n    if (!i18n) return;\n    let defaultLocale = i18n.defaultLocale;\n    let detectedLocale = (0, _detectLocaleCookie.detectLocaleCookie)(req, i18n.locales);\n    let acceptPreferredLocale = i18n.localeDetection !== false ? _accept.default.language(req.headers['accept-language'], i18n.locales) : detectedLocale;\n    const {\n      host\n    } = req.headers || {}; // remove port from host and remove port if present\n\n    const hostname = host && host.split(':')[0].toLowerCase();\n    const detectedDomain = (0, _detectDomainLocale.detectDomainLocale)(i18n.domains, hostname);\n\n    if (detectedDomain) {\n      defaultLocale = detectedDomain.defaultLocale;\n      detectedLocale = defaultLocale;\n    } // if not domain specific locale use accept-language preferred\n\n\n    detectedLocale = detectedLocale || acceptPreferredLocale;\n    let localeDomainRedirect;\n    const localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedUrl.pathname, i18n.locales);\n    routeNoAssetPath = (0, _normalizeLocalePath.normalizeLocalePath)(routeNoAssetPath, i18n.locales).pathname;\n\n    if (localePathResult.detectedLocale) {\n      detectedLocale = localePathResult.detectedLocale;\n      req.url = (0, _url.format)({ ...parsedUrl,\n        pathname: localePathResult.pathname\n      });\n      req.__nextStrippedLocale = true;\n      parsedUrl.pathname = localePathResult.pathname;\n    } // If a detected locale is a domain specific locale and we aren't already\n    // on that domain and path prefix redirect to it to prevent duplicate\n    // content from multiple domains\n\n\n    if (detectedDomain) {\n      const localeToCheck = localePathResult.detectedLocale ? detectedLocale : acceptPreferredLocale;\n      const matchedDomain = (0, _detectDomainLocale.detectDomainLocale)(i18n.domains, undefined, localeToCheck);\n\n      if (matchedDomain && matchedDomain.domain !== detectedDomain.domain) {\n        localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${matchedDomain.domain}/${localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck}`;\n      }\n    }\n\n    const denormalizedPagePath = (0, _denormalizePagePath.denormalizePagePath)(parsedUrl.pathname || '/');\n    const detectedDefaultLocale = !detectedLocale || detectedLocale.toLowerCase() === defaultLocale.toLowerCase();\n    const shouldStripDefaultLocale = false; // detectedDefaultLocale &&\n    // denormalizedPagePath.toLowerCase() === \\`/\\${i18n.defaultLocale.toLowerCase()}\\`\n\n    const shouldAddLocalePrefix = !detectedDefaultLocale && denormalizedPagePath === '/';\n    detectedLocale = detectedLocale || i18n.defaultLocale;\n\n    if (!shouldNotRedirect && !req.headers[vercelHeader] && i18n.localeDetection !== false && (localeDomainRedirect || shouldAddLocalePrefix || shouldStripDefaultLocale)) {\n      // set the NEXT_LOCALE cookie when a user visits the default locale\n      // with the locale prefix so that they aren't redirected back to\n      // their accept-language preferred locale\n      if (shouldStripDefaultLocale && acceptPreferredLocale !== defaultLocale) {\n        const previous = res.getHeader('set-cookie');\n        res.setHeader('set-cookie', [...(typeof previous === 'string' ? [previous] : Array.isArray(previous) ? previous : []), _cookie.default.serialize('NEXT_LOCALE', defaultLocale, {\n          httpOnly: true,\n          path: '/'\n        })]);\n      }\n\n      res.setHeader('Location', (0, _url.format)({ // make sure to include any query values when redirecting\n        ...parsedUrl,\n        pathname: localeDomainRedirect ? localeDomainRedirect : shouldStripDefaultLocale ? basePath || '/' : `${basePath}/${detectedLocale}`\n      }));\n      res.statusCode = _constants.TEMPORARY_REDIRECT_STATUS;\n      res.end();\n      return;\n    }\n\n    detectedLocale = localePathResult.detectedLocale || detectedDomain && detectedDomain.defaultLocale || defaultLocale;\n    return {\n      defaultLocale,\n      detectedLocale,\n      routeNoAssetPath\n    };\n  }\n\n  return {\n    handleLocale,\n    handleRewrites,\n    handleBasePath,\n    defaultRouteRegex,\n    normalizeVercelUrl,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    interpolateDynamicPath,\n    getParamsFromRouteMatches,\n    normalizeDynamicRouteParams\n  };\n}","map":{"version":3,"sources":["../../../../../build/webpack/loaders/next-serverless-loader/utils.ts"],"names":["getCustomRouteMatcher","vercelHeader","defaultRouteRegex","dynamicRouteMatcher","defaultRouteMatches","matcher","rewrite","params","parsedUrl","Object","parsedDestination","fsPathname","basePath","destLocalePathResult","i18n","pageIsDynamic","dynamicParams","req","re","exec","str","obj","routeKeyNames","routeKeys","filterLocaleItem","val","isCatchAll","Array","_val","item","detectedLocale","renderOpts","name","paramName","prev","groups","builtParam","repeat","param","paramIdx","pathname","paramValue","encodeURI","_parsedUrl","hasValidParams","value","isDefaultValue","key","defaultLocale","acceptPreferredLocale","accept","hostname","host","detectedDomain","localePathResult","routeNoAssetPath","localeToCheck","matchedDomain","localeDomainRedirect","domain","denormalizedPagePath","detectedDefaultLocale","shouldStripDefaultLocale","shouldAddLocalePrefix","previous","res","cookie","httpOnly","path","TEMPORARY_REDIRECT_STATUS"],"mappings":";;;;;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,IAAA,oBAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,IAAA,UAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,qDAAA,CAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,8DAAA,CAAA,CAAA;;AAQA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AACA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,2BAAA,CAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;;;;;AAGA;;AAAA,MAAMA,qBAAqB,GAAG,CAAA,GAAA,UAAA,CAAA,OAAA,EAA9B,IAA8B,CAA9B;AAEO,MAAMC,YAAY,GAAlB,aAAA;;;AAsCA,SAAA,QAAA,CAAkB;AAAA,EAAA,IAAA;AAAA,EAAA,IAAA;AAAA,EAAA,QAAA;AAAA,EAAA,QAAA;AAAlB,EAAA;AAAkB,CAAlB,EAYJ;AACD,MAAA,iBAAA;AACA,MAAA,mBAAA;AACA,MAAA,mBAAA;;AAEA,MAAA,aAAA,EAAmB;AACjBC,IAAAA,iBAAiB,GAAG,CAAA,GAAA,WAAA,CAAA,aAAA,EAApBA,IAAoB,CAApBA;AACAC,IAAAA,mBAAmB,GAAG,CAAA,GAAA,aAAA,CAAA,eAAA,EAAtBA,iBAAsB,CAAtBA;AACAC,IAAAA,mBAAmB,GAAGD,mBAAmB,CAAzCC,IAAyC,CAAzCA;AAGF;;AAAA,WAAA,cAAA,CAAA,SAAA,EAAuD;AACrD,SAAK,MAAL,OAAA,IAAA,QAAA,EAAgC;AAC9B,YAAMC,OAAO,GAAGL,qBAAqB,CAACM,OAAO,CAA7C,MAAqC,CAArC;AACA,YAAMC,MAAM,GAAGF,OAAO,CAACG,SAAS,CAAhC,QAAsB,CAAtB;;AAEA,UAAA,MAAA,EAAY;AACV,cAAM;AAAA,UAAA;AAAA,YAAwB,CAAA,GAAA,mBAAA,CAAA,OAAA,EAC5BF,OAAO,CADqB,WAAA,EAAA,MAAA,EAG5BE,SAAS,CAHmB,KAAA,EAA9B,IAA8B,CAA9B;AAOAC,QAAAA,MAAM,CAANA,MAAAA,CAAcD,SAAS,CAAvBC,KAAAA,EAA+BC,iBAAiB,CAAhDD,KAAAA;AACA,eAAQC,iBAAD,CAAP,KAAA;AAEAD,QAAAA,MAAM,CAANA,MAAAA,CAAAA,SAAAA,EAAAA,iBAAAA;AAEA,YAAIE,UAAU,GAAGH,SAAS,CAA1B,QAAA;;AAEA,YAAA,QAAA,EAAc;AACZG,UAAAA,UAAU,GACRA,UAAU,CAAVA,OAAAA,CAAoB,IAAA,MAAA,CAAY,IAAGC,QAAnCD,EAAoB,CAApBA,EAAAA,EAAAA,KADFA,GAAAA;AAIF;;AAAA,YAAA,IAAA,EAAU;AACR,gBAAME,oBAAoB,GAAG,CAAA,GAAA,oBAAA,CAAA,mBAAA,EAAA,UAAA,EAE3BC,IAAI,CAFN,OAA6B,CAA7B;AAIAH,UAAAA,UAAU,GAAGE,oBAAoB,CAAjCF,QAAAA;AACAH,UAAAA,SAAS,CAATA,KAAAA,CAAAA,kBAAAA,GACEK,oBAAoB,CAApBA,cAAAA,IAAuCN,MAAM,CAD/CC,kBAAAA;AAIF;;AAAA,YAAIG,UAAU,KAAd,IAAA,EAAyB;AACvB;AAGF;;AAAA,YAAII,aAAa,IAAjB,mBAAA,EAA0C;AACxC,gBAAMC,aAAa,GAAGb,mBAAmB,CAAzC,UAAyC,CAAzC;;AACA,cAAA,aAAA,EAAmB;AACjBK,YAAAA,SAAS,CAATA,KAAAA,GAAkB,EAChB,GAAGA,SAAS,CADI,KAAA;AAEhB,iBAFFA;AAAkB,aAAlBA;AAIA;AAEH;AACF;AACF;AAED;;AAAA,WAAA,SAAA;AAGF;;AAAA,WAAA,cAAA,CAAA,GAAA,EAAA,SAAA,EAA6E;AAC3E;AACAS,IAAAA,GAAG,CAAHA,GAAAA,GAAUA,GAAG,CAAHA,GAAAA,CAAAA,OAAAA,CAAiB,IAAA,MAAA,CAAY,IAAGL,QAAhCK,EAAiB,CAAjBA,EAAAA,EAAAA,KAAVA,GAAAA;AACAT,IAAAA,SAAS,CAATA,QAAAA,GACEA,SAAS,CAATA,QAAAA,CAAAA,OAAAA,CAA4B,IAAA,MAAA,CAAY,IAAGI,QAA3CJ,EAA4B,CAA5BA,EAAAA,EAAAA,KADFA,GAAAA;AAIF;;AAAA,WAAA,yBAAA,CAAA,GAAA,EAAA,UAAA,EAAA,cAAA,EAIE;AACA,WAAO,CAAA,GAAA,aAAA,CAAA,eAAA,EACJ,YAAY;AACX,YAAM;AAAA,QAAA,MAAA;AAAA,QAAA;AAAA,UAAN,iBAAA;AAEA,aAAO;AACLU,QAAAA,EAAE,EAAE;AACF;AACAC,UAAAA,IAAI,EAAGC,GAAD,IAAiB;AACrB,kBAAMC,GAAG,GAAG,CAAA,GAAA,YAAA,CAAA,KAAA,EAAZ,GAAY,CAAZ,CADqB,CAGrB;;AACA,kBAAMC,aAAa,GAAGb,MAAM,CAANA,IAAAA,CAAYc,SAAS,IAA3C,EAAsBd,CAAtB;;AAEA,kBAAMe,gBAAgB,GAAIC,GAAD,IAA4B;AACnD,kBAAA,IAAA,EAAU;AACR;AACA;AACA;AACA,sBAAMC,UAAU,GAAGC,KAAK,CAALA,OAAAA,CAAnB,GAAmBA,CAAnB;;AACA,sBAAMC,IAAI,GAAGF,UAAU,GAAGD,GAAG,CAAN,CAAM,CAAN,GAAvB,GAAA;;AAEA,oBACE,OAAA,IAAA,KAAA,QAAA,IACAX,IAAI,CAAJA,OAAAA,CAAAA,IAAAA,CAAmBe,IAAD,IAAU;AAC1B,sBAAIA,IAAI,CAAJA,WAAAA,OAAuBD,IAAI,CAA/B,WAA2BA,EAA3B,EAA+C;AAC7CE,oBAAAA,cAAc,GAAdA,IAAAA;AACAC,oBAAAA,UAAU,CAAVA,MAAAA,GAAAA,cAAAA;AACA,2BAAA,IAAA;AAEF;;AAAA,yBAAA,KAAA;AARJ,iBAEEjB,CAFF,EAUE;AACA;AACA,sBAAA,UAAA,EAAgB;AACd;AAAEW,oBAAAA,GAAD,CAAA,MAACA,CAAD,CAACA,EAAD,CAACA;AAGJ,mBANA,CAMA;AACA;;;AACA,yBAAOC,UAAU,GAAGD,GAAG,CAAHA,MAAAA,KAAH,CAAA,GAAjB,IAAA;AAEH;AACD;;AAAA,qBAAA,KAAA;AA7BF,aAAA;;AAgCA,gBAAIH,aAAa,CAAbA,KAAAA,CAAqBU,IAAD,IAAUX,GAAG,CAArC,IAAqC,CAAjCC,CAAJ,EAA8C;AAC5C,qBAAOA,aAAa,CAAbA,MAAAA,CAAqB,CAAA,IAAA,EAAA,OAAA,KAAmB;AAC7C,sBAAMW,SAAS,GAAGV,SAAH,IAAA,IAAGA,GAAH,KAAA,CAAGA,GAAAA,SAAS,CAA3B,OAA2B,CAA3B;;AAEA,oBAAIU,SAAS,IAAI,CAACT,gBAAgB,CAACH,GAAG,CAAtC,OAAsC,CAAJ,CAAlC,EAAkD;AAChDa,kBAAAA,IAAI,CAACC,MAAM,CAANA,SAAM,CAANA,CAALD,GAAI,CAAJA,GAA8Bb,GAAG,CAAjCa,OAAiC,CAAjCA;AAEF;;AAAA,uBAAA,IAAA;AANKZ,eAAAA,EAAP,EAAOA,CAAP;AAUF;;AAAA,mBAAOb,MAAM,CAANA,IAAAA,CAAAA,GAAAA,EAAAA,MAAAA,CAAwB,CAAA,IAAA,EAAA,GAAA,KAAe;AAC5C,kBAAI,CAACe,gBAAgB,CAACH,GAAG,CAAzB,GAAyB,CAAJ,CAArB,EAAiC;AAC/B,uBAAOZ,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAoB;AACzB,mBAAA,GAAA,GAAOY,GAAG,CADZ,GACY;AADe,iBAApBZ,CAAP;AAIF;;AAAA,qBAAA,IAAA;AANKA,aAAAA,EAAP,EAAOA,CAAP;AApDC;AACD,SADC;AAAP,QAAA;AAAO,OAAP;AAJG,KACJ,EADI,EAqELQ,GAAG,CAAHA,OAAAA,CArEF,qBAqEEA,CArEK,CAAP;AAwEF;;AAAA,WAAA,sBAAA,CAAA,QAAA,EAAA,MAAA,EAA0E;AACxE,QAAI,CAAJ,iBAAA,EAAwB,OAAA,QAAA;;AAExB,SAAK,MAAL,KAAA,IAAoBR,MAAM,CAANA,IAAAA,CAAYP,iBAAiB,CAAjD,MAAoBO,CAApB,EAA2D;AACzD,YAAM;AAAA,QAAA,QAAA;AAAA,QAAA;AAAA,UAAuBP,iBAAiB,CAAjBA,MAAAA,CAA7B,KAA6BA,CAA7B;AACA,UAAIkC,UAAU,GAAI,IAAGC,MAAM,GAAA,KAAA,GAAW,EAAG,GAAEC,KAA3C,GAAA;;AAEA,UAAA,QAAA,EAAc;AACZF,QAAAA,UAAU,GAAI,IAAGA,UAAjBA,GAAAA;AAGF;;AAAA,YAAMG,QAAQ,GAAGC,QAAQ,CAARA,OAAAA,CAAjB,UAAiBA,CAAjB;;AAEA,UAAID,QAAQ,GAAG,CAAf,CAAA,EAAmB;AACjB,YAAA,UAAA;;AAEA,YAAIZ,KAAK,CAALA,OAAAA,CAAcpB,MAAM,CAAxB,KAAwB,CAApBoB,CAAJ,EAAkC;AAChCc,UAAAA,UAAU,GAAIlC,MAAM,CAAP,KAAO,CAANA,CAAD,IAACA,CAAdkC,GAAclC,CAAdkC;AADF,SAAA,MAEO;AACLA,UAAAA,UAAU,GAAGlC,MAAM,CAAnBkC,KAAmB,CAAnBA;AAGFD;;AAAAA,QAAAA,QAAQ,GACNA,QAAQ,CAARA,MAAAA,CAAAA,CAAAA,EAAAA,QAAAA,IACAE,SAAS,CAACD,UAAU,IADpBD,EACS,CADTA,GAEAA,QAAQ,CAARA,MAAAA,CAAgBD,QAAQ,GAAGH,UAAU,CAHvCI,MAGEA,CAHFA;AAKH;AAED;;AAAA,WAAA,QAAA;AAGF;;AAAA,WAAA,kBAAA,CAAA,GAAA,EAAA,UAAA,EAAuE;AACrE;AACA;AACA,QAAIzB,aAAa,IAAbA,UAAAA,IAAJ,iBAAA,EAAsD;AACpD,YAAM4B,UAAU,GAAG,CAAA,GAAA,IAAA,CAAA,KAAA,EAAS1B,GAAG,CAAZ,GAAA,EAAnB,IAAmB,CAAnB;;AACA,aAAQ0B,UAAD,CAAP,MAAA;;AAEA,WAAK,MAAL,KAAA,IAAoBlC,MAAM,CAANA,IAAAA,CAAYP,iBAAiB,CAAjD,MAAoBO,CAApB,EAA2D;AACzD,eAAOkC,UAAU,CAAVA,KAAAA,CAAP,KAAOA,CAAP;AAEF1B;;AAAAA,MAAAA,GAAG,CAAHA,GAAAA,GAAU,CAAA,GAAA,IAAA,CAAA,MAAA,EAAVA,UAAU,CAAVA;AAEH;AAED;;AAAA,WAAA,2BAAA,CAAA,MAAA,EAA6D;AAC3D,QAAI2B,cAAc,GAAlB,IAAA;AACA,QAAI,CAAJ,iBAAA,EAAwB,OAAO;AAAA,MAAA,MAAA;AAAP,MAAA;AAAO,KAAP;AAExB,IAAA,MAAM,GAAG,MAAM,CAAN,IAAA,CAAY1C,iBAAiB,CAA7B,MAAA,EAAA,MAAA,CAA6C,CAAA,IAAA,EAAA,GAAA,KAAe;AACnE,UAAI2C,KAAoC,GAAGtC,MAAM,CAAjD,GAAiD,CAAjD,CADmE,CAGnE;AACA;AACA;;AACA,YAAMuC,cAAc,GAAGnB,KAAK,CAALA,OAAAA,CAAAA,KAAAA,IACnBkB,KAAK,CAALA,KAAAA,CAAY,CAAA,GAAA,EAAA,GAAA,KAAcpB,GAAG,KAAKrB,mBAAmB,CAAnBA,GAAmB,CAAnBA,CADfuB,GACevB,CAAlCyC,CADmBlB,GAEnBkB,KAAK,KAAKzC,mBAAmB,CAFjC,GAEiC,CAFjC;;AAIA,UAAI0C,cAAc,IAAI,OAAA,KAAA,KAAtB,WAAA,EAAoD;AAClDF,QAAAA,cAAc,GAAdA,KAAAA;AAGF,OAdmE,CAcnE;AACA;;;AACA,UACE1C,iBAAiB,CAAjBA,MAAAA,CAAAA,GAAAA,EAAAA,QAAAA,KACC,CAAA,KAAA,IACE,KAAK,CAAL,OAAA,CAAA,KAAA,KACC2C,KAAK,CAALA,MAAAA,KADD,CAAA,MAEC;AACA;AACCA,MAAAA,KAAK,CAALA,CAAK,CAALA,KAAAA,OAAAA,IAAwBA,KAAK,CAALA,CAAK,CAALA,KAAc,QAAOE,GAPpD,IAGK,CAFH7C,CADF,EAQE;AACA2C,QAAAA,KAAK,GAALA,SAAAA;AACA,eAAOtC,MAAM,CAAb,GAAa,CAAb;AAGF,OA7BmE,CA6BnE;AACA;;;AACA,UACEsC,KAAK,IACL,OAAA,KAAA,KADAA,QAAAA,IAEA3C,iBAAiB,CAAjBA,MAAAA,CAAAA,GAAAA,EAHF,MAAA,EAIE;AACA2C,QAAAA,KAAK,GAAGA,KAAK,CAALA,KAAAA,CAARA,GAAQA,CAARA;AAGF;;AAAA,UAAA,KAAA,EAAW;AACTX,QAAAA,IAAI,CAAJA,GAAI,CAAJA,GAAAA,KAAAA;AAEF;;AAAA,aAAA,IAAA;AA1CO,KAAA,EAAT,EAAS,CAAT;AA6CA,WAAO;AAAA,MAAA,MAAA;AAAP,MAAA;AAAO,KAAP;AAMF;;AAAA,WAAA,YAAA,CAAA,GAAA,EAAA,GAAA,EAAA,SAAA,EAAA,gBAAA,EAAA,iBAAA,EAME;AACA,QAAI,CAAJ,IAAA,EAAW;AAEX,QAAIc,aAAa,GAAGlC,IAAI,CAAxB,aAAA;AACA,QAAIgB,cAAc,GAAG,CAAA,GAAA,mBAAA,CAAA,kBAAA,EAAA,GAAA,EAAwBhB,IAAI,CAAjD,OAAqB,CAArB;AACA,QAAImC,qBAAqB,GACvBnC,IAAI,CAAJA,eAAAA,KAAAA,KAAAA,GACIoC,OAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAgBjC,GAAG,CAAHA,OAAAA,CAAhBiC,iBAAgBjC,CAAhBiC,EAAgDpC,IAAI,CADxDA,OACIoC,CADJpC,GADF,cAAA;AAKA,UAAM;AAAA,MAAA;AAAA,QAAWG,GAAG,CAAHA,OAAAA,IAAjB,EAAA,CAVA,CAWA;;AACA,UAAMkC,QAAQ,GAAGC,IAAI,IAAIA,IAAI,CAAJA,KAAAA,CAAAA,GAAAA,EAAAA,CAAAA,EAAzB,WAAyBA,EAAzB;AAEA,UAAMC,cAAc,GAAG,CAAA,GAAA,mBAAA,CAAA,kBAAA,EAAmBvC,IAAI,CAAvB,OAAA,EAAvB,QAAuB,CAAvB;;AACA,QAAA,cAAA,EAAoB;AAClBkC,MAAAA,aAAa,GAAGK,cAAc,CAA9BL,aAAAA;AACAlB,MAAAA,cAAc,GAAdA,aAAAA;AAGF,KApBA,CAoBA;;;AACAA,IAAAA,cAAc,GAAGA,cAAc,IAA/BA,qBAAAA;AAEA,QAAA,oBAAA;AACA,UAAMwB,gBAAgB,GAAG,CAAA,GAAA,oBAAA,CAAA,mBAAA,EACvB9C,SAAS,CADc,QAAA,EAEvBM,IAAI,CAFN,OAAyB,CAAzB;AAKAyC,IAAAA,gBAAgB,GAAG,CAAA,GAAA,oBAAA,CAAA,mBAAA,EAAA,gBAAA,EAAsCzC,IAAI,CAA1C,OAAA,EAAnByC,QAAAA;;AAGA,QAAID,gBAAgB,CAApB,cAAA,EAAqC;AACnCxB,MAAAA,cAAc,GAAGwB,gBAAgB,CAAjCxB,cAAAA;AACAb,MAAAA,GAAG,CAAHA,GAAAA,GAAU,CAAA,GAAA,IAAA,CAAA,MAAA,EAAU,EAClB,GADkB,SAAA;AAElBuB,QAAAA,QAAQ,EAAEc,gBAAgB,CAF5BrC;AAAoB,OAAV,CAAVA;AAIEA,MAAAA,GAAD,CAAA,oBAACA,GAAD,IAACA;AACFT,MAAAA,SAAS,CAATA,QAAAA,GAAqB8C,gBAAgB,CAArC9C,QAAAA;AAGF,KA1CA,CA0CA;AACA;AACA;;;AACA,QAAA,cAAA,EAAoB;AAClB,YAAMgD,aAAa,GAAGF,gBAAgB,CAAhBA,cAAAA,GAAAA,cAAAA,GAAtB,qBAAA;AAIA,YAAMG,aAAa,GAAG,CAAA,GAAA,mBAAA,CAAA,kBAAA,EACpB3C,IAAI,CADgB,OAAA,EAAA,SAAA,EAAtB,aAAsB,CAAtB;;AAMA,UAAI2C,aAAa,IAAIA,aAAa,CAAbA,MAAAA,KAAyBJ,cAAc,CAA5D,MAAA,EAAqE;AACnEK,QAAAA,oBAAoB,GAAI,OAAMD,aAAa,CAAbA,IAAAA,GAAAA,EAAAA,GAA0B,GAAI,MAC1DA,aAAa,CAACE,MACf,IAAGH,aAAa,KAAKC,aAAa,CAA/BD,aAAAA,GAAAA,EAAAA,GAAqDA,aAFzDE,EAAAA;AAIH;AAED;;AAAA,UAAME,oBAAoB,GAAG,CAAA,GAAA,oBAAA,CAAA,mBAAA,EAAoBpD,SAAS,CAATA,QAAAA,IAAjD,GAA6B,CAA7B;AACA,UAAMqD,qBAAqB,GACzB,CAAA,cAAA,IACA/B,cAAc,CAAdA,WAAAA,OAAiCkB,aAAa,CAFhD,WAEmCA,EAFnC;AAGA,UAAMc,wBAAwB,GAA9B,KAAA,CAnEA,CAoEA;AACA;;AAEA,UAAMC,qBAAqB,GACzB,CAAA,qBAAA,IAA0BH,oBAAoB,KADhD,GAAA;AAGA9B,IAAAA,cAAc,GAAGA,cAAc,IAAIhB,IAAI,CAAvCgB,aAAAA;;AAEA,QACE,CAAA,iBAAA,IACA,CAACb,GAAG,CAAHA,OAAAA,CADD,YACCA,CADD,IAEAH,IAAI,CAAJA,eAAAA,KAFA,KAAA,KAGC4C,oBAAoB,IAApBA,qBAAAA,IAJH,wBACE,CADF,EAOE;AACA;AACA;AACA;AACA,UAAII,wBAAwB,IAAIb,qBAAqB,KAArD,aAAA,EAAyE;AACvE,cAAMe,QAAQ,GAAGC,GAAG,CAAHA,SAAAA,CAAjB,YAAiBA,CAAjB;AAEAA,QAAAA,GAAG,CAAHA,SAAAA,CAAAA,YAAAA,EAA4B,CAC1B,IAAI,OAAA,QAAA,KAAA,QAAA,GACA,CADA,QACA,CADA,GAEAtC,KAAK,CAALA,OAAAA,CAAAA,QAAAA,IAAAA,QAAAA,GAHsB,EAC1B,CAD0B,EAM1BuC,OAAAA,CAAAA,OAAAA,CAAAA,SAAAA,CAAAA,aAAAA,EAAAA,aAAAA,EAA+C;AAC7CC,UAAAA,QAAQ,EADqC,IAAA;AAE7CC,UAAAA,IAAI,EARRH;AAMiD,SAA/CC,CAN0B,CAA5BD;AAaF;;AAAA,MAAA,GAAG,CAAH,SAAA,CAAA,UAAA,EAEE,CAAA,GAAA,IAAA,CAAA,MAAA,EAAU,EACR;AACA,WAFQ,SAAA;AAGRzB,QAAAA,QAAQ,EAAEkB,oBAAoB,GAAA,oBAAA,GAE1BI,wBAAwB,GACxBlD,QAAQ,IADgB,GAAA,GAEvB,GAAEA,QAAS,IAAGkB,cATvB;AAEY,OAAV,CAFF;AAYAmC,MAAAA,GAAG,CAAHA,UAAAA,GAAiBI,UAAAA,CAAjBJ,yBAAAA;AACAA,MAAAA,GAAG,CAAHA,GAAAA;AACA;AAGFnC;;AAAAA,IAAAA,cAAc,GACZwB,gBAAgB,CAAhBA,cAAAA,IACCD,cAAc,IAAIA,cAAc,CADjCC,aAAAA,IADFxB,aAAAA;AAKA,WAAO;AAAA,MAAA,aAAA;AAAA,MAAA,cAAA;AAAP,MAAA;AAAO,KAAP;AAOF;;AAAA,SAAO;AAAA,IAAA,YAAA;AAAA,IAAA,cAAA;AAAA,IAAA,cAAA;AAAA,IAAA,iBAAA;AAAA,IAAA,kBAAA;AAAA,IAAA,mBAAA;AAAA,IAAA,mBAAA;AAAA,IAAA,sBAAA;AAAA,IAAA,yBAAA;AAAP,IAAA;AAAO,GAAP;AAYD","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { format as formatUrl, UrlWithParsedQuery, parse as parseUrl } from 'url'\nimport { parse as parseQs, ParsedUrlQuery } from 'querystring'\nimport { Rewrite } from '../../../../lib/load-custom-routes'\nimport { normalizeLocalePath } from '../../../../next-server/lib/i18n/normalize-locale-path'\nimport pathMatch from '../../../../next-server/lib/router/utils/path-match'\nimport { getRouteRegex } from '../../../../next-server/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../../../../next-server/lib/router/utils/route-matcher'\nimport prepareDestination from '../../../../next-server/lib/router/utils/prepare-destination'\nimport { __ApiPreviewProps } from '../../../../next-server/server/api-utils'\nimport { BuildManifest } from '../../../../next-server/server/get-page-files'\nimport {\n  GetServerSideProps,\n  GetStaticPaths,\n  GetStaticProps,\n} from '../../../../types'\nimport accept from '@hapi/accept'\nimport { detectLocaleCookie } from '../../../../next-server/lib/i18n/detect-locale-cookie'\nimport { detectDomainLocale } from '../../../../next-server/lib/i18n/detect-domain-locale'\nimport { denormalizePagePath } from '../../../../next-server/server/denormalize-page-path'\nimport cookie from 'next/dist/compiled/cookie'\nimport { TEMPORARY_REDIRECT_STATUS } from '../../../../next-server/lib/constants'\nimport { NextConfig } from '../../../../next-server/server/config'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\nexport const vercelHeader = 'x-vercel-id'\n\nexport type ServerlessHandlerCtx = {\n  page: string\n\n  pageModule: any\n  pageComponent?: any\n  pageConfig?: any\n  pageGetStaticProps?: GetStaticProps\n  pageGetStaticPaths?: GetStaticPaths\n  pageGetServerSideProps?: GetServerSideProps\n\n  appModule?: any\n  errorModule?: any\n  documentModule?: any\n  notFoundModule?: any\n\n  runtimeConfig: any\n  buildManifest?: BuildManifest\n  reactLoadableManifest?: any\n  basePath: string\n  rewrites: Rewrite[]\n  pageIsDynamic: boolean\n  generateEtags: boolean\n  distDir: string\n  buildId: string\n  escapedBuildId: string\n  assetPrefix: string\n  poweredByHeader: boolean\n  canonicalBase: string\n  encodedPreviewProps: __ApiPreviewProps\n  i18n?: NextConfig['i18n']\n  experimental: {\n    initServer: () => Promise<any>\n    onError: ({ err }: { err: Error }) => Promise<any>\n  }\n}\n\nexport function getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n}: {\n  page: ServerlessHandlerCtx['page']\n  i18n?: ServerlessHandlerCtx['i18n']\n  basePath: ServerlessHandlerCtx['basePath']\n  rewrites: ServerlessHandlerCtx['rewrites']\n  pageIsDynamic: ServerlessHandlerCtx['pageIsDynamic']\n}) {\n  let defaultRouteRegex: ReturnType<typeof getRouteRegex> | undefined\n  let dynamicRouteMatcher: ReturnType<typeof getRouteMatcher> | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getRouteRegex(page)\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(parsedUrl: UrlWithParsedQuery) {\n    for (const rewrite of rewrites) {\n      const matcher = getCustomRouteMatcher(rewrite.source)\n      const params = matcher(parsedUrl.pathname)\n\n      if (params) {\n        const { parsedDestination } = prepareDestination(\n          rewrite.destination,\n          params,\n          parsedUrl.query,\n          true\n        )\n\n        Object.assign(parsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(parsedUrl, parsedDestination)\n\n        let fsPathname = parsedUrl.pathname\n\n        if (basePath) {\n          fsPathname =\n            fsPathname!.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const destLocalePathResult = normalizeLocalePath(\n            fsPathname!,\n            i18n.locales\n          )\n          fsPathname = destLocalePathResult.pathname\n          parsedUrl.query.nextInternalLocale =\n            destLocalePathResult.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          break\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            parsedUrl.query = {\n              ...parsedUrl.query,\n              ...dynamicParams,\n            }\n            break\n          }\n        }\n      }\n    }\n\n    return parsedUrl\n  }\n\n  function handleBasePath(req: IncomingMessage, parsedUrl: UrlWithParsedQuery) {\n    // always strip the basePath if configured since it is required\n    req.url = req.url!.replace(new RegExp(`^${basePath}`), '') || '/'\n    parsedUrl.pathname =\n      parsedUrl.pathname!.replace(new RegExp(`^${basePath}`), '') || '/'\n  }\n\n  function getParamsFromRouteMatches(\n    req: IncomingMessage,\n    renderOpts?: any,\n    detectedLocale?: string\n  ) {\n    return getRouteMatcher(\n      (function () {\n        const { groups, routeKeys } = defaultRouteRegex!\n\n        return {\n          re: {\n            // Simulate a RegExp match from the \\`req.url\\` input\n            exec: (str: string) => {\n              const obj = parseQs(str)\n\n              // favor named matches if available\n              const routeKeyNames = Object.keys(routeKeys || {})\n\n              const filterLocaleItem = (val: string | string[]) => {\n                if (i18n) {\n                  // locale items can be included in route-matches\n                  // for fallback SSG pages so ensure they are\n                  // filtered\n                  const isCatchAll = Array.isArray(val)\n                  const _val = isCatchAll ? val[0] : val\n\n                  if (\n                    typeof _val === 'string' &&\n                    i18n.locales.some((item) => {\n                      if (item.toLowerCase() === _val.toLowerCase()) {\n                        detectedLocale = item\n                        renderOpts.locale = detectedLocale\n                        return true\n                      }\n                      return false\n                    })\n                  ) {\n                    // remove the locale item from the match\n                    if (isCatchAll) {\n                      ;(val as string[]).splice(0, 1)\n                    }\n\n                    // the value is only a locale item and\n                    // shouldn't be added\n                    return isCatchAll ? val.length === 0 : true\n                  }\n                }\n                return false\n              }\n\n              if (routeKeyNames.every((name) => obj[name])) {\n                return routeKeyNames.reduce((prev, keyName) => {\n                  const paramName = routeKeys?.[keyName]\n\n                  if (paramName && !filterLocaleItem(obj[keyName])) {\n                    prev[groups[paramName].pos] = obj[keyName]\n                  }\n                  return prev\n                }, {} as any)\n              }\n\n              return Object.keys(obj).reduce((prev, key) => {\n                if (!filterLocaleItem(obj[key])) {\n                  return Object.assign(prev, {\n                    [key]: obj[key],\n                  })\n                }\n                return prev\n              }, {})\n            },\n          },\n          groups,\n        }\n      })() as any\n    )(req.headers['x-now-route-matches'] as string) as ParsedUrlQuery\n  }\n\n  function interpolateDynamicPath(pathname: string, params: ParsedUrlQuery) {\n    if (!defaultRouteRegex) return pathname\n\n    for (const param of Object.keys(defaultRouteRegex.groups)) {\n      const { optional, repeat } = defaultRouteRegex.groups[param]\n      let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n      if (optional) {\n        builtParam = `[${builtParam}]`\n      }\n\n      const paramIdx = pathname!.indexOf(builtParam)\n\n      if (paramIdx > -1) {\n        let paramValue: string\n\n        if (Array.isArray(params[param])) {\n          paramValue = (params[param] as string[]).join('/')\n        } else {\n          paramValue = params[param] as string\n        }\n\n        pathname =\n          pathname.substr(0, paramIdx) +\n          encodeURI(paramValue || '') +\n          pathname.substr(paramIdx + builtParam.length)\n      }\n    }\n\n    return pathname\n  }\n\n  function normalizeVercelUrl(req: IncomingMessage, trustQuery: boolean) {\n    // make sure to normalize req.url on Vercel to strip dynamic params\n    // from the query which are added during routing\n    if (pageIsDynamic && trustQuery && defaultRouteRegex) {\n      const _parsedUrl = parseUrl(req.url!, true)\n      delete (_parsedUrl as any).search\n\n      for (const param of Object.keys(defaultRouteRegex.groups)) {\n        delete _parsedUrl.query[param]\n      }\n      req.url = formatUrl(_parsedUrl)\n    }\n  }\n\n  function normalizeDynamicRouteParams(params: ParsedUrlQuery) {\n    let hasValidParams = true\n    if (!defaultRouteRegex) return { params, hasValidParams }\n\n    params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {\n      let value: string | string[] | undefined = params[key]\n\n      // if the value matches the default value we can't rely\n      // on the parsed params, this is used to signal if we need\n      // to parse x-now-route-matches or not\n      const isDefaultValue = Array.isArray(value)\n        ? value.every((val, idx) => val === defaultRouteMatches![key][idx])\n        : value === defaultRouteMatches![key]\n\n      if (isDefaultValue || typeof value === 'undefined') {\n        hasValidParams = false\n      }\n\n      // non-provided optional values should be undefined so normalize\n      // them to undefined\n      if (\n        defaultRouteRegex!.groups[key].optional &&\n        (!value ||\n          (Array.isArray(value) &&\n            value.length === 1 &&\n            // fallback optional catch-all SSG pages have\n            // [[...paramName]] for the root path on Vercel\n            (value[0] === 'index' || value[0] === `[[...${key}]]`)))\n      ) {\n        value = undefined\n        delete params[key]\n      }\n\n      // query values from the proxy aren't already split into arrays\n      // so make sure to normalize catch-all values\n      if (\n        value &&\n        typeof value === 'string' &&\n        defaultRouteRegex!.groups[key].repeat\n      ) {\n        value = value.split('/')\n      }\n\n      if (value) {\n        prev[key] = value\n      }\n      return prev\n    }, {} as ParsedUrlQuery)\n\n    return {\n      params,\n      hasValidParams,\n    }\n  }\n\n  function handleLocale(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery,\n    routeNoAssetPath: string,\n    shouldNotRedirect: boolean\n  ) {\n    if (!i18n) return\n\n    let defaultLocale = i18n.defaultLocale\n    let detectedLocale = detectLocaleCookie(req, i18n.locales)\n    let acceptPreferredLocale =\n      i18n.localeDetection !== false\n        ? accept.language(req.headers['accept-language'], i18n.locales)\n        : detectedLocale\n\n    const { host } = req.headers || {}\n    // remove port from host and remove port if present\n    const hostname = host && host.split(':')[0].toLowerCase()\n\n    const detectedDomain = detectDomainLocale(i18n.domains, hostname)\n    if (detectedDomain) {\n      defaultLocale = detectedDomain.defaultLocale\n      detectedLocale = defaultLocale\n    }\n\n    // if not domain specific locale use accept-language preferred\n    detectedLocale = detectedLocale || acceptPreferredLocale\n\n    let localeDomainRedirect\n    const localePathResult = normalizeLocalePath(\n      parsedUrl.pathname!,\n      i18n.locales\n    )\n\n    routeNoAssetPath = normalizeLocalePath(routeNoAssetPath, i18n.locales)\n      .pathname\n\n    if (localePathResult.detectedLocale) {\n      detectedLocale = localePathResult.detectedLocale\n      req.url = formatUrl({\n        ...parsedUrl,\n        pathname: localePathResult.pathname,\n      })\n      ;(req as any).__nextStrippedLocale = true\n      parsedUrl.pathname = localePathResult.pathname\n    }\n\n    // If a detected locale is a domain specific locale and we aren't already\n    // on that domain and path prefix redirect to it to prevent duplicate\n    // content from multiple domains\n    if (detectedDomain) {\n      const localeToCheck = localePathResult.detectedLocale\n        ? detectedLocale\n        : acceptPreferredLocale\n\n      const matchedDomain = detectDomainLocale(\n        i18n.domains,\n        undefined,\n        localeToCheck\n      )\n\n      if (matchedDomain && matchedDomain.domain !== detectedDomain.domain) {\n        localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${\n          matchedDomain.domain\n        }/${localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck}`\n      }\n    }\n\n    const denormalizedPagePath = denormalizePagePath(parsedUrl.pathname || '/')\n    const detectedDefaultLocale =\n      !detectedLocale ||\n      detectedLocale.toLowerCase() === defaultLocale.toLowerCase()\n    const shouldStripDefaultLocale = false\n    // detectedDefaultLocale &&\n    // denormalizedPagePath.toLowerCase() === \\`/\\${i18n.defaultLocale.toLowerCase()}\\`\n\n    const shouldAddLocalePrefix =\n      !detectedDefaultLocale && denormalizedPagePath === '/'\n\n    detectedLocale = detectedLocale || i18n.defaultLocale\n\n    if (\n      !shouldNotRedirect &&\n      !req.headers[vercelHeader] &&\n      i18n.localeDetection !== false &&\n      (localeDomainRedirect ||\n        shouldAddLocalePrefix ||\n        shouldStripDefaultLocale)\n    ) {\n      // set the NEXT_LOCALE cookie when a user visits the default locale\n      // with the locale prefix so that they aren't redirected back to\n      // their accept-language preferred locale\n      if (shouldStripDefaultLocale && acceptPreferredLocale !== defaultLocale) {\n        const previous = res.getHeader('set-cookie')\n\n        res.setHeader('set-cookie', [\n          ...(typeof previous === 'string'\n            ? [previous]\n            : Array.isArray(previous)\n            ? previous\n            : []),\n          cookie.serialize('NEXT_LOCALE', defaultLocale, {\n            httpOnly: true,\n            path: '/',\n          }),\n        ])\n      }\n\n      res.setHeader(\n        'Location',\n        formatUrl({\n          // make sure to include any query values when redirecting\n          ...parsedUrl,\n          pathname: localeDomainRedirect\n            ? localeDomainRedirect\n            : shouldStripDefaultLocale\n            ? basePath || '/'\n            : `${basePath}/${detectedLocale}`,\n        })\n      )\n      res.statusCode = TEMPORARY_REDIRECT_STATUS\n      res.end()\n      return\n    }\n\n    detectedLocale =\n      localePathResult.detectedLocale ||\n      (detectedDomain && detectedDomain.defaultLocale) ||\n      defaultLocale\n\n    return {\n      defaultLocale,\n      detectedLocale,\n      routeNoAssetPath,\n    }\n  }\n\n  return {\n    handleLocale,\n    handleRewrites,\n    handleBasePath,\n    defaultRouteRegex,\n    normalizeVercelUrl,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    interpolateDynamicPath,\n    getParamsFromRouteMatches,\n    normalizeDynamicRouteParams,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}