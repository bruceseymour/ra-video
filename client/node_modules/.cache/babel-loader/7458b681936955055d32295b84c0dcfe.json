{"ast":null,"code":"/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst {\n  nextNode,\n  insertAfter,\n  createElement,\n  firstChildByTag\n} = require('../NodeUtils');\n\nconst {\n  findMetaViewport\n} = require('../HtmlDomHelper');\n\nconst {\n  AMP_FORMATS,\n  AMP_CACHE_HOST\n} = require('../AmpConstants');\n\nconst BIND_SHORT_FORM_PREFIX = 'bind';\nconst AMP_BIND_DATA_ATTRIBUTE_PREFIX = 'data-amp-bind-';\nconst DEFAULT_FORMAT = 'AMP'; // Some AMP component don't bring their own tag, but enable new attributes on other\n// elements. Most are included in the AMP validation rules, but some are not. These\n// need to be defined manually here.\n\nconst manualAttributeToExtensionMapping = new Map([['mask', 'amp-inputmask'], ['lightbox', 'amp-lightbox-gallery']]);\nconst manualExtensions = Array.from(manualAttributeToExtensionMapping.values());\n/**\n * Extension Auto Importer - this transformer auto imports all missing AMP extensions.\n *\n * The importer analyzes the HTML source code and identifies missing AMP extension imports\n * using multiple strategies:\n *\n * - use validation rules to map used AMP tags to required AMP extensions.\n * - use validation rules to map used AMP attributes to required AMP extensions.\n * - manually specifiy attribute to extension mappings if this information is not available in the\n *   validation rules.\n * - mnullay implement AMP extension detection for a few corner cases.\n *\n * This importer also enables a shortcode `bindtext` instead of `data-amp-bind-text` for specifying\n * AMP bindings when the square bracket notation (`[text]`) is not available. To avoid accidently\n * rewriting non-AMP attributes, the transformer uses the AMP validation rules to only rename bindable\n * attributes as specified in the validation rules.\n *\n * This transformer supports the following option:\n *\n * - `format: [AMP|AMP4EMAIL|AMP4ADS]` - specifies the AMP format. Defaults to `AMP`.\n * - `autoExtensionImport: [true|false]` - set to `false` to disable the auto extension import. Default to `true`.\n */\n\nclass AutoExtensionImporter {\n  constructor(config) {\n    this.enabled = config.autoExtensionImport !== false;\n    this.format = config.format || DEFAULT_FORMAT;\n    this.log_ = config.log.tag('AutoExtensionImporter');\n    this.experimentBindAttributeEnabled = config.experimentBindAttribute === true;\n    this.extensionVersions = config.extensionVersions || {};\n  }\n  /**\n   * @private\n   */\n\n\n  createExtensionsSpec(params) {\n    const rules = params.validatorRules; // Map extension names to info required for generating the extension imports\n\n    const extensionsMap = new Map();\n\n    for (const ext of rules.extensions) {\n      if (ext.htmlFormat.includes(this.format)) {\n        extensionsMap.set(ext.name, {\n          name: ext.name,\n          type: ext.extensionType === 'CUSTOM_TEMPLATE' ? 'custom-template' : 'custom-element',\n          version: ext.version.filter(v => v !== 'latest')\n        });\n      }\n    } // Maps tags (e.g. amp-state) to their extension (e.g. amp-bind)\n\n\n    const tagToExtensionsMapping = new Map(); // Maps tags to their extension specific allowed attributes\n    // (e.g. amp-img => amp-fx => amp-fx-collection)\n\n    const tagToAttributeMapping = new Map(); // Maps tags to their bindable attributes (e.g. div => text)\n\n    const tagToBindAttributeMapping = new Map(); // Iterate over all available tags\n\n    for (const tag of rules.getTagsForFormat(this.format)) {\n      const tagName = tag.tagName.toLowerCase(); // Map amp tags to their required extension(s)\n\n      if (tagName.startsWith('amp-')) {\n        // HACK: some tags define multiple validation rules for attribute based imports\n        // e.g. amp-carousel, amp-carousel[lightbox]\n        // these are handled differently, so we filter them out here\n        let requiresExtension = tag.requiresExtension || [];\n        requiresExtension = requiresExtension.filter(ext => !manualExtensions.includes(ext));\n        tagToExtensionsMapping.set(tagName, requiresExtension);\n      } // Collects all bindable attributes\n\n\n      const bindableAttributes = new Set(); // Process the tag specific attributes\n\n      for (const attribute of tag.attrs) {\n        // Hack: fix missing attribute dependencies (e.g. amp-img => lightbox => amp-lightbox-gallery)\n        if (manualAttributeToExtensionMapping.has(attribute.name)) {\n          attribute.requiresExtension = [manualAttributeToExtensionMapping.get(attribute.name)];\n        } // Map attributes to tags and extensions (e.g. amp-img => amp-fx => amp-fx-collection)\n\n\n        if (attribute.requiresExtension && attribute.requiresExtension.length > 0) {\n          const attributeMapping = tagToAttributeMapping.get(tagName) || [];\n          attributeMapping.push(attribute);\n          tagToAttributeMapping.set(tagName, attributeMapping);\n        } // Maps tags to bindable attributes which are named `[text]`\n\n\n        if (attribute.name.startsWith('[')) {\n          bindableAttributes.add(attribute.name.substring(1, attribute.name.length - 1));\n        }\n      }\n\n      tagToBindAttributeMapping.set(tagName, bindableAttributes);\n    }\n\n    return {\n      extensionsMap,\n      tagToExtensionsMapping,\n      tagToAttributeMapping,\n      tagToBindAttributeMapping\n    };\n  }\n\n  async transform(root, params) {\n    if (!this.enabled) {\n      return;\n    }\n\n    if (!params.validatorRules) {\n      this.log_.error('Missing validation rules, cannot auto import extensions');\n      return;\n    }\n\n    if (!this.extensionSpec_) {\n      this.extensionSpec_ = this.createExtensionsSpec(params);\n    }\n\n    if (!AMP_FORMATS.includes(this.format)) {\n      this.log_.error('Unsupported AMPHTML format', this.format);\n      return;\n    }\n\n    const html = firstChildByTag(root, 'html');\n    if (!html) return;\n    const head = firstChildByTag(html, 'head');\n    if (!head) return;\n    const body = firstChildByTag(html, 'body');\n    if (!body) return; // Extensions which need to be imported\n\n    const extensionsToImport = new Set(); // Keep track of existing extensions imports to avoid duplicates\n\n    const existingImports = new Set(); // Some AMP components need to be detected in the head (e.g. amp-access)\n\n    this.findExistingExtensionsAndExtensionsToImportInHead_(head, extensionsToImport, existingImports); // Most AMP components can be detected in the body\n\n    await this.findExtensionsToImportInBody_(body, extensionsToImport);\n\n    if (extensionsToImport.length === 0) {\n      // Nothing to do\n      return;\n    } // We use this for adding new import elements to the header\n\n\n    const referenceNode = findMetaViewport(head); // Use cdn.ampproject.org as default, RewriteUrlTransformer will change this in case of self-hosting\n\n    const host = AMP_CACHE_HOST;\n\n    for (const extensionName of extensionsToImport) {\n      if (existingImports.has(extensionName)) {\n        continue;\n      }\n\n      const extension = this.extensionSpec_.extensionsMap.get(extensionName.trim());\n      this.log_.debug('auto importing', extensionName); // Use the latest version by default\n\n      let version = extension.version[extension.version.length - 1]; // Let user override default\n\n      if (this.extensionVersions[extensionName]) {\n        version = this.extensionVersions[extensionName];\n      }\n\n      const extensionImportAttribs = {\n        async: '',\n        src: `${host}/v0/${extensionName}-${version}.js`\n      };\n      extensionImportAttribs[extension.type] = extensionName;\n      const extensionImport = createElement('script', extensionImportAttribs);\n      insertAfter(head, extensionImport, referenceNode);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  findExistingExtensionsAndExtensionsToImportInHead_(head, extensionsToImport, existingImports) {\n    let node = head;\n\n    while (node) {\n      // Detect any existing extension imports\n      const customElement = this.getCustomElement_(node);\n\n      if (customElement) {\n        existingImports.add(customElement);\n      } // Explicitly detect amp-access via the script tag in the header to be able to handle amp-access extensions\n      else if (node.tagName === 'script' && node.attribs['id'] === 'amp-access') {\n          extensionsToImport.add('amp-access');\n          extensionsToImport.add('amp-analytics');\n          const jsonData = this.getJson(node);\n\n          if (jsonData.vendor === 'laterpay') {\n            extensionsToImport.add('amp-access-laterpay');\n          } // Explicitly detect amp-subscriptions via the script tag in the header to be able to handle amp-subscriptions extensions\n\n        } else if (node.tagName === 'script' && node.attribs['id'] === 'amp-subscriptions') {\n          extensionsToImport.add('amp-subscriptions');\n          extensionsToImport.add('amp-analytics');\n          const jsonData = this.getJson(node);\n\n          if (jsonData.services && jsonData.services.length) {\n            for (const service of jsonData.services) {\n              if (service.serviceId === 'subscribe.google.com') {\n                extensionsToImport.add('amp-subscriptions-google');\n              }\n            }\n          }\n        }\n\n      node = nextNode(node);\n    }\n  }\n\n  getJson(node) {\n    for (const child of node.children || []) {\n      if (!child.data) {\n        continue;\n      }\n\n      try {\n        return JSON.parse(child.data);\n      } catch (error) {\n        this.log_.error('Could not parse JSON in <script id=\"amp-access\">', error.message);\n      }\n    }\n\n    return {};\n  }\n  /**\n   * @private\n   */\n\n\n  async findExtensionsToImportInBody_(body, extensionsToImport) {\n    let node = body;\n\n    while (node !== null) {\n      if (node.tagName) {\n        this.addRequiredExtensionByTag_(node, extensionsToImport);\n        this.addRequiredExtensionByAttributes_(node, extensionsToImport);\n      }\n\n      node = nextNode(node);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  addRequiredExtensionByTag_(node, allRequiredExtensions) {\n    // Check for required extensions by tag name\n    const requiredExtensions = this.extensionSpec_.tagToExtensionsMapping.get(node.tagName);\n\n    if (requiredExtensions) {\n      requiredExtensions.forEach(ext => allRequiredExtensions.add(ext));\n    } // Add custom templates (e.g. amp-mustache)\n\n\n    if (node.tagName === 'template' && node.attribs.type) {\n      allRequiredExtensions.add(node.attribs.type);\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  addRequiredExtensionByAttributes_(node, allRequiredExtensions) {\n    if (!node.tagName || !node.attribs) {\n      return;\n    } // Look for element attributes indicating AMP components (e.g. amp-fx)\n\n\n    const tagToAttributeMapping = this.extensionSpec_.tagToAttributeMapping;\n    const attributesForTag = tagToAttributeMapping.get(node.tagName) || [];\n    attributesForTag.forEach(attribute => {\n      if (node.attribs[attribute.name] !== undefined) {\n        attribute.requiresExtension.forEach(ext => {\n          allRequiredExtensions.add(ext);\n        });\n      }\n    }); // Look for forms\n\n    if (node.tagName === 'form') {\n      allRequiredExtensions.add('amp-form');\n    } // Check for amp-bind attribute bindings\n\n\n    const tagToBindAttributeMapping = this.extensionSpec_.tagToBindAttributeMapping;\n    const attributeNames = Object.keys(node.attribs);\n\n    if (attributeNames.some(a => a.startsWith('[') || a.startsWith(AMP_BIND_DATA_ATTRIBUTE_PREFIX))) {\n      allRequiredExtensions.add('amp-bind');\n    } // EXPERIMENTAL FEATURE: Rewrite short-form `bindtext` to `data-amp-bind-text`\n    // to avoid false-positives we check for each tag only the\n    // supported bindable attributes (e.g. for a div only bindtext, but not bindvalue).\n\n\n    if (this.experimentBindAttributeEnabled) {\n      const ampBindAttrs = tagToBindAttributeMapping.get(node.tagName); // true if we need to import amp-bind\n\n      let usesAmpBind = false;\n\n      for (const attributeName of attributeNames) {\n        if (!attributeName.startsWith(BIND_SHORT_FORM_PREFIX)) {\n          continue;\n        }\n\n        const attributeNameWithoutBindPrefix = attributeName.substring(BIND_SHORT_FORM_PREFIX.length); // Rename attribute from bindx to data-amp-bind-x\n\n        if (ampBindAttrs.has(attributeNameWithoutBindPrefix)) {\n          const newAttributeName = `${AMP_BIND_DATA_ATTRIBUTE_PREFIX}${attributeNameWithoutBindPrefix}`;\n          node.attribs[newAttributeName] = node.attribs[attributeName];\n          delete node.attribs[attributeName];\n          usesAmpBind = true;\n        }\n\n        if (usesAmpBind) {\n          allRequiredExtensions.add('amp-bind');\n        }\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  getCustomElement_(scriptNode) {\n    if (scriptNode.tagName !== 'script') {\n      return '';\n    }\n\n    const customElement = scriptNode.attribs['custom-element'] || scriptNode.attribs['custom-template'] || '';\n\n    if (!customElement) {\n      return '';\n    }\n\n    if (!customElement.startsWith('amp-')) {\n      return '';\n    }\n\n    return customElement;\n  }\n\n}\n\nmodule.exports = AutoExtensionImporter;","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/lib/transformers/AutoExtensionImporter.js"],"names":["nextNode","insertAfter","createElement","firstChildByTag","require","findMetaViewport","AMP_FORMATS","AMP_CACHE_HOST","BIND_SHORT_FORM_PREFIX","AMP_BIND_DATA_ATTRIBUTE_PREFIX","DEFAULT_FORMAT","manualAttributeToExtensionMapping","Map","manualExtensions","Array","from","values","AutoExtensionImporter","constructor","config","enabled","autoExtensionImport","format","log_","log","tag","experimentBindAttributeEnabled","experimentBindAttribute","extensionVersions","createExtensionsSpec","params","rules","validatorRules","extensionsMap","ext","extensions","htmlFormat","includes","set","name","type","extensionType","version","filter","v","tagToExtensionsMapping","tagToAttributeMapping","tagToBindAttributeMapping","getTagsForFormat","tagName","toLowerCase","startsWith","requiresExtension","bindableAttributes","Set","attribute","attrs","has","get","length","attributeMapping","push","add","substring","transform","root","error","extensionSpec_","html","head","body","extensionsToImport","existingImports","findExistingExtensionsAndExtensionsToImportInHead_","findExtensionsToImportInBody_","referenceNode","host","extensionName","extension","trim","debug","extensionImportAttribs","async","src","extensionImport","node","customElement","getCustomElement_","attribs","jsonData","getJson","vendor","services","service","serviceId","child","children","data","JSON","parse","message","addRequiredExtensionByTag_","addRequiredExtensionByAttributes_","allRequiredExtensions","requiredExtensions","forEach","attributesForTag","undefined","attributeNames","Object","keys","some","a","ampBindAttrs","usesAmpBind","attributeName","attributeNameWithoutBindPrefix","newAttributeName","scriptNode","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst {nextNode, insertAfter, createElement, firstChildByTag} = require('../NodeUtils');\nconst {findMetaViewport} = require('../HtmlDomHelper');\nconst {AMP_FORMATS, AMP_CACHE_HOST} = require('../AmpConstants');\n\nconst BIND_SHORT_FORM_PREFIX = 'bind';\nconst AMP_BIND_DATA_ATTRIBUTE_PREFIX = 'data-amp-bind-';\nconst DEFAULT_FORMAT = 'AMP';\n\n// Some AMP component don't bring their own tag, but enable new attributes on other\n// elements. Most are included in the AMP validation rules, but some are not. These\n// need to be defined manually here.\nconst manualAttributeToExtensionMapping = new Map([\n  ['mask', 'amp-inputmask'],\n  ['lightbox', 'amp-lightbox-gallery'],\n]);\nconst manualExtensions = Array.from(manualAttributeToExtensionMapping.values());\n\n/**\n * Extension Auto Importer - this transformer auto imports all missing AMP extensions.\n *\n * The importer analyzes the HTML source code and identifies missing AMP extension imports\n * using multiple strategies:\n *\n * - use validation rules to map used AMP tags to required AMP extensions.\n * - use validation rules to map used AMP attributes to required AMP extensions.\n * - manually specifiy attribute to extension mappings if this information is not available in the\n *   validation rules.\n * - mnullay implement AMP extension detection for a few corner cases.\n *\n * This importer also enables a shortcode `bindtext` instead of `data-amp-bind-text` for specifying\n * AMP bindings when the square bracket notation (`[text]`) is not available. To avoid accidently\n * rewriting non-AMP attributes, the transformer uses the AMP validation rules to only rename bindable\n * attributes as specified in the validation rules.\n *\n * This transformer supports the following option:\n *\n * - `format: [AMP|AMP4EMAIL|AMP4ADS]` - specifies the AMP format. Defaults to `AMP`.\n * - `autoExtensionImport: [true|false]` - set to `false` to disable the auto extension import. Default to `true`.\n */\nclass AutoExtensionImporter {\n  constructor(config) {\n    this.enabled = config.autoExtensionImport !== false;\n    this.format = config.format || DEFAULT_FORMAT;\n    this.log_ = config.log.tag('AutoExtensionImporter');\n    this.experimentBindAttributeEnabled = config.experimentBindAttribute === true;\n    this.extensionVersions = config.extensionVersions || {};\n  }\n\n  /**\n   * @private\n   */\n  createExtensionsSpec(params) {\n    const rules = params.validatorRules;\n    // Map extension names to info required for generating the extension imports\n    const extensionsMap = new Map();\n    for (const ext of rules.extensions) {\n      if (ext.htmlFormat.includes(this.format)) {\n        extensionsMap.set(ext.name, {\n          name: ext.name,\n          type: ext.extensionType === 'CUSTOM_TEMPLATE' ? 'custom-template' : 'custom-element',\n          version: ext.version.filter((v) => v !== 'latest'),\n        });\n      }\n    }\n    // Maps tags (e.g. amp-state) to their extension (e.g. amp-bind)\n    const tagToExtensionsMapping = new Map();\n    // Maps tags to their extension specific allowed attributes\n    // (e.g. amp-img => amp-fx => amp-fx-collection)\n    const tagToAttributeMapping = new Map();\n    // Maps tags to their bindable attributes (e.g. div => text)\n    const tagToBindAttributeMapping = new Map();\n    // Iterate over all available tags\n    for (const tag of rules.getTagsForFormat(this.format)) {\n      const tagName = tag.tagName.toLowerCase();\n      // Map amp tags to their required extension(s)\n      if (tagName.startsWith('amp-')) {\n        // HACK: some tags define multiple validation rules for attribute based imports\n        // e.g. amp-carousel, amp-carousel[lightbox]\n        // these are handled differently, so we filter them out here\n        let requiresExtension = tag.requiresExtension || [];\n        requiresExtension = requiresExtension.filter((ext) => !manualExtensions.includes(ext));\n        tagToExtensionsMapping.set(tagName, requiresExtension);\n      }\n      // Collects all bindable attributes\n      const bindableAttributes = new Set();\n      // Process the tag specific attributes\n      for (const attribute of tag.attrs) {\n        // Hack: fix missing attribute dependencies (e.g. amp-img => lightbox => amp-lightbox-gallery)\n        if (manualAttributeToExtensionMapping.has(attribute.name)) {\n          attribute.requiresExtension = [manualAttributeToExtensionMapping.get(attribute.name)];\n        }\n        // Map attributes to tags and extensions (e.g. amp-img => amp-fx => amp-fx-collection)\n        if (attribute.requiresExtension && attribute.requiresExtension.length > 0) {\n          const attributeMapping = tagToAttributeMapping.get(tagName) || [];\n          attributeMapping.push(attribute);\n          tagToAttributeMapping.set(tagName, attributeMapping);\n        }\n        // Maps tags to bindable attributes which are named `[text]`\n        if (attribute.name.startsWith('[')) {\n          bindableAttributes.add(attribute.name.substring(1, attribute.name.length - 1));\n        }\n      }\n      tagToBindAttributeMapping.set(tagName, bindableAttributes);\n    }\n    return {\n      extensionsMap,\n      tagToExtensionsMapping,\n      tagToAttributeMapping,\n      tagToBindAttributeMapping,\n    };\n  }\n\n  async transform(root, params) {\n    if (!this.enabled) {\n      return;\n    }\n    if (!params.validatorRules) {\n      this.log_.error('Missing validation rules, cannot auto import extensions');\n      return;\n    }\n    if (!this.extensionSpec_) {\n      this.extensionSpec_ = this.createExtensionsSpec(params);\n    }\n    if (!AMP_FORMATS.includes(this.format)) {\n      this.log_.error('Unsupported AMPHTML format', this.format);\n      return;\n    }\n    const html = firstChildByTag(root, 'html');\n    if (!html) return;\n    const head = firstChildByTag(html, 'head');\n    if (!head) return;\n    const body = firstChildByTag(html, 'body');\n    if (!body) return;\n\n    // Extensions which need to be imported\n    const extensionsToImport = new Set();\n    // Keep track of existing extensions imports to avoid duplicates\n    const existingImports = new Set();\n\n    // Some AMP components need to be detected in the head (e.g. amp-access)\n    this.findExistingExtensionsAndExtensionsToImportInHead_(\n      head,\n      extensionsToImport,\n      existingImports\n    );\n\n    // Most AMP components can be detected in the body\n    await this.findExtensionsToImportInBody_(body, extensionsToImport);\n\n    if (extensionsToImport.length === 0) {\n      // Nothing to do\n      return;\n    }\n\n    // We use this for adding new import elements to the header\n    const referenceNode = findMetaViewport(head);\n\n    // Use cdn.ampproject.org as default, RewriteUrlTransformer will change this in case of self-hosting\n    const host = AMP_CACHE_HOST;\n    for (const extensionName of extensionsToImport) {\n      if (existingImports.has(extensionName)) {\n        continue;\n      }\n      const extension = this.extensionSpec_.extensionsMap.get(extensionName.trim());\n      this.log_.debug('auto importing', extensionName);\n      // Use the latest version by default\n      let version = extension.version[extension.version.length - 1];\n      // Let user override default\n      if (this.extensionVersions[extensionName]) {\n        version = this.extensionVersions[extensionName];\n      }\n      const extensionImportAttribs = {\n        async: '',\n        src: `${host}/v0/${extensionName}-${version}.js`,\n      };\n      extensionImportAttribs[extension.type] = extensionName;\n      const extensionImport = createElement('script', extensionImportAttribs);\n      insertAfter(head, extensionImport, referenceNode);\n    }\n  }\n\n  /**\n   * @private\n   */\n  findExistingExtensionsAndExtensionsToImportInHead_(head, extensionsToImport, existingImports) {\n    let node = head;\n    while (node) {\n      // Detect any existing extension imports\n      const customElement = this.getCustomElement_(node);\n      if (customElement) {\n        existingImports.add(customElement);\n      }\n      // Explicitly detect amp-access via the script tag in the header to be able to handle amp-access extensions\n      else if (node.tagName === 'script' && node.attribs['id'] === 'amp-access') {\n        extensionsToImport.add('amp-access');\n        extensionsToImport.add('amp-analytics');\n        const jsonData = this.getJson(node);\n        if (jsonData.vendor === 'laterpay') {\n          extensionsToImport.add('amp-access-laterpay');\n        }\n        // Explicitly detect amp-subscriptions via the script tag in the header to be able to handle amp-subscriptions extensions\n      } else if (node.tagName === 'script' && node.attribs['id'] === 'amp-subscriptions') {\n        extensionsToImport.add('amp-subscriptions');\n        extensionsToImport.add('amp-analytics');\n        const jsonData = this.getJson(node);\n        if (jsonData.services && jsonData.services.length) {\n          for (const service of jsonData.services) {\n            if (service.serviceId === 'subscribe.google.com') {\n              extensionsToImport.add('amp-subscriptions-google');\n            }\n          }\n        }\n      }\n      node = nextNode(node);\n    }\n  }\n\n  getJson(node) {\n    for (const child of node.children || []) {\n      if (!child.data) {\n        continue;\n      }\n      try {\n        return JSON.parse(child.data);\n      } catch (error) {\n        this.log_.error('Could not parse JSON in <script id=\"amp-access\">', error.message);\n      }\n    }\n    return {};\n  }\n\n  /**\n   * @private\n   */\n  async findExtensionsToImportInBody_(body, extensionsToImport) {\n    let node = body;\n    while (node !== null) {\n      if (node.tagName) {\n        this.addRequiredExtensionByTag_(node, extensionsToImport);\n        this.addRequiredExtensionByAttributes_(node, extensionsToImport);\n      }\n      node = nextNode(node);\n    }\n  }\n\n  /**\n   * @private\n   */\n  addRequiredExtensionByTag_(node, allRequiredExtensions) {\n    // Check for required extensions by tag name\n    const requiredExtensions = this.extensionSpec_.tagToExtensionsMapping.get(node.tagName);\n    if (requiredExtensions) {\n      requiredExtensions.forEach((ext) => allRequiredExtensions.add(ext));\n    }\n    // Add custom templates (e.g. amp-mustache)\n    if (node.tagName === 'template' && node.attribs.type) {\n      allRequiredExtensions.add(node.attribs.type);\n    }\n  }\n\n  /**\n   * @private\n   */\n  addRequiredExtensionByAttributes_(node, allRequiredExtensions) {\n    if (!node.tagName || !node.attribs) {\n      return;\n    }\n    // Look for element attributes indicating AMP components (e.g. amp-fx)\n    const tagToAttributeMapping = this.extensionSpec_.tagToAttributeMapping;\n    const attributesForTag = tagToAttributeMapping.get(node.tagName) || [];\n    attributesForTag.forEach((attribute) => {\n      if (node.attribs[attribute.name] !== undefined) {\n        attribute.requiresExtension.forEach((ext) => {\n          allRequiredExtensions.add(ext);\n        });\n      }\n    });\n    // Look for forms\n    if (node.tagName === 'form') {\n      allRequiredExtensions.add('amp-form');\n    }\n    // Check for amp-bind attribute bindings\n    const tagToBindAttributeMapping = this.extensionSpec_.tagToBindAttributeMapping;\n    const attributeNames = Object.keys(node.attribs);\n    if (\n      attributeNames.some((a) => a.startsWith('[') || a.startsWith(AMP_BIND_DATA_ATTRIBUTE_PREFIX))\n    ) {\n      allRequiredExtensions.add('amp-bind');\n    }\n\n    // EXPERIMENTAL FEATURE: Rewrite short-form `bindtext` to `data-amp-bind-text`\n    // to avoid false-positives we check for each tag only the\n    // supported bindable attributes (e.g. for a div only bindtext, but not bindvalue).\n    if (this.experimentBindAttributeEnabled) {\n      const ampBindAttrs = tagToBindAttributeMapping.get(node.tagName);\n      // true if we need to import amp-bind\n      let usesAmpBind = false;\n      for (const attributeName of attributeNames) {\n        if (!attributeName.startsWith(BIND_SHORT_FORM_PREFIX)) {\n          continue;\n        }\n        const attributeNameWithoutBindPrefix = attributeName.substring(\n          BIND_SHORT_FORM_PREFIX.length\n        );\n\n        // Rename attribute from bindx to data-amp-bind-x\n        if (ampBindAttrs.has(attributeNameWithoutBindPrefix)) {\n          const newAttributeName = `${AMP_BIND_DATA_ATTRIBUTE_PREFIX}${attributeNameWithoutBindPrefix}`;\n          node.attribs[newAttributeName] = node.attribs[attributeName];\n          delete node.attribs[attributeName];\n          usesAmpBind = true;\n        }\n        if (usesAmpBind) {\n          allRequiredExtensions.add('amp-bind');\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  getCustomElement_(scriptNode) {\n    if (scriptNode.tagName !== 'script') {\n      return '';\n    }\n    const customElement =\n      scriptNode.attribs['custom-element'] || scriptNode.attribs['custom-template'] || '';\n    if (!customElement) {\n      return '';\n    }\n    if (!customElement.startsWith('amp-')) {\n      return '';\n    }\n    return customElement;\n  }\n}\n\nmodule.exports = AutoExtensionImporter;\n"]},"metadata":{},"sourceType":"script"}