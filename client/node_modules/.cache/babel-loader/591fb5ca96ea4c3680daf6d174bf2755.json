{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.ServerlessPlugin = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst isWebpack5 = parseInt(_webpack.default.version) === 5;\nconst GraphHelpers = isWebpack5 ? undefined : require('webpack/lib/GraphHelpers');\n/**\n* Makes sure there are no dynamic chunks when the target is serverless\n* The dynamic chunks are integrated back into their parent chunk\n* This is to make sure there is a single render bundle instead of that bundle importing dynamic chunks\n*/\n\nclass ServerlessPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap('ServerlessPlugin', compilation => {\n      const hook = isWebpack5 ? compilation.hooks.optimizeChunks : compilation.hooks.optimizeChunksBasic;\n      hook.tap('ServerlessPlugin', chunks => {\n        for (const chunk of chunks) {\n          // If chunk is not an entry point skip them\n          if (!chunk.hasEntryModule()) {\n            continue;\n          } // Async chunks are usages of import() for example\n\n\n          const dynamicChunks = chunk.getAllAsyncChunks();\n\n          for (const dynamicChunk of dynamicChunks) {\n            if (isWebpack5) {\n              // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n              for (const module of compilation.chunkGraph.getChunkModulesIterable(chunk)) {\n                // Add module back into the entry chunk\n                chunk.addModule(module);\n              }\n\n              continue;\n            }\n\n            for (const module of dynamicChunk.modulesIterable) {\n              // Webpack 4 has separate GraphHelpers\n              GraphHelpers.connectChunkAndModule(chunk, module);\n            }\n          }\n        }\n      });\n    });\n  }\n\n}\n\nexports.ServerlessPlugin = ServerlessPlugin;","map":{"version":3,"sources":["../../../../build/webpack/plugins/serverless-plugin.ts"],"names":["isWebpack5","parseInt","webpack","GraphHelpers","require","ServerlessPlugin","apply","compiler","compilation","hook","chunks","chunk","dynamicChunks","dynamicChunk"],"mappings":";;;;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;;;;;AACA;;AAAA,MAAMA,UAAU,GAAGC,QAAQ,CAACC,QAAAA,CAAAA,OAAAA,CAATD,OAAQ,CAARA,KAAnB,CAAA;AAEA,MAAME,YAAY,GAAGH,UAAU,GAAA,SAAA,GAE3BI,OAAO,CAFX,0BAEW,CAFX;AAIA;AACA;AACA;AACA;AACA;;AAEO,MAAMC,gBAAN,CAAuB;AAC5BC,EAAAA,KAAK,CAAA,QAAA,EAAqB;AACxBC,IAAAA,QAAQ,CAARA,KAAAA,CAAAA,WAAAA,CAAAA,GAAAA,CAAAA,kBAAAA,EAAoDC,WAAD,IAAiB;AAClE,YAAMC,IAAI,GAAGT,UAAU,GACnBQ,WAAW,CAAXA,KAAAA,CADmB,cAAA,GAEnBA,WAAW,CAAXA,KAAAA,CAFJ,mBAAA;AAIA,MAAA,IAAI,CAAJ,GAAA,CAAA,kBAAA,EAA8BE,MAAD,IAAY;AACvC,aAAK,MAAL,KAAA,IAAA,MAAA,EAA4B;AAC1B;AACA,cAAI,CAACC,KAAK,CAAV,cAAKA,EAAL,EAA6B;AAC3B;AAGF,WAN0B,CAM1B;;;AACA,gBAAMC,aAAa,GAAGD,KAAK,CAA3B,iBAAsBA,EAAtB;;AACA,eAAK,MAAL,YAAA,IAAA,aAAA,EAA0C;AACxC,gBAAA,UAAA,EAAgB;AACd;AACA,mBAAK,MAAL,MAAA,IAAqBH,WAAW,CAAXA,UAAAA,CAAAA,uBAAAA,CAArB,KAAqBA,CAArB,EAEG;AACD;AACAG,gBAAAA,KAAK,CAALA,SAAAA,CAAAA,MAAAA;AAEF;;AAAA;AAGF;;AAAA,iBAAK,MAAL,MAAA,IAAqBE,YAAY,CAAjC,eAAA,EAAmD;AACjD;AACAV,cAAAA,YAAY,CAAZA,qBAAAA,CAAAA,KAAAA,EAAAA,MAAAA;AAEH;AACF;AACF;AA3BD,OAAA;AALFI,KAAAA;AAF0B;;AAAA","sourcesContent":["import { Compiler } from 'webpack'\nimport webpack from 'webpack'\nconst isWebpack5 = parseInt(webpack.version!) === 5\n\nconst GraphHelpers = isWebpack5\n  ? undefined\n  : require('webpack/lib/GraphHelpers')\n\n/**\n * Makes sure there are no dynamic chunks when the target is serverless\n * The dynamic chunks are integrated back into their parent chunk\n * This is to make sure there is a single render bundle instead of that bundle importing dynamic chunks\n */\n\nexport class ServerlessPlugin {\n  apply(compiler: Compiler) {\n    compiler.hooks.compilation.tap('ServerlessPlugin', (compilation) => {\n      const hook = isWebpack5\n        ? compilation.hooks.optimizeChunks\n        : compilation.hooks.optimizeChunksBasic\n\n      hook.tap('ServerlessPlugin', (chunks) => {\n        for (const chunk of chunks) {\n          // If chunk is not an entry point skip them\n          if (!chunk.hasEntryModule()) {\n            continue\n          }\n\n          // Async chunks are usages of import() for example\n          const dynamicChunks = chunk.getAllAsyncChunks()\n          for (const dynamicChunk of dynamicChunks) {\n            if (isWebpack5) {\n              // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n              for (const module of compilation.chunkGraph.getChunkModulesIterable(\n                chunk\n              )) {\n                // Add module back into the entry chunk\n                chunk.addModule(module)\n              }\n              continue\n            }\n\n            for (const module of dynamicChunk.modulesIterable) {\n              // Webpack 4 has separate GraphHelpers\n              GraphHelpers.connectChunkAndModule(chunk, module)\n            }\n          }\n        }\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}