{"ast":null,"code":"/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst {\n  Element,\n  DataNode\n} = require('domhandler');\n\nconst {\n  removeElement,\n  append,\n  prepend\n} = require('domutils');\n/**\n * Depth-first walk through the DOM tree.\n * @param {Node} node\n */\n\n\nconst nextNode = function (node) {\n  // Walk downwards if there are children\n  const firstChild = node.firstChild;\n\n  if (firstChild) {\n    return firstChild;\n  } // Return the direct sibling or walk upwards until we find a node with sibling\n\n\n  let tmp = node;\n\n  while (tmp) {\n    const next = tmp.nextSibling;\n\n    if (next) {\n      return next;\n    } // Walk upwards\n\n\n    tmp = tmp.parent;\n  } // We are done\n\n\n  return null;\n};\n/**\n * Remove node from DOM\n *\n * @param {Node} node\n */\n\n\nconst remove = function (node) {\n  removeElement(node);\n};\n/**\n * Appends a node to the given parent\n *\n * @param {Node} parent\n * @param {Node} node\n */\n\n\nconst appendChild = function (elem, child) {\n  if (!child) {\n    return;\n  }\n\n  child.parent = elem;\n\n  if (elem.children.push(child) !== 1) {\n    const sibling = elem.children[elem.children.length - 2];\n    sibling.next = child;\n    child.prev = sibling;\n    child.next = null;\n  }\n};\n/**\n * Inserts a Node before the reference node. If referenceNode is null, inserts the node as\n * the first child.\n *\n * @param {Node} newNode the node to be inserted.\n * @param {Node} referenceNode the reference node, where the new node will be added before.\n */\n\n\nconst insertBefore = function (parent, newNode, referenceNode) {\n  if (referenceNode) {\n    prepend(referenceNode, newNode);\n    return;\n  } // if referenceNode.nextSibling is null, referenceNode is the last child. newNode is inserted\n  // as the last element.\n\n\n  appendChild(parent, newNode);\n};\n/**\n * Inserts a Node after the reference node. If referenceNode is null, inserts the node as\n * the first child.\n *\n * @param {Node} newNode the node to be inserted.\n * @param {Node} referenceNode the reference node, where the new node will be added after.\n */\n\n\nconst insertAfter = function (parent, newNode, referenceNode) {\n  if (referenceNode) {\n    append(referenceNode, newNode);\n    return;\n  } // if referenceNode.nextSibling is null, referenceNode is the last child. newNode is inserted\n  // as the last element.\n\n\n  appendChild(parent, newNode);\n};\n/**\n * Appends all nodes to the given parent\n *\n * @param {Node} parent\n * @param {Array<Node>} node\n */\n\n\nconst appendAll = function (node, nodes) {\n  if (!nodes) {\n    return;\n  }\n\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    appendChild(node, nodes[i]);\n  }\n};\n/**\n * Returns the first child with the given tag name\n *\n * @param {Node} node\n * @param {String} tagName\n */\n\n\nconst firstChildByTag = function (node, tagName) {\n  if (!node || !node.children) {\n    return null;\n  }\n\n  return node.children.find(child => child.tagName && child.tagName === tagName);\n}; //\n\n/**\n * Returns true if an attribute with the given name exists\n * @param {Node} node\n * @param {String} attributeName\n */\n\n\nconst hasAttribute = function (node, attribute) {\n  if (!node.attribs) return false;\n  return attribute in node.attribs;\n};\n/**\n * Move a node from one parent to another\n * @param {Node} nodeToMove\n * @param {Node} newParent\n */\n\n\nconst move = function (nodeToMove, newParent) {\n  remove(nodeToMove);\n  appendChild(newParent, nodeToMove);\n};\n/**\n * Creates a new element\n *\n * @param {string} tagName\n * @param {obj} [attribs={}]\n * @returns {Node} new node\n */\n\n\nconst createElement = (tagName, attribs) => {\n  return new Element(tagName, attribs);\n};\n/**\n * Inserts text\n *\n * @param {Node} node\n * @param {string} the text\n */\n\n\nconst insertText = (node, text) => {\n  const dataNode = new DataNode('text', text);\n  appendChild(node, dataNode);\n};\n/**\n * Creates a new doctype\n */\n\n\nconst createDocType = () => {\n  const result = new DataNode('directive', '!doctype html');\n  return result;\n};\n\nmodule.exports = {\n  appendChild,\n  appendAll,\n  insertAfter,\n  nextNode,\n  remove,\n  createDocType,\n  createElement,\n  insertText,\n  insertBefore,\n  hasAttribute,\n  firstChildByTag,\n  move\n};","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/lib/NodeUtils.js"],"names":["Element","DataNode","require","removeElement","append","prepend","nextNode","node","firstChild","tmp","next","nextSibling","parent","remove","appendChild","elem","child","children","push","sibling","length","prev","insertBefore","newNode","referenceNode","insertAfter","appendAll","nodes","i","len","firstChildByTag","tagName","find","hasAttribute","attribute","attribs","move","nodeToMove","newParent","createElement","insertText","text","dataNode","createDocType","result","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nconst {Element, DataNode} = require('domhandler');\nconst {removeElement, append, prepend} = require('domutils');\n\n/**\n * Depth-first walk through the DOM tree.\n * @param {Node} node\n */\nconst nextNode = function (node) {\n  // Walk downwards if there are children\n  const firstChild = node.firstChild;\n  if (firstChild) {\n    return firstChild;\n  }\n  // Return the direct sibling or walk upwards until we find a node with sibling\n  let tmp = node;\n  while (tmp) {\n    const next = tmp.nextSibling;\n    if (next) {\n      return next;\n    }\n    // Walk upwards\n    tmp = tmp.parent;\n  }\n  // We are done\n  return null;\n};\n\n/**\n * Remove node from DOM\n *\n * @param {Node} node\n */\nconst remove = function (node) {\n  removeElement(node);\n};\n\n/**\n * Appends a node to the given parent\n *\n * @param {Node} parent\n * @param {Node} node\n */\nconst appendChild = function (elem, child) {\n  if (!child) {\n    return;\n  }\n  child.parent = elem;\n\n  if (elem.children.push(child) !== 1) {\n    const sibling = elem.children[elem.children.length - 2];\n    sibling.next = child;\n    child.prev = sibling;\n    child.next = null;\n  }\n};\n\n/**\n * Inserts a Node before the reference node. If referenceNode is null, inserts the node as\n * the first child.\n *\n * @param {Node} newNode the node to be inserted.\n * @param {Node} referenceNode the reference node, where the new node will be added before.\n */\nconst insertBefore = function (parent, newNode, referenceNode) {\n  if (referenceNode) {\n    prepend(referenceNode, newNode);\n    return;\n  }\n  // if referenceNode.nextSibling is null, referenceNode is the last child. newNode is inserted\n  // as the last element.\n  appendChild(parent, newNode);\n};\n\n/**\n * Inserts a Node after the reference node. If referenceNode is null, inserts the node as\n * the first child.\n *\n * @param {Node} newNode the node to be inserted.\n * @param {Node} referenceNode the reference node, where the new node will be added after.\n */\nconst insertAfter = function (parent, newNode, referenceNode) {\n  if (referenceNode) {\n    append(referenceNode, newNode);\n    return;\n  }\n  // if referenceNode.nextSibling is null, referenceNode is the last child. newNode is inserted\n  // as the last element.\n  appendChild(parent, newNode);\n};\n\n/**\n * Appends all nodes to the given parent\n *\n * @param {Node} parent\n * @param {Array<Node>} node\n */\nconst appendAll = function (node, nodes) {\n  if (!nodes) {\n    return;\n  }\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    appendChild(node, nodes[i]);\n  }\n};\n\n/**\n * Returns the first child with the given tag name\n *\n * @param {Node} node\n * @param {String} tagName\n */\nconst firstChildByTag = function (node, tagName) {\n  if (!node || !node.children) {\n    return null;\n  }\n  return node.children.find((child) => child.tagName && child.tagName === tagName);\n};\n\n//\n/**\n * Returns true if an attribute with the given name exists\n * @param {Node} node\n * @param {String} attributeName\n */\nconst hasAttribute = function (node, attribute) {\n  if (!node.attribs) return false;\n  return attribute in node.attribs;\n};\n\n/**\n * Move a node from one parent to another\n * @param {Node} nodeToMove\n * @param {Node} newParent\n */\nconst move = function (nodeToMove, newParent) {\n  remove(nodeToMove);\n  appendChild(newParent, nodeToMove);\n};\n\n/**\n * Creates a new element\n *\n * @param {string} tagName\n * @param {obj} [attribs={}]\n * @returns {Node} new node\n */\nconst createElement = (tagName, attribs) => {\n  return new Element(tagName, attribs);\n};\n\n/**\n * Inserts text\n *\n * @param {Node} node\n * @param {string} the text\n */\nconst insertText = (node, text) => {\n  const dataNode = new DataNode('text', text);\n  appendChild(node, dataNode);\n};\n\n/**\n * Creates a new doctype\n */\nconst createDocType = () => {\n  const result = new DataNode('directive', '!doctype html');\n  return result;\n};\n\nmodule.exports = {\n  appendChild,\n  appendAll,\n  insertAfter,\n  nextNode,\n  remove,\n  createDocType,\n  createElement,\n  insertText,\n  insertBefore,\n  hasAttribute,\n  firstChildByTag,\n  move,\n};\n"]},"metadata":{},"sourceType":"script"}