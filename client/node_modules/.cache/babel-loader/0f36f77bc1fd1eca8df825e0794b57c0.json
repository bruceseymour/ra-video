{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.encryptWithSecret = encryptWithSecret;\nexports.decryptWithSecret = decryptWithSecret;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Background:\n// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure\n\n\nconst CIPHER_ALGORITHM = `aes-256-gcm`,\n      CIPHER_KEY_LENGTH = 32,\n      // https://stackoverflow.com/a/28307668/4397028\nCIPHER_IV_LENGTH = 16,\n      // https://stackoverflow.com/a/28307668/4397028\nCIPHER_TAG_LENGTH = 16,\n      CIPHER_SALT_LENGTH = 64;\nconst PBKDF2_ITERATIONS = 100000; // https://support.1password.com/pbkdf2/\n\nfunction encryptWithSecret(secret, data) {\n  const iv = _crypto.default.randomBytes(CIPHER_IV_LENGTH);\n\n  const salt = _crypto.default.randomBytes(CIPHER_SALT_LENGTH); // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n\n\n  const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);\n\n  const cipher = _crypto.default.createCipheriv(CIPHER_ALGORITHM, key, iv);\n\n  const encrypted = Buffer.concat([cipher.update(data, `utf8`), cipher.final()]); // https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag\n\n  const tag = cipher.getAuthTag();\n  return Buffer.concat([// Data as required by:\n  // Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n  // IV: https://nodejs.org/api/crypto.html#crypto_class_decipher\n  // Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer\n  salt, iv, tag, encrypted]).toString(`hex`);\n}\n\nfunction decryptWithSecret(secret, encryptedData) {\n  const buffer = Buffer.from(encryptedData, `hex`);\n  const salt = buffer.slice(0, CIPHER_SALT_LENGTH);\n  const iv = buffer.slice(CIPHER_SALT_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH);\n  const tag = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);\n  const encrypted = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH); // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n\n  const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);\n\n  const decipher = _crypto.default.createDecipheriv(CIPHER_ALGORITHM, key, iv);\n\n  decipher.setAuthTag(tag);\n  return decipher.update(encrypted) + decipher.final(`utf8`);\n}","map":{"version":3,"sources":["../../../next-server/server/crypto-utils.ts"],"names":["CIPHER_ALGORITHM","CIPHER_KEY_LENGTH","CIPHER_IV_LENGTH","CIPHER_TAG_LENGTH","CIPHER_SALT_LENGTH","PBKDF2_ITERATIONS","iv","crypto","salt","key","cipher","encrypted","Buffer","tag","buffer","decipher"],"mappings":";;;;;;AAAA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;;;;;AAEA,C,CAAA;AACA;;;AAEA,MAAMA,gBAAgB,GAAtB,aAAA;AAAA,MACEC,iBAAiB,GADnB,EAAA;AAAA,MAC0B;AACxBC,gBAAgB,GAFlB,EAAA;AAAA,MAEyB;AACvBC,iBAAiB,GAHnB,EAAA;AAAA,MAIEC,kBAAkB,GAJpB,EAAA;AAMA,MAAMC,iBAAiB,GAAvB,MAAA,C,CAAkC;;AAE3B,SAAA,iBAAA,CAAA,MAAA,EAAA,IAAA,EAAiE;AACtE,QAAMC,EAAE,GAAGC,OAAAA,CAAAA,OAAAA,CAAAA,WAAAA,CAAX,gBAAWA,CAAX;;AACA,QAAMC,IAAI,GAAGD,OAAAA,CAAAA,OAAAA,CAAAA,WAAAA,CAAb,kBAAaA,CAAb,CAFsE,CAItE;;;AACA,QAAME,GAAG,GAAGF,OAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,MAAAA,EAAAA,IAAAA,EAAAA,iBAAAA,EAAAA,iBAAAA,EAAZ,QAAYA,CAAZ;;AAQA,QAAMG,MAAM,GAAGH,OAAAA,CAAAA,OAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,EAAAA,GAAAA,EAAf,EAAeA,CAAf;;AACA,QAAMI,SAAS,GAAGC,MAAM,CAANA,MAAAA,CAAc,CAACF,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAD,MAACA,CAAD,EAA8BA,MAAM,CAApE,KAA8DA,EAA9B,CAAdE,CAAlB,CAdsE,CAgBtE;;AACA,QAAMC,GAAG,GAAGH,MAAM,CAAlB,UAAYA,EAAZ;AAEA,SAAO,MAAM,CAAN,MAAA,CAAc,CACnB;AACA;AACA;AACA;AAJmB,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAd,SAAc,CAAd,EAAA,QAAA,CAAP,KAAO,CAAP;AAYK;;AAAA,SAAA,iBAAA,CAAA,MAAA,EAAA,aAAA,EAGG;AACR,QAAMI,MAAM,GAAGF,MAAM,CAANA,IAAAA,CAAAA,aAAAA,EAAf,KAAeA,CAAf;AAEA,QAAMJ,IAAI,GAAGM,MAAM,CAANA,KAAAA,CAAAA,CAAAA,EAAb,kBAAaA,CAAb;AACA,QAAMR,EAAE,GAAGQ,MAAM,CAANA,KAAAA,CAAAA,kBAAAA,EAETV,kBAAkB,GAFpB,gBAAWU,CAAX;AAIA,QAAMD,GAAG,GAAGC,MAAM,CAANA,KAAAA,CACVV,kBAAkB,GADRU,gBAAAA,EAEVV,kBAAkB,GAAlBA,gBAAAA,GAFF,iBAAYU,CAAZ;AAIA,QAAMH,SAAS,GAAGG,MAAM,CAANA,KAAAA,CAChBV,kBAAkB,GAAlBA,gBAAAA,GADF,iBAAkBU,CAAlB,CAZQ,CAgBR;;AACA,QAAML,GAAG,GAAGF,OAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,MAAAA,EAAAA,IAAAA,EAAAA,iBAAAA,EAAAA,iBAAAA,EAAZ,QAAYA,CAAZ;;AAQA,QAAMQ,QAAQ,GAAGR,OAAAA,CAAAA,OAAAA,CAAAA,gBAAAA,CAAAA,gBAAAA,EAAAA,GAAAA,EAAjB,EAAiBA,CAAjB;;AACAQ,EAAAA,QAAQ,CAARA,UAAAA,CAAAA,GAAAA;AAEA,SAAOA,QAAQ,CAARA,MAAAA,CAAAA,SAAAA,IAA6BA,QAAQ,CAARA,KAAAA,CAApC,MAAoCA,CAApC;AACD","sourcesContent":["import crypto from 'crypto'\n\n// Background:\n// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure\n\nconst CIPHER_ALGORITHM = `aes-256-gcm`,\n  CIPHER_KEY_LENGTH = 32, // https://stackoverflow.com/a/28307668/4397028\n  CIPHER_IV_LENGTH = 16, // https://stackoverflow.com/a/28307668/4397028\n  CIPHER_TAG_LENGTH = 16,\n  CIPHER_SALT_LENGTH = 64\n\nconst PBKDF2_ITERATIONS = 100_000 // https://support.1password.com/pbkdf2/\n\nexport function encryptWithSecret(secret: Buffer, data: string): string {\n  const iv = crypto.randomBytes(CIPHER_IV_LENGTH)\n  const salt = crypto.randomBytes(CIPHER_SALT_LENGTH)\n\n  // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n  const key = crypto.pbkdf2Sync(\n    secret,\n    salt,\n    PBKDF2_ITERATIONS,\n    CIPHER_KEY_LENGTH,\n    `sha512`\n  )\n\n  const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, key, iv)\n  const encrypted = Buffer.concat([cipher.update(data, `utf8`), cipher.final()])\n\n  // https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag\n  const tag = cipher.getAuthTag()\n\n  return Buffer.concat([\n    // Data as required by:\n    // Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n    // IV: https://nodejs.org/api/crypto.html#crypto_class_decipher\n    // Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer\n    salt,\n    iv,\n    tag,\n    encrypted,\n  ]).toString(`hex`)\n}\n\nexport function decryptWithSecret(\n  secret: Buffer,\n  encryptedData: string\n): string {\n  const buffer = Buffer.from(encryptedData, `hex`)\n\n  const salt = buffer.slice(0, CIPHER_SALT_LENGTH)\n  const iv = buffer.slice(\n    CIPHER_SALT_LENGTH,\n    CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH\n  )\n  const tag = buffer.slice(\n    CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH,\n    CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH\n  )\n  const encrypted = buffer.slice(\n    CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH\n  )\n\n  // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest\n  const key = crypto.pbkdf2Sync(\n    secret,\n    salt,\n    PBKDF2_ITERATIONS,\n    CIPHER_KEY_LENGTH,\n    `sha512`\n  )\n\n  const decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, key, iv)\n  decipher.setAuthTag(tag)\n\n  return decipher.update(encrypted) + decipher.final(`utf8`)\n}\n"]},"metadata":{},"sourceType":"script"}