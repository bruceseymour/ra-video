{"ast":null,"code":"'use strict';\n\nlet MapGenerator = require('./map-generator');\n\nlet {\n  isClean\n} = require('./symbols');\n\nlet stringify = require('./stringify');\n\nlet warnOnce = require('./warn-once');\n\nlet Result = require('./result');\n\nlet parse = require('./parse');\n\nlet Root = require('./root');\n\nconst TYPE_TO_CLASS_NAME = {\n  root: 'Root',\n  atrule: 'AtRule',\n  rule: 'Rule',\n  decl: 'Declaration',\n  comment: 'Comment'\n};\nconst CHILDREN = 0;\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\nfunction getEvents(node) {\n  let key = false;\n  let type = TYPE_TO_CLASS_NAME[node.type];\n\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase();\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase();\n  }\n\n  if (key && node.append) {\n    return [type, type + '-' + key, CHILDREN, type + 'Exit', type + 'Exit-' + key];\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit'];\n  } else {\n    return [type, type + 'Exit'];\n  }\n}\n\nfunction toStack(node) {\n  let events;\n\n  if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit'];\n  } else {\n    events = getEvents(node);\n  }\n\n  return {\n    node,\n    events,\n    eventIndex: 0,\n    visitors: [],\n    visitorIndex: 0,\n    iterator: 0\n  };\n}\n\nfunction cleanMarks(node) {\n  node[isClean] = false;\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i));\n  return node;\n}\n\nlet postcss = {};\n\nclass LazyResult {\n  constructor(processor, css, opts) {\n    this.stringified = false;\n    this.processed = false;\n    let root;\n\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = cleanMarks(css);\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root);\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      let parser = parse;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.processed = true;\n        this.error = error;\n      }\n    }\n\n    this.result = new Result(processor, root, opts);\n    this.helpers = { ...postcss,\n      result: this.result,\n      postcss\n    };\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin,\n          ...plugin.prepare(this.result)\n        };\n      } else {\n        return plugin;\n      }\n    });\n  }\n\n  get processor() {\n    return this.result.processor;\n  }\n\n  get opts() {\n    return this.result.opts;\n  }\n\n  get css() {\n    return this.stringify().css;\n  }\n\n  get content() {\n    return this.stringify().content;\n  }\n\n  get map() {\n    return this.stringify().map;\n  }\n\n  get root() {\n    return this.sync().root;\n  }\n\n  get messages() {\n    return this.sync().messages;\n  }\n\n  warnings() {\n    return this.sync().warnings();\n  }\n\n  toString() {\n    return this.css;\n  }\n\n  then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected);\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally);\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error);\n    if (this.processed) return Promise.resolve(this.result);\n\n    if (!this.processing) {\n      this.processing = this.runAsync();\n    }\n\n    return this.processing;\n  }\n\n  sync() {\n    if (this.error) throw this.error;\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw this.getAsyncError();\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin);\n\n      if (isPromise(promise)) {\n        throw this.getAsyncError();\n      }\n    }\n\n    this.prepareVisitors();\n\n    if (this.hasListener) {\n      let root = this.result.root;\n\n      while (!root[isClean]) {\n        root[isClean] = true;\n        this.walkSync(root);\n      }\n\n      if (this.listeners.OnceExit) {\n        this.visitSync(this.listeners.OnceExit, root);\n      }\n    }\n\n    return this.result;\n  }\n\n  stringify() {\n    if (this.error) throw this.error;\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    let opts = this.result.opts;\n    let str = stringify;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    let map = new MapGenerator(str, this.result.root, this.result.opts);\n    let data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  }\n\n  walkSync(node) {\n    node[isClean] = true;\n    let events = getEvents(node);\n\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child);\n          });\n        }\n      } else {\n        let visitors = this.listeners[event];\n\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return;\n        }\n      }\n    }\n  }\n\n  visitSync(visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin;\n      let promise;\n\n      try {\n        promise = visitor(node, this.helpers);\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf);\n      }\n\n      if (node.type !== 'root' && !node.parent) return true;\n\n      if (isPromise(promise)) {\n        throw this.getAsyncError();\n      }\n    }\n  }\n\n  runOnRoot(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        return plugin.Once(this.result.root, this.helpers);\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result);\n      }\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  getAsyncError() {\n    throw new Error('Use process(css).then(cb) to work with async plugins');\n  }\n\n  handleError(error, node) {\n    let plugin = this.result.lastPlugin;\n\n    try {\n      if (node) node.addToError(error);\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin;\n          let pluginVer = plugin.postcssVersion;\n          let runtimeVer = this.result.processor.version;\n          let a = pluginVer.split('.');\n          let b = runtimeVer.split('.');\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n          }\n        }\n      }\n    } catch (err) {\n      // istanbul ignore next\n      if (console && console.error) console.error(err);\n    }\n\n    return error;\n  }\n\n  async runAsync() {\n    this.plugin = 0;\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i];\n      let promise = this.runOnRoot(plugin);\n\n      if (isPromise(promise)) {\n        try {\n          await promise;\n        } catch (error) {\n          throw this.handleError(error);\n        }\n      }\n    }\n\n    this.prepareVisitors();\n\n    if (this.hasListener) {\n      let root = this.result.root;\n\n      while (!root[isClean]) {\n        root[isClean] = true;\n        let stack = [toStack(root)];\n\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack);\n\n          if (isPromise(promise)) {\n            try {\n              await promise;\n            } catch (e) {\n              let node = stack[stack.length - 1].node;\n              throw this.handleError(e, node);\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin;\n\n          try {\n            await visitor(root, this.helpers);\n          } catch (e) {\n            throw this.handleError(e);\n          }\n        }\n      }\n    }\n\n    this.processed = true;\n    return this.stringify();\n  }\n\n  prepareVisitors() {\n    this.listeners = {};\n\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = [];\n      this.listeners[type].push([plugin, cb]);\n    };\n\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let type of ['Root', 'Declaration', 'Rule', 'AtRule', 'Comment', 'DeclarationExit', 'RuleExit', 'AtRuleExit', 'CommentExit', 'RootExit', 'OnceExit']) {\n          if (typeof plugin[type] === 'object') {\n            for (let filter in plugin[type]) {\n              if (filter === '*') {\n                add(plugin, type, plugin[type][filter]);\n              } else {\n                add(plugin, type + '-' + filter.toLowerCase(), plugin[type][filter]);\n              }\n            }\n          } else if (typeof plugin[type] === 'function') {\n            add(plugin, type, plugin[type]);\n          }\n        }\n      }\n    }\n\n    this.hasListener = Object.keys(this.listeners).length > 0;\n  }\n\n  visitTick(stack) {\n    let visit = stack[stack.length - 1];\n    let {\n      node,\n      visitors\n    } = visit;\n\n    if (node.type !== 'root' && !node.parent) {\n      stack.pop();\n      return;\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex];\n      visit.visitorIndex += 1;\n\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = [];\n        visit.visitorIndex = 0;\n      }\n\n      this.result.lastPlugin = plugin;\n\n      try {\n        return visitor(node.toProxy(), this.helpers);\n      } catch (e) {\n        throw this.handleError(e, node);\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator;\n      let child;\n\n      while (child = node.nodes[node.indexes[iterator]]) {\n        node.indexes[iterator] += 1;\n\n        if (!child[isClean]) {\n          child[isClean] = true;\n          stack.push(toStack(child));\n          return;\n        }\n      }\n\n      visit.iterator = 0;\n      delete node.indexes[iterator];\n    }\n\n    let events = visit.events;\n\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex];\n      visit.eventIndex += 1;\n\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true;\n          visit.iterator = node.getIterator();\n        }\n\n        return;\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event];\n        return;\n      }\n    }\n\n    stack.pop();\n  }\n\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant;\n};\n\nmodule.exports = LazyResult;\nLazyResult.default = LazyResult;\nRoot.registerLazyResult(LazyResult);","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/next/node_modules/postcss/lib/lazy-result.js"],"names":["MapGenerator","require","isClean","stringify","warnOnce","Result","parse","Root","TYPE_TO_CLASS_NAME","root","atrule","rule","decl","comment","CHILDREN","isPromise","obj","then","getEvents","node","key","type","prop","toLowerCase","name","append","toStack","events","eventIndex","visitors","visitorIndex","iterator","cleanMarks","nodes","forEach","i","postcss","LazyResult","constructor","processor","css","opts","stringified","processed","map","inline","prev","parser","syntax","error","result","helpers","plugins","plugin","prepare","content","sync","messages","warnings","toString","onFulfilled","onRejected","process","env","NODE_ENV","async","catch","finally","onFinally","Promise","reject","resolve","processing","runAsync","getAsyncError","promise","runOnRoot","prepareVisitors","hasListener","walkSync","listeners","OnceExit","visitSync","str","stringifier","data","generate","event","each","child","toProxy","visitor","lastPlugin","e","handleError","proxyOf","parent","Once","Error","addToError","postcssPlugin","setMessage","postcssVersion","pluginName","pluginVer","runtimeVer","version","a","split","b","parseInt","console","err","length","stack","visitTick","add","cb","push","filter","Object","keys","visit","pop","indexes","getIterator","registerPostcss","dependant","module","exports","default","registerLazyResult"],"mappings":"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","sourcesContent":["'use strict'\n\nlet MapGenerator = require('./map-generator')\nlet { isClean } = require('./symbols')\nlet stringify = require('./stringify')\nlet warnOnce = require('./warn-once')\nlet Result = require('./result')\nlet parse = require('./parse')\nlet Root = require('./root')\n\nconst TYPE_TO_CLASS_NAME = {\n  root: 'Root',\n  atrule: 'AtRule',\n  rule: 'Rule',\n  decl: 'Declaration',\n  comment: 'Comment'\n}\n\nconst CHILDREN = 0\n\nfunction isPromise (obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\nfunction getEvents (node) {\n  let key = false\n  let type = TYPE_TO_CLASS_NAME[node.type]\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase()\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase()\n  }\n\n  if (key && node.append) {\n    return [\n      type,\n      type + '-' + key,\n      CHILDREN,\n      type + 'Exit',\n      type + 'Exit-' + key\n    ]\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit']\n  } else {\n    return [type, type + 'Exit']\n  }\n}\n\nfunction toStack (node) {\n  let events\n  if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit']\n  } else {\n    events = getEvents(node)\n  }\n\n  return {\n    node,\n    events,\n    eventIndex: 0,\n    visitors: [],\n    visitorIndex: 0,\n    iterator: 0\n  }\n}\n\nfunction cleanMarks (node) {\n  node[isClean] = false\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))\n  return node\n}\n\nlet postcss = {}\n\nclass LazyResult {\n  constructor (processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = cleanMarks(css)\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root)\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {}\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.processed = true\n        this.error = error\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n    this.helpers = { ...postcss, result: this.result, postcss }\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin, ...plugin.prepare(this.result) }\n      } else {\n        return plugin\n      }\n    })\n  }\n\n  get processor () {\n    return this.result.processor\n  }\n\n  get opts () {\n    return this.result.opts\n  }\n\n  get css () {\n    return this.stringify().css\n  }\n\n  get content () {\n    return this.stringify().content\n  }\n\n  get map () {\n    return this.stringify().map\n  }\n\n  get root () {\n    return this.sync().root\n  }\n\n  get messages () {\n    return this.sync().messages\n  }\n\n  warnings () {\n    return this.sync().warnings()\n  }\n\n  toString () {\n    return this.css\n  }\n\n  then (onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch (onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally (onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async () {\n    if (this.error) return Promise.reject(this.error)\n    if (this.processed) return Promise.resolve(this.result)\n    if (!this.processing) {\n      this.processing = this.runAsync()\n    }\n    return this.processing\n  }\n\n  sync () {\n    if (this.error) throw this.error\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw this.getAsyncError()\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        this.walkSync(root)\n      }\n      if (this.listeners.OnceExit) {\n        this.visitSync(this.listeners.OnceExit, root)\n      }\n    }\n\n    return this.result\n  }\n\n  stringify () {\n    if (this.error) throw this.error\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n\n  walkSync (node) {\n    node[isClean] = true\n    let events = getEvents(node)\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child)\n          })\n        }\n      } else {\n        let visitors = this.listeners[event]\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return\n        }\n      }\n    }\n  }\n\n  visitSync (visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin\n      let promise\n      try {\n        promise = visitor(node, this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf)\n      }\n      if (node.type !== 'root' && !node.parent) return true\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n  }\n\n  runOnRoot (plugin) {\n    this.result.lastPlugin = plugin\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        return plugin.Once(this.result.root, this.helpers)\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result)\n      }\n    } catch (error) {\n      throw this.handleError(error)\n    }\n  }\n\n  getAsyncError () {\n    throw new Error('Use process(css).then(cb) to work with async plugins')\n  }\n\n  handleError (error, node) {\n    let plugin = this.result.lastPlugin\n    try {\n      if (node) node.addToError(error)\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n                'version is ' +\n                runtimeVer +\n                ', but ' +\n                pluginName +\n                ' uses ' +\n                pluginVer +\n                '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      // istanbul ignore next\n      if (console && console.error) console.error(err)\n    }\n    return error\n  }\n\n  async runAsync () {\n    this.plugin = 0\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        try {\n          await promise\n        } catch (error) {\n          throw this.handleError(error)\n        }\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        let stack = [toStack(root)]\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack)\n          if (isPromise(promise)) {\n            try {\n              await promise\n            } catch (e) {\n              let node = stack[stack.length - 1].node\n              throw this.handleError(e, node)\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin\n          try {\n            await visitor(root, this.helpers)\n          } catch (e) {\n            throw this.handleError(e)\n          }\n        }\n      }\n    }\n\n    this.processed = true\n    return this.stringify()\n  }\n\n  prepareVisitors () {\n    this.listeners = {}\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = []\n      this.listeners[type].push([plugin, cb])\n    }\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let type of [\n          'Root',\n          'Declaration',\n          'Rule',\n          'AtRule',\n          'Comment',\n          'DeclarationExit',\n          'RuleExit',\n          'AtRuleExit',\n          'CommentExit',\n          'RootExit',\n          'OnceExit'\n        ]) {\n          if (typeof plugin[type] === 'object') {\n            for (let filter in plugin[type]) {\n              if (filter === '*') {\n                add(plugin, type, plugin[type][filter])\n              } else {\n                add(\n                  plugin,\n                  type + '-' + filter.toLowerCase(),\n                  plugin[type][filter]\n                )\n              }\n            }\n          } else if (typeof plugin[type] === 'function') {\n            add(plugin, type, plugin[type])\n          }\n        }\n      }\n    }\n    this.hasListener = Object.keys(this.listeners).length > 0\n  }\n\n  visitTick (stack) {\n    let visit = stack[stack.length - 1]\n    let { node, visitors } = visit\n\n    if (node.type !== 'root' && !node.parent) {\n      stack.pop()\n      return\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex]\n      visit.visitorIndex += 1\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = []\n        visit.visitorIndex = 0\n      }\n      this.result.lastPlugin = plugin\n      try {\n        return visitor(node.toProxy(), this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node)\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator\n      let child\n      while ((child = node.nodes[node.indexes[iterator]])) {\n        node.indexes[iterator] += 1\n        if (!child[isClean]) {\n          child[isClean] = true\n          stack.push(toStack(child))\n          return\n        }\n      }\n      visit.iterator = 0\n      delete node.indexes[iterator]\n    }\n\n    let events = visit.events\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex]\n      visit.eventIndex += 1\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true\n          visit.iterator = node.getIterator()\n        }\n        return\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event]\n        return\n      }\n    }\n    stack.pop()\n  }\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant\n}\n\nmodule.exports = LazyResult\nLazyResult.default = LazyResult\n\nRoot.registerLazyResult(LazyResult)\n"]},"metadata":{},"sourceType":"script"}