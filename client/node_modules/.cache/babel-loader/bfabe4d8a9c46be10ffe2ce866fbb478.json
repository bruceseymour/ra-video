{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.findPageFile = findPageFile;\n\nvar _path = require(\"path\");\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _isWriteable = require(\"../../build/is-writeable\");\n\nvar _log = require(\"../../build/output/log\");\n\nvar _fs = require(\"fs\");\n\nvar _normalizePagePath = require(\"../../next-server/server/normalize-page-path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nasync function isTrueCasePagePath(pagePath, pagesDir) {\n  const pageSegments = (0, _path.normalize)(pagePath).split(_path.sep).filter(Boolean);\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = (0, _path.join)(pagesDir, ...pageSegments.slice(0, i));\n    const parentDirEntries = await _fs.promises.readdir(segmentParentDir);\n    return parentDirEntries.includes(segment);\n  });\n  return (await Promise.all(segmentExistsPromises)).every(Boolean);\n}\n\nasync function findPageFile(rootDir, normalizedPagePath, pageExtensions) {\n  const foundPagePaths = [];\n  const page = (0, _normalizePagePath.denormalizePagePath)(normalizedPagePath);\n\n  for (const extension of pageExtensions) {\n    if (!normalizedPagePath.endsWith('/index')) {\n      const relativePagePath = `${page}.${extension}`;\n      const pagePath = (0, _path.join)(rootDir, relativePagePath);\n\n      if (await (0, _isWriteable.isWriteable)(pagePath)) {\n        foundPagePaths.push(relativePagePath);\n      }\n    }\n\n    const relativePagePathWithIndex = (0, _path.join)(page, `index.${extension}`);\n    const pagePathWithIndex = (0, _path.join)(rootDir, relativePagePathWithIndex);\n\n    if (await (0, _isWriteable.isWriteable)(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex);\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null;\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null;\n  }\n\n  if (foundPagePaths.length > 1) {\n    (0, _log.warn)(`Duplicate page detected. ${_chalk.default.cyan((0, _path.join)('pages', foundPagePaths[0]))} and ${_chalk.default.cyan((0, _path.join)('pages', foundPagePaths[1]))} both resolve to ${_chalk.default.cyan(normalizedPagePath)}.`);\n  }\n\n  return foundPagePaths[0];\n}","map":{"version":3,"sources":["../../../server/lib/find-page-file.ts"],"names":["pageSegments","pathSeparator","segmentExistsPromises","segmentParentDir","parentDirEntries","promises","Promise","foundPagePaths","page","normalizedPagePath","relativePagePath","extension","pagePath","relativePagePathWithIndex","pagePathWithIndex","isTrueCasePagePath","chalk"],"mappings":"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","sourcesContent":["import { join, sep as pathSeparator, normalize } from 'path'\nimport chalk from 'chalk'\nimport { isWriteable } from '../../build/is-writeable'\nimport { warn } from '../../build/output/log'\nimport { promises } from 'fs'\nimport { denormalizePagePath } from '../../next-server/server/normalize-page-path'\n\nasync function isTrueCasePagePath(pagePath: string, pagesDir: string) {\n  const pageSegments = normalize(pagePath).split(pathSeparator).filter(Boolean)\n\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = join(pagesDir, ...pageSegments.slice(0, i))\n    const parentDirEntries = await promises.readdir(segmentParentDir)\n    return parentDirEntries.includes(segment)\n  })\n\n  return (await Promise.all(segmentExistsPromises)).every(Boolean)\n}\n\nexport async function findPageFile(\n  rootDir: string,\n  normalizedPagePath: string,\n  pageExtensions: string[]\n): Promise<string | null> {\n  const foundPagePaths: string[] = []\n\n  const page = denormalizePagePath(normalizedPagePath)\n\n  for (const extension of pageExtensions) {\n    if (!normalizedPagePath.endsWith('/index')) {\n      const relativePagePath = `${page}.${extension}`\n      const pagePath = join(rootDir, relativePagePath)\n\n      if (await isWriteable(pagePath)) {\n        foundPagePaths.push(relativePagePath)\n      }\n    }\n\n    const relativePagePathWithIndex = join(page, `index.${extension}`)\n    const pagePathWithIndex = join(rootDir, relativePagePathWithIndex)\n    if (await isWriteable(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex)\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null\n  }\n\n  if (foundPagePaths.length > 1) {\n    warn(\n      `Duplicate page detected. ${chalk.cyan(\n        join('pages', foundPagePaths[0])\n      )} and ${chalk.cyan(\n        join('pages', foundPagePaths[1])\n      )} both resolve to ${chalk.cyan(normalizedPagePath)}.`\n    )\n  }\n\n  return foundPagePaths[0]\n}\n"]},"metadata":{},"sourceType":"script"}