{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.renderScriptError = renderScriptError;\nexports.default = void 0;\n\nvar _middleware = require(\"@next/react-dev-overlay/lib/middleware\");\n\nvar _hotMiddleware = require(\"./hot-middleware\");\n\nvar _path = require(\"path\");\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _entries = require(\"../build/entries\");\n\nvar _output = require(\"../build/output\");\n\nvar _webpackConfig = _interopRequireDefault(require(\"../build/webpack-config\"));\n\nvar _constants = require(\"../lib/constants\");\n\nvar _recursiveDelete = require(\"../lib/recursive-delete\");\n\nvar _constants2 = require(\"../next-server/lib/constants\");\n\nvar _router = require(\"../next-server/server/router\");\n\nvar _findPageFile = require(\"./lib/find-page-file\");\n\nvar _onDemandEntryHandler = _interopRequireWildcard(require(\"./on-demand-entry-handler\"));\n\nvar _normalizePagePath = require(\"../next-server/server/normalize-page-path\");\n\nvar _getRouteFromEntrypoint = _interopRequireDefault(require(\"../next-server/server/get-route-from-entrypoint\"));\n\nvar _isWriteable = require(\"../build/is-writeable\");\n\nvar _querystring = require(\"querystring\");\n\nvar _utils = require(\"../build/utils\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nasync function renderScriptError(res, error, {\n  verbose = true\n} = {}) {\n  // Asks CDNs and others to not to cache the errored page\n  res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n\n  if (error.code === 'ENOENT' || error.message === 'INVALID_BUILD_ID') {\n    res.statusCode = 404;\n    res.end('404 - Not Found');\n    return;\n  }\n\n  if (verbose) {\n    console.error(error.stack);\n  }\n\n  res.statusCode = 500;\n  res.end('500 - Internal Error');\n}\n\nfunction addCorsSupport(req, res) {\n  const isApiRoute = req.url.match(_constants.API_ROUTE); // API routes handle their own CORS headers\n\n  if (isApiRoute) {\n    return {\n      preflight: false\n    };\n  }\n\n  if (!req.headers.origin) {\n    return {\n      preflight: false\n    };\n  }\n\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET'); // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158\n\n  if (req.headers['access-control-request-headers']) {\n    res.setHeader('Access-Control-Allow-Headers', req.headers['access-control-request-headers']);\n  }\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    res.end();\n    return {\n      preflight: true\n    };\n  }\n\n  return {\n    preflight: false\n  };\n}\n\nconst matchNextPageBundleRequest = (0, _router.route)('/_next/static/chunks/pages/:path*.js(\\\\.map|)'); // Recursively look up the issuer till it ends up at the root\n\nfunction findEntryModule(issuer) {\n  if (issuer.issuer) {\n    return findEntryModule(issuer.issuer);\n  }\n\n  return issuer;\n}\n\nfunction erroredPages(compilation) {\n  const failedPages = {};\n\n  for (const error of compilation.errors) {\n    if (!error.origin) {\n      continue;\n    }\n\n    const entryModule = findEntryModule(error.origin);\n    const {\n      name\n    } = entryModule;\n\n    if (!name) {\n      continue;\n    } // Only pages have to be reloaded\n\n\n    if (!(0, _getRouteFromEntrypoint.default)(name)) {\n      continue;\n    }\n\n    const enhancedName = (0, _getRouteFromEntrypoint.default)(name);\n\n    if (!enhancedName) {\n      continue;\n    }\n\n    if (!failedPages[enhancedName]) {\n      failedPages[enhancedName] = [];\n    }\n\n    failedPages[enhancedName].push(error);\n  }\n\n  return failedPages;\n}\n\nclass HotReloader {\n  constructor(dir, {\n    config,\n    pagesDir,\n    buildId,\n    previewProps,\n    rewrites\n  }) {\n    this.dir = void 0;\n    this.buildId = void 0;\n    this.middlewares = void 0;\n    this.pagesDir = void 0;\n    this.webpackHotMiddleware = void 0;\n    this.config = void 0;\n    this.stats = void 0;\n    this.serverStats = void 0;\n    this.clientError = null;\n    this.serverError = null;\n    this.serverPrevDocumentHash = void 0;\n    this.prevChunkNames = void 0;\n    this.onDemandEntries = void 0;\n    this.previewProps = void 0;\n    this.watcher = void 0;\n    this.rewrites = void 0;\n    this.buildId = buildId;\n    this.dir = dir;\n    this.middlewares = [];\n    this.pagesDir = pagesDir;\n    this.webpackHotMiddleware = null;\n    this.stats = null;\n    this.serverStats = null;\n    this.serverPrevDocumentHash = null;\n    this.config = config;\n    this.previewProps = previewProps;\n    this.rewrites = rewrites;\n  }\n\n  async run(req, res, parsedUrl) {\n    // Usually CORS support is not needed for the hot-reloader (this is dev only feature)\n    // With when the app runs for multi-zones support behind a proxy,\n    // the current page is trying to access this URL via assetPrefix.\n    // That's when the CORS support is needed.\n    const {\n      preflight\n    } = addCorsSupport(req, res);\n\n    if (preflight) {\n      return {};\n    } // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js\n    // we have to compile the page using on-demand-entries, this middleware will handle doing that\n    // by adding the page to on-demand-entries, waiting till it's done\n    // and then the bundle will be served like usual by the actual route in server/index.js\n\n\n    const handlePageBundleRequest = async (pageBundleRes, parsedPageBundleUrl) => {\n      const {\n        pathname\n      } = parsedPageBundleUrl;\n      const params = matchNextPageBundleRequest(pathname);\n\n      if (!params) {\n        return {};\n      }\n\n      let decodedPagePath;\n\n      try {\n        decodedPagePath = `/${params.path.map(param => decodeURIComponent(param)).join('/')}`;\n      } catch (_) {\n        const err = new Error('failed to decode param');\n        err.code = 'DECODE_FAILED';\n        throw err;\n      }\n\n      const page = (0, _normalizePagePath.denormalizePagePath)(decodedPagePath);\n\n      if (page === '/_error' || _constants2.BLOCKED_PAGES.indexOf(page) === -1) {\n        try {\n          await this.ensurePage(page);\n        } catch (error) {\n          await renderScriptError(pageBundleRes, error);\n          return {\n            finished: true\n          };\n        }\n\n        const errors = await this.getCompilationErrors(page);\n\n        if (errors.length > 0) {\n          await renderScriptError(pageBundleRes, errors[0], {\n            verbose: false\n          });\n          return {\n            finished: true\n          };\n        }\n      }\n\n      return {};\n    };\n\n    const {\n      finished\n    } = await handlePageBundleRequest(res, parsedUrl);\n\n    for (const fn of this.middlewares) {\n      await new Promise((resolve, reject) => {\n        fn(req, res, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      });\n    }\n\n    return {\n      finished\n    };\n  }\n\n  async clean() {\n    return (0, _recursiveDelete.recursiveDelete)((0, _path.join)(this.dir, this.config.distDir), /^cache/);\n  }\n\n  async getWebpackConfig() {\n    const pagePaths = await Promise.all([(0, _findPageFile.findPageFile)(this.pagesDir, '/_app', this.config.pageExtensions), (0, _findPageFile.findPageFile)(this.pagesDir, '/_document', this.config.pageExtensions)]);\n    const pages = (0, _entries.createPagesMapping)(pagePaths.filter(i => i !== null), this.config.pageExtensions);\n    const entrypoints = (0, _entries.createEntrypoints)(pages, 'server', this.buildId, this.previewProps, this.config, []);\n    let additionalClientEntrypoints = {};\n    additionalClientEntrypoints[_constants2.CLIENT_STATIC_FILES_RUNTIME_AMP] = `./` + (0, _path.relative)(this.dir, (0, _path.join)(_constants.NEXT_PROJECT_ROOT_DIST_CLIENT, 'dev', 'amp-dev')).replace(/\\\\/g, '/');\n    additionalClientEntrypoints[_constants2.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH] = require.resolve(`@next/react-refresh-utils/runtime`);\n    return Promise.all([(0, _webpackConfig.default)(this.dir, {\n      dev: true,\n      isServer: false,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: this.rewrites,\n      entrypoints: { ...entrypoints.client,\n        ...additionalClientEntrypoints\n      }\n    }), (0, _webpackConfig.default)(this.dir, {\n      dev: true,\n      isServer: true,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: this.rewrites,\n      entrypoints: entrypoints.server\n    })]);\n  }\n\n  async start() {\n    await this.clean();\n    const configs = await this.getWebpackConfig();\n\n    for (const config of configs) {\n      const defaultEntry = config.entry;\n\n      config.entry = async (...args) => {\n        // @ts-ignore entry is always a functon\n        const entrypoints = await defaultEntry(...args);\n        const isClientCompilation = config.name === 'client';\n        await Promise.all(Object.keys(_onDemandEntryHandler.entries).map(async page => {\n          if (isClientCompilation && page.match(_constants.API_ROUTE)) {\n            return;\n          }\n\n          const {\n            serverBundlePath,\n            clientBundlePath,\n            absolutePagePath\n          } = _onDemandEntryHandler.entries[page];\n          const pageExists = await (0, _isWriteable.isWriteable)(absolutePagePath);\n\n          if (!pageExists) {\n            // page was removed\n            delete _onDemandEntryHandler.entries[page];\n            return;\n          }\n\n          _onDemandEntryHandler.entries[page].status = _onDemandEntryHandler.BUILDING;\n          const pageLoaderOpts = {\n            page,\n            absolutePagePath\n          };\n          entrypoints[isClientCompilation ? clientBundlePath : serverBundlePath] = isClientCompilation ? `next-client-pages-loader?${(0, _querystring.stringify)(pageLoaderOpts)}!` : absolutePagePath;\n        }));\n        return entrypoints;\n      };\n    }\n\n    const multiCompiler = (0, _webpack.default)(configs);\n    (0, _output.watchCompilers)(multiCompiler.compilers[0], multiCompiler.compilers[1]); // Watch for changes to client/server page files so we can tell when just\n    // the server file changes and trigger a reload for GS(S)P pages\n\n    const changedClientPages = new Set();\n    const changedServerPages = new Set();\n    const prevClientPageHashes = new Map();\n    const prevServerPageHashes = new Map();\n\n    const trackPageChanges = (pageHashMap, changedItems) => stats => {\n      stats.entrypoints.forEach((entry, key) => {\n        if (key.startsWith('pages/')) {\n          entry.chunks.forEach(chunk => {\n            if (chunk.id === key) {\n              const prevHash = pageHashMap.get(key);\n\n              if (prevHash && prevHash !== chunk.hash) {\n                changedItems.add(key);\n              }\n\n              pageHashMap.set(key, chunk.hash);\n            }\n          });\n        }\n      });\n    };\n\n    multiCompiler.compilers[0].hooks.emit.tap('NextjsHotReloaderForClient', trackPageChanges(prevClientPageHashes, changedClientPages));\n    multiCompiler.compilers[1].hooks.emit.tap('NextjsHotReloaderForServer', trackPageChanges(prevServerPageHashes, changedServerPages)); // This plugin watches for changes to _document.js and notifies the client side that it should reload the page\n\n    multiCompiler.compilers[1].hooks.failed.tap('NextjsHotReloaderForServer', err => {\n      this.serverError = err;\n      this.serverStats = null;\n    });\n    multiCompiler.compilers[1].hooks.done.tap('NextjsHotReloaderForServer', stats => {\n      this.serverError = null;\n      this.serverStats = stats;\n      const serverOnlyChanges = (0, _utils.difference)(changedServerPages, changedClientPages);\n      changedClientPages.clear();\n      changedServerPages.clear();\n\n      if (serverOnlyChanges.length > 0) {\n        this.send({\n          event: 'serverOnlyChanges',\n          pages: serverOnlyChanges.map(pg => (0, _normalizePagePath.denormalizePagePath)(pg.substr('pages'.length)))\n        });\n      }\n\n      const {\n        compilation\n      } = stats; // We only watch `_document` for changes on the server compilation\n      // the rest of the files will be triggered by the client compilation\n\n      const documentChunk = compilation.namedChunks.get('pages/_document'); // If the document chunk can't be found we do nothing\n\n      if (!documentChunk) {\n        console.warn('_document.js chunk not found');\n        return;\n      } // Initial value\n\n\n      if (this.serverPrevDocumentHash === null) {\n        this.serverPrevDocumentHash = documentChunk.hash;\n        return;\n      } // If _document.js didn't change we don't trigger a reload\n\n\n      if (documentChunk.hash === this.serverPrevDocumentHash) {\n        return;\n      } // Notify reload to reload the page, as _document.js was changed (different hash)\n\n\n      this.send('reloadPage');\n      this.serverPrevDocumentHash = documentChunk.hash;\n    });\n    multiCompiler.compilers[0].hooks.failed.tap('NextjsHotReloaderForClient', err => {\n      this.clientError = err;\n      this.stats = null;\n    });\n    multiCompiler.compilers[0].hooks.done.tap('NextjsHotReloaderForClient', stats => {\n      this.clientError = null;\n      this.stats = stats;\n      const {\n        compilation\n      } = stats;\n      const chunkNames = new Set([...compilation.namedChunks.keys()].filter(name => !!(0, _getRouteFromEntrypoint.default)(name)));\n\n      if (this.prevChunkNames) {\n        // detect chunks which have to be replaced with a new template\n        // e.g, pages/index.js <-> pages/_error.js\n        const addedPages = diff(chunkNames, this.prevChunkNames);\n        const removedPages = diff(this.prevChunkNames, chunkNames);\n\n        if (addedPages.size > 0) {\n          for (const addedPage of addedPages) {\n            const page = (0, _getRouteFromEntrypoint.default)(addedPage);\n            this.send('addedPage', page);\n          }\n        }\n\n        if (removedPages.size > 0) {\n          for (const removedPage of removedPages) {\n            const page = (0, _getRouteFromEntrypoint.default)(removedPage);\n            this.send('removedPage', page);\n          }\n        }\n      }\n\n      this.prevChunkNames = chunkNames;\n    });\n    this.webpackHotMiddleware = new _hotMiddleware.WebpackHotMiddleware(multiCompiler.compilers[0]);\n    let booted = false;\n    this.watcher = await new Promise(resolve => {\n      const watcher = multiCompiler.watch( // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n      configs.map(config => config.watchOptions), // Errors are handled separately\n      _err => {\n        if (!booted) {\n          booted = true;\n          resolve(watcher);\n        }\n      });\n    });\n    this.onDemandEntries = (0, _onDemandEntryHandler.default)(this.watcher, multiCompiler, {\n      pagesDir: this.pagesDir,\n      pageExtensions: this.config.pageExtensions,\n      ...this.config.onDemandEntries\n    });\n    this.middlewares = [// must come before hotMiddleware\n    this.onDemandEntries.middleware, this.webpackHotMiddleware.middleware, (0, _middleware.getOverlayMiddleware)({\n      rootDirectory: this.dir,\n      stats: () => this.stats,\n      serverStats: () => this.serverStats\n    })];\n  }\n\n  async stop() {\n    return new Promise((resolve, reject) => {\n      this.watcher.close(err => err ? reject(err) : resolve());\n    });\n  }\n\n  async getCompilationErrors(page) {\n    var _this$stats;\n\n    const normalizedPage = (0, _normalizePagePath.normalizePathSep)(page);\n\n    if (this.clientError || this.serverError) {\n      return [this.clientError || this.serverError];\n    } else if ((_this$stats = this.stats) != null && _this$stats.hasErrors()) {\n      const {\n        compilation\n      } = this.stats;\n      const failedPages = erroredPages(compilation); // If there is an error related to the requesting page we display it instead of the first error\n\n      if (failedPages[normalizedPage] && failedPages[normalizedPage].length > 0) {\n        return failedPages[normalizedPage];\n      } // If none were found we still have to show the other errors\n\n\n      return this.stats.compilation.errors;\n    }\n\n    return [];\n  }\n\n  send(action, ...args) {\n    this.webpackHotMiddleware.publish(action && typeof action === 'object' ? action : {\n      action,\n      data: args\n    });\n  }\n\n  async ensurePage(page) {\n    // Make sure we don't re-build or dispose prebuilt pages\n    if (page !== '/_error' && _constants2.BLOCKED_PAGES.indexOf(page) !== -1) {\n      return;\n    }\n\n    if (this.serverError || this.clientError) {\n      return Promise.reject(this.serverError || this.clientError);\n    }\n\n    return this.onDemandEntries.ensurePage(page);\n  }\n\n}\n\nexports.default = HotReloader;\n\nfunction diff(a, b) {\n  return new Set([...a].filter(v => !b.has(v)));\n}","map":{"version":3,"sources":["../../server/hot-reloader.ts"],"names":["verbose","res","error","console","isApiRoute","req","API_ROUTE","preflight","matchNextPageBundleRequest","issuer","findEntryModule","failedPages","compilation","entryModule","enhancedName","HotReloader","dir","buildId","middlewares","pagesDir","webpackHotMiddleware","config","stats","serverStats","clientError","serverError","serverPrevDocumentHash","prevChunkNames","onDemandEntries","previewProps","watcher","rewrites","constructor","addCorsSupport","handlePageBundleRequest","params","decodedPagePath","param","decodeURIComponent","err","page","BLOCKED_PAGES","renderScriptError","finished","errors","fn","reject","resolve","pagePaths","Promise","pages","i","entrypoints","additionalClientEntrypoints","CLIENT_STATIC_FILES_RUNTIME_AMP","NEXT_PROJECT_ROOT_DIST_CLIENT","CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH","require","dev","isServer","configs","defaultEntry","isClientCompilation","Object","entries","pageExists","BUILDING","pageLoaderOpts","multiCompiler","changedClientPages","changedServerPages","prevClientPageHashes","prevServerPageHashes","trackPageChanges","key","entry","chunk","prevHash","pageHashMap","changedItems","serverOnlyChanges","event","pg","documentChunk","chunkNames","name","addedPages","diff","removedPages","WebpackHotMiddleware","booted","_err","pageExtensions","rootDirectory","normalizedPage","erroredPages","send","action","data","v","b"],"mappings":"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","sourcesContent":["import { getOverlayMiddleware } from '@next/react-dev-overlay/lib/middleware'\nimport { NextHandleFunction } from 'connect'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { WebpackHotMiddleware } from './hot-middleware'\nimport { join, relative as relativePath } from 'path'\nimport { UrlObject } from 'url'\nimport webpack from 'webpack'\nimport { createEntrypoints, createPagesMapping } from '../build/entries'\nimport { watchCompilers } from '../build/output'\nimport getBaseWebpackConfig from '../build/webpack-config'\nimport { API_ROUTE, NEXT_PROJECT_ROOT_DIST_CLIENT } from '../lib/constants'\nimport { recursiveDelete } from '../lib/recursive-delete'\nimport {\n  BLOCKED_PAGES,\n  CLIENT_STATIC_FILES_RUNTIME_AMP,\n  CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,\n} from '../next-server/lib/constants'\nimport { __ApiPreviewProps } from '../next-server/server/api-utils'\nimport { route } from '../next-server/server/router'\nimport { findPageFile } from './lib/find-page-file'\nimport onDemandEntryHandler, {\n  entries,\n  BUILDING,\n} from './on-demand-entry-handler'\nimport {\n  denormalizePagePath,\n  normalizePathSep,\n} from '../next-server/server/normalize-page-path'\nimport getRouteFromEntrypoint from '../next-server/server/get-route-from-entrypoint'\nimport { isWriteable } from '../build/is-writeable'\nimport { ClientPagesLoaderOptions } from '../build/webpack/loaders/next-client-pages-loader'\nimport { stringify } from 'querystring'\nimport { Rewrite } from '../lib/load-custom-routes'\nimport { difference } from '../build/utils'\nimport { NextConfig } from '../next-server/server/config'\n\nexport async function renderScriptError(\n  res: ServerResponse,\n  error: Error,\n  { verbose = true } = {}\n) {\n  // Asks CDNs and others to not to cache the errored page\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  if (\n    (error as any).code === 'ENOENT' ||\n    error.message === 'INVALID_BUILD_ID'\n  ) {\n    res.statusCode = 404\n    res.end('404 - Not Found')\n    return\n  }\n\n  if (verbose) {\n    console.error(error.stack)\n  }\n  res.statusCode = 500\n  res.end('500 - Internal Error')\n}\n\nfunction addCorsSupport(req: IncomingMessage, res: ServerResponse) {\n  const isApiRoute = req.url!.match(API_ROUTE)\n  // API routes handle their own CORS headers\n  if (isApiRoute) {\n    return { preflight: false }\n  }\n\n  if (!req.headers.origin) {\n    return { preflight: false }\n  }\n\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin)\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET')\n  // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158\n  if (req.headers['access-control-request-headers']) {\n    res.setHeader(\n      'Access-Control-Allow-Headers',\n      req.headers['access-control-request-headers'] as string\n    )\n  }\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200)\n    res.end()\n    return { preflight: true }\n  }\n\n  return { preflight: false }\n}\n\nconst matchNextPageBundleRequest = route(\n  '/_next/static/chunks/pages/:path*.js(\\\\.map|)'\n)\n\n// Recursively look up the issuer till it ends up at the root\nfunction findEntryModule(issuer: any): any {\n  if (issuer.issuer) {\n    return findEntryModule(issuer.issuer)\n  }\n\n  return issuer\n}\n\nfunction erroredPages(compilation: webpack.compilation.Compilation) {\n  const failedPages: { [page: string]: any[] } = {}\n  for (const error of compilation.errors) {\n    if (!error.origin) {\n      continue\n    }\n\n    const entryModule = findEntryModule(error.origin)\n    const { name } = entryModule\n    if (!name) {\n      continue\n    }\n\n    // Only pages have to be reloaded\n    if (!getRouteFromEntrypoint(name)) {\n      continue\n    }\n\n    const enhancedName = getRouteFromEntrypoint(name)\n\n    if (!enhancedName) {\n      continue\n    }\n\n    if (!failedPages[enhancedName]) {\n      failedPages[enhancedName] = []\n    }\n\n    failedPages[enhancedName].push(error)\n  }\n\n  return failedPages\n}\n\nexport default class HotReloader {\n  private dir: string\n  private buildId: string\n  private middlewares: any[]\n  private pagesDir: string\n  private webpackHotMiddleware: (NextHandleFunction & any) | null\n  private config: NextConfig\n  private stats: webpack.Stats | null\n  private serverStats: webpack.Stats | null\n  private clientError: Error | null = null\n  private serverError: Error | null = null\n  private serverPrevDocumentHash: string | null\n  private prevChunkNames?: Set<any>\n  private onDemandEntries: any\n  private previewProps: __ApiPreviewProps\n  private watcher: any\n  private rewrites: Rewrite[]\n\n  constructor(\n    dir: string,\n    {\n      config,\n      pagesDir,\n      buildId,\n      previewProps,\n      rewrites,\n    }: {\n      config: NextConfig\n      pagesDir: string\n      buildId: string\n      previewProps: __ApiPreviewProps\n      rewrites: Rewrite[]\n    }\n  ) {\n    this.buildId = buildId\n    this.dir = dir\n    this.middlewares = []\n    this.pagesDir = pagesDir\n    this.webpackHotMiddleware = null\n    this.stats = null\n    this.serverStats = null\n    this.serverPrevDocumentHash = null\n\n    this.config = config\n    this.previewProps = previewProps\n    this.rewrites = rewrites\n  }\n\n  public async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }> {\n    // Usually CORS support is not needed for the hot-reloader (this is dev only feature)\n    // With when the app runs for multi-zones support behind a proxy,\n    // the current page is trying to access this URL via assetPrefix.\n    // That's when the CORS support is needed.\n    const { preflight } = addCorsSupport(req, res)\n    if (preflight) {\n      return {}\n    }\n\n    // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js\n    // we have to compile the page using on-demand-entries, this middleware will handle doing that\n    // by adding the page to on-demand-entries, waiting till it's done\n    // and then the bundle will be served like usual by the actual route in server/index.js\n    const handlePageBundleRequest = async (\n      pageBundleRes: ServerResponse,\n      parsedPageBundleUrl: UrlObject\n    ): Promise<{ finished?: true }> => {\n      const { pathname } = parsedPageBundleUrl\n      const params: { path: string[] } | null = matchNextPageBundleRequest(\n        pathname\n      )\n      if (!params) {\n        return {}\n      }\n\n      let decodedPagePath: string\n\n      try {\n        decodedPagePath = `/${params.path\n          .map((param) => decodeURIComponent(param))\n          .join('/')}`\n      } catch (_) {\n        const err: Error & { code?: string } = new Error(\n          'failed to decode param'\n        )\n        err.code = 'DECODE_FAILED'\n        throw err\n      }\n\n      const page = denormalizePagePath(decodedPagePath)\n\n      if (page === '/_error' || BLOCKED_PAGES.indexOf(page) === -1) {\n        try {\n          await this.ensurePage(page)\n        } catch (error) {\n          await renderScriptError(pageBundleRes, error)\n          return { finished: true }\n        }\n\n        const errors = await this.getCompilationErrors(page)\n        if (errors.length > 0) {\n          await renderScriptError(pageBundleRes, errors[0], { verbose: false })\n          return { finished: true }\n        }\n      }\n\n      return {}\n    }\n\n    const { finished } = await handlePageBundleRequest(res, parsedUrl)\n\n    for (const fn of this.middlewares) {\n      await new Promise((resolve, reject) => {\n        fn(req, res, (err: Error) => {\n          if (err) return reject(err)\n          resolve()\n        })\n      })\n    }\n\n    return { finished }\n  }\n\n  private async clean(): Promise<void> {\n    return recursiveDelete(join(this.dir, this.config.distDir), /^cache/)\n  }\n\n  private async getWebpackConfig() {\n    const pagePaths = await Promise.all([\n      findPageFile(this.pagesDir, '/_app', this.config.pageExtensions),\n      findPageFile(this.pagesDir, '/_document', this.config.pageExtensions),\n    ])\n\n    const pages = createPagesMapping(\n      pagePaths.filter((i) => i !== null) as string[],\n      this.config.pageExtensions\n    )\n    const entrypoints = createEntrypoints(\n      pages,\n      'server',\n      this.buildId,\n      this.previewProps,\n      this.config,\n      []\n    )\n\n    let additionalClientEntrypoints: { [file: string]: string } = {}\n    additionalClientEntrypoints[CLIENT_STATIC_FILES_RUNTIME_AMP] =\n      `./` +\n      relativePath(\n        this.dir,\n        join(NEXT_PROJECT_ROOT_DIST_CLIENT, 'dev', 'amp-dev')\n      ).replace(/\\\\/g, '/')\n\n    additionalClientEntrypoints[\n      CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH\n    ] = require.resolve(`@next/react-refresh-utils/runtime`)\n\n    return Promise.all([\n      getBaseWebpackConfig(this.dir, {\n        dev: true,\n        isServer: false,\n        config: this.config,\n        buildId: this.buildId,\n        pagesDir: this.pagesDir,\n        rewrites: this.rewrites,\n        entrypoints: { ...entrypoints.client, ...additionalClientEntrypoints },\n      }),\n      getBaseWebpackConfig(this.dir, {\n        dev: true,\n        isServer: true,\n        config: this.config,\n        buildId: this.buildId,\n        pagesDir: this.pagesDir,\n        rewrites: this.rewrites,\n        entrypoints: entrypoints.server,\n      }),\n    ])\n  }\n\n  public async start(): Promise<void> {\n    await this.clean()\n\n    const configs = await this.getWebpackConfig()\n\n    for (const config of configs) {\n      const defaultEntry = config.entry\n      config.entry = async (...args) => {\n        // @ts-ignore entry is always a functon\n        const entrypoints = await defaultEntry(...args)\n\n        const isClientCompilation = config.name === 'client'\n\n        await Promise.all(\n          Object.keys(entries).map(async (page) => {\n            if (isClientCompilation && page.match(API_ROUTE)) {\n              return\n            }\n            const {\n              serverBundlePath,\n              clientBundlePath,\n              absolutePagePath,\n            } = entries[page]\n            const pageExists = await isWriteable(absolutePagePath)\n            if (!pageExists) {\n              // page was removed\n              delete entries[page]\n              return\n            }\n\n            entries[page].status = BUILDING\n            const pageLoaderOpts: ClientPagesLoaderOptions = {\n              page,\n              absolutePagePath,\n            }\n\n            entrypoints[\n              isClientCompilation ? clientBundlePath : serverBundlePath\n            ] = isClientCompilation\n              ? `next-client-pages-loader?${stringify(pageLoaderOpts)}!`\n              : absolutePagePath\n          })\n        )\n\n        return entrypoints\n      }\n    }\n\n    const multiCompiler = webpack(configs)\n\n    watchCompilers(multiCompiler.compilers[0], multiCompiler.compilers[1])\n\n    // Watch for changes to client/server page files so we can tell when just\n    // the server file changes and trigger a reload for GS(S)P pages\n    const changedClientPages = new Set<string>()\n    const changedServerPages = new Set<string>()\n    const prevClientPageHashes = new Map<string, string>()\n    const prevServerPageHashes = new Map<string, string>()\n\n    const trackPageChanges = (\n      pageHashMap: Map<string, string>,\n      changedItems: Set<string>\n    ) => (stats: webpack.compilation.Compilation) => {\n      stats.entrypoints.forEach((entry, key) => {\n        if (key.startsWith('pages/')) {\n          entry.chunks.forEach((chunk: any) => {\n            if (chunk.id === key) {\n              const prevHash = pageHashMap.get(key)\n\n              if (prevHash && prevHash !== chunk.hash) {\n                changedItems.add(key)\n              }\n              pageHashMap.set(key, chunk.hash)\n            }\n          })\n        }\n      })\n    }\n\n    multiCompiler.compilers[0].hooks.emit.tap(\n      'NextjsHotReloaderForClient',\n      trackPageChanges(prevClientPageHashes, changedClientPages)\n    )\n    multiCompiler.compilers[1].hooks.emit.tap(\n      'NextjsHotReloaderForServer',\n      trackPageChanges(prevServerPageHashes, changedServerPages)\n    )\n\n    // This plugin watches for changes to _document.js and notifies the client side that it should reload the page\n    multiCompiler.compilers[1].hooks.failed.tap(\n      'NextjsHotReloaderForServer',\n      (err: Error) => {\n        this.serverError = err\n        this.serverStats = null\n      }\n    )\n    multiCompiler.compilers[1].hooks.done.tap(\n      'NextjsHotReloaderForServer',\n      (stats) => {\n        this.serverError = null\n        this.serverStats = stats\n\n        const serverOnlyChanges = difference<string>(\n          changedServerPages,\n          changedClientPages\n        )\n        changedClientPages.clear()\n        changedServerPages.clear()\n\n        if (serverOnlyChanges.length > 0) {\n          this.send({\n            event: 'serverOnlyChanges',\n            pages: serverOnlyChanges.map((pg) =>\n              denormalizePagePath(pg.substr('pages'.length))\n            ),\n          })\n        }\n\n        const { compilation } = stats\n\n        // We only watch `_document` for changes on the server compilation\n        // the rest of the files will be triggered by the client compilation\n        const documentChunk = compilation.namedChunks.get('pages/_document')\n        // If the document chunk can't be found we do nothing\n        if (!documentChunk) {\n          console.warn('_document.js chunk not found')\n          return\n        }\n\n        // Initial value\n        if (this.serverPrevDocumentHash === null) {\n          this.serverPrevDocumentHash = documentChunk.hash\n          return\n        }\n\n        // If _document.js didn't change we don't trigger a reload\n        if (documentChunk.hash === this.serverPrevDocumentHash) {\n          return\n        }\n\n        // Notify reload to reload the page, as _document.js was changed (different hash)\n        this.send('reloadPage')\n        this.serverPrevDocumentHash = documentChunk.hash\n      }\n    )\n\n    multiCompiler.compilers[0].hooks.failed.tap(\n      'NextjsHotReloaderForClient',\n      (err: Error) => {\n        this.clientError = err\n        this.stats = null\n      }\n    )\n    multiCompiler.compilers[0].hooks.done.tap(\n      'NextjsHotReloaderForClient',\n      (stats) => {\n        this.clientError = null\n        this.stats = stats\n\n        const { compilation } = stats\n        const chunkNames = new Set(\n          [...compilation.namedChunks.keys()].filter(\n            (name) => !!getRouteFromEntrypoint(name)\n          )\n        )\n\n        if (this.prevChunkNames) {\n          // detect chunks which have to be replaced with a new template\n          // e.g, pages/index.js <-> pages/_error.js\n          const addedPages = diff(chunkNames, this.prevChunkNames!)\n          const removedPages = diff(this.prevChunkNames!, chunkNames)\n\n          if (addedPages.size > 0) {\n            for (const addedPage of addedPages) {\n              const page = getRouteFromEntrypoint(addedPage)\n              this.send('addedPage', page)\n            }\n          }\n\n          if (removedPages.size > 0) {\n            for (const removedPage of removedPages) {\n              const page = getRouteFromEntrypoint(removedPage)\n              this.send('removedPage', page)\n            }\n          }\n        }\n\n        this.prevChunkNames = chunkNames\n      }\n    )\n\n    this.webpackHotMiddleware = new WebpackHotMiddleware(\n      multiCompiler.compilers[0]\n    )\n\n    let booted = false\n\n    this.watcher = await new Promise((resolve) => {\n      const watcher = multiCompiler.watch(\n        // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n        configs.map((config) => config.watchOptions!),\n        // Errors are handled separately\n        (_err: any) => {\n          if (!booted) {\n            booted = true\n            resolve(watcher)\n          }\n        }\n      )\n    })\n\n    this.onDemandEntries = onDemandEntryHandler(this.watcher, multiCompiler, {\n      pagesDir: this.pagesDir,\n      pageExtensions: this.config.pageExtensions,\n      ...(this.config.onDemandEntries as {\n        maxInactiveAge: number\n        pagesBufferLength: number\n      }),\n    })\n\n    this.middlewares = [\n      // must come before hotMiddleware\n      this.onDemandEntries.middleware,\n      this.webpackHotMiddleware.middleware,\n      getOverlayMiddleware({\n        rootDirectory: this.dir,\n        stats: () => this.stats,\n        serverStats: () => this.serverStats,\n      }),\n    ]\n  }\n\n  public async stop(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.watcher.close((err: any) => (err ? reject(err) : resolve()))\n    })\n  }\n\n  public async getCompilationErrors(page: string) {\n    const normalizedPage = normalizePathSep(page)\n\n    if (this.clientError || this.serverError) {\n      return [this.clientError || this.serverError]\n    } else if (this.stats?.hasErrors()) {\n      const { compilation } = this.stats\n      const failedPages = erroredPages(compilation)\n\n      // If there is an error related to the requesting page we display it instead of the first error\n      if (\n        failedPages[normalizedPage] &&\n        failedPages[normalizedPage].length > 0\n      ) {\n        return failedPages[normalizedPage]\n      }\n\n      // If none were found we still have to show the other errors\n      return this.stats.compilation.errors\n    }\n\n    return []\n  }\n\n  public send(action?: string | any, ...args: any[]): void {\n    this.webpackHotMiddleware!.publish(\n      action && typeof action === 'object' ? action : { action, data: args }\n    )\n  }\n\n  public async ensurePage(page: string) {\n    // Make sure we don't re-build or dispose prebuilt pages\n    if (page !== '/_error' && BLOCKED_PAGES.indexOf(page) !== -1) {\n      return\n    }\n    if (this.serverError || this.clientError) {\n      return Promise.reject(this.serverError || this.clientError)\n    }\n    return this.onDemandEntries.ensurePage(page)\n  }\n}\n\nfunction diff(a: Set<any>, b: Set<any>) {\n  return new Set([...a].filter((v) => !b.has(v)))\n}\n"]},"metadata":{},"sourceType":"script"}