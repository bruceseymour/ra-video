{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.verifyTypeScriptSetup = verifyTypeScriptSetup;\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _FatalTypeScriptError = require(\"./typescript/FatalTypeScriptError\");\n\nvar _getTypeScriptIntent = require(\"./typescript/getTypeScriptIntent\");\n\nvar _hasNecessaryDependencies = require(\"./typescript/hasNecessaryDependencies\");\n\nvar _runTypeCheck = require(\"./typescript/runTypeCheck\");\n\nvar _TypeScriptCompileError = require(\"./typescript/TypeScriptCompileError\");\n\nvar _writeAppTypeDeclarations = require(\"./typescript/writeAppTypeDeclarations\");\n\nvar _writeConfigurationDefaults = require(\"./typescript/writeConfigurationDefaults\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nasync function verifyTypeScriptSetup(dir, pagesDir, typeCheckPreflight) {\n  const tsConfigPath = _path.default.join(dir, 'tsconfig.json');\n\n  try {\n    // Check if the project uses TypeScript:\n    const intent = await (0, _getTypeScriptIntent.getTypeScriptIntent)(dir, pagesDir);\n\n    if (!intent) {\n      return false;\n    }\n\n    const firstTimeSetup = intent.firstTimeSetup; // Ensure TypeScript and necessary `@types/*` are installed:\n\n    const deps = await (0, _hasNecessaryDependencies.hasNecessaryDependencies)(dir); // Load TypeScript after we're sure it exists:\n\n    const ts = await Promise.resolve(`${deps.resolvedTypeScript}`).then(s => _interopRequireWildcard(require(s))); // Reconfigure (or create) the user's `tsconfig.json` for them:\n\n    await (0, _writeConfigurationDefaults.writeConfigurationDefaults)(ts, tsConfigPath, firstTimeSetup); // Write out the necessary `next-env.d.ts` file to correctly register\n    // Next.js' types:\n\n    await (0, _writeAppTypeDeclarations.writeAppTypeDeclarations)(dir);\n\n    if (typeCheckPreflight) {\n      // Verify the project passes type-checking before we go to webpack phase:\n      return await (0, _runTypeCheck.runTypeCheck)(ts, dir, tsConfigPath);\n    }\n\n    return true;\n  } catch (err) {\n    // These are special errors that should not show a stack trace:\n    if (err instanceof _TypeScriptCompileError.TypeScriptCompileError) {\n      console.error(_chalk.default.red('Failed to compile.\\n'));\n      console.error(err.message);\n      process.exit(1);\n    } else if (err instanceof _FatalTypeScriptError.FatalTypeScriptError) {\n      console.error(err.message);\n      process.exit(1);\n    }\n\n    throw err;\n  }\n}","map":{"version":3,"sources":["../../lib/verifyTypeScriptSetup.ts"],"names":["tsConfigPath","path","intent","firstTimeSetup","deps","ts","err","TypeScriptCompileError","console","chalk","process","FatalTypeScriptError"],"mappings":";;;;;AAAA,IAAA,MAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,KAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AACA,IAAA,qBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;;AACA,IAAA,yBAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AAIA,IAAA,aAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,IAAA,uBAAA,GAAA,OAAA,CAAA,qCAAA,CAAA;;AACA,IAAA,yBAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,IAAA,2BAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO;;AAAA,eAAA,qBAAA,CAAA,GAAA,EAAA,QAAA,EAAA,kBAAA,EAI+B;AACpC,QAAMA,YAAY,GAAGC,KAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA,GAAAA,EAArB,eAAqBA,CAArB;;AAEA,MAAI;AACF;AACA,UAAMC,MAAM,GAAG,MAAM,CAAA,GAAA,oBAAA,CAAA,mBAAA,EAAA,GAAA,EAArB,QAAqB,CAArB;;AACA,QAAI,CAAJ,MAAA,EAAa;AACX,aAAA,KAAA;AAEF;;AAAA,UAAMC,cAAc,GAAGD,MAAM,CAA7B,cAAA,CANE,CAQF;;AACA,UAAME,IAA2B,GAAG,MAAM,CAAA,GAAA,yBAAA,CAAA,wBAAA,EAA1C,GAA0C,CAA1C,CATE,CAWF;;AACA,UAAMC,EAAE,GAAI,MAAA,OAAA,CAAA,OAAA,CAAA,GACVD,IAAI,CADM,kBAAA,EAAA,EAAA,IAAA,CAAA,CAAA,IAAA,uBAAA,CAAA,OAAA,CAAZ,CAAY,CAAA,CAAA,CAAZ,CAZE,CAgBF;;AACA,UAAM,CAAA,GAAA,2BAAA,CAAA,0BAAA,EAAA,EAAA,EAAA,YAAA,EAAN,cAAM,CAAN,CAjBE,CAkBF;AACA;;AACA,UAAM,CAAA,GAAA,yBAAA,CAAA,wBAAA,EAAN,GAAM,CAAN;;AAEA,QAAA,kBAAA,EAAwB;AACtB;AACA,aAAO,MAAM,CAAA,GAAA,aAAA,CAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAb,YAAa,CAAb;AAEF;;AAAA,WAAA,IAAA;AACA,GA3BF,CA2BE,OAAA,GAAA,EAAY;AACZ;AACA,QAAIE,GAAG,YAAYC,uBAAAA,CAAnB,sBAAA,EAA2C;AACzCC,MAAAA,OAAO,CAAPA,KAAAA,CAAcC,MAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAdD,sBAAcC,CAAdD;AACAA,MAAAA,OAAO,CAAPA,KAAAA,CAAcF,GAAG,CAAjBE,OAAAA;AACAE,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AAHF,KAAA,MAIO,IAAIJ,GAAG,YAAYK,qBAAAA,CAAnB,oBAAA,EAAyC;AAC9CH,MAAAA,OAAO,CAAPA,KAAAA,CAAcF,GAAG,CAAjBE,OAAAA;AACAE,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AAEF;;AAAA,UAAA,GAAA;AAEH;AAAA","sourcesContent":["import chalk from 'chalk'\nimport path from 'path'\nimport { FatalTypeScriptError } from './typescript/FatalTypeScriptError'\nimport { getTypeScriptIntent } from './typescript/getTypeScriptIntent'\nimport {\n  hasNecessaryDependencies,\n  NecessaryDependencies,\n} from './typescript/hasNecessaryDependencies'\nimport { runTypeCheck, TypeCheckResult } from './typescript/runTypeCheck'\nimport { TypeScriptCompileError } from './typescript/TypeScriptCompileError'\nimport { writeAppTypeDeclarations } from './typescript/writeAppTypeDeclarations'\nimport { writeConfigurationDefaults } from './typescript/writeConfigurationDefaults'\n\nexport async function verifyTypeScriptSetup(\n  dir: string,\n  pagesDir: string,\n  typeCheckPreflight: boolean\n): Promise<TypeCheckResult | boolean> {\n  const tsConfigPath = path.join(dir, 'tsconfig.json')\n\n  try {\n    // Check if the project uses TypeScript:\n    const intent = await getTypeScriptIntent(dir, pagesDir)\n    if (!intent) {\n      return false\n    }\n    const firstTimeSetup = intent.firstTimeSetup\n\n    // Ensure TypeScript and necessary `@types/*` are installed:\n    const deps: NecessaryDependencies = await hasNecessaryDependencies(dir)\n\n    // Load TypeScript after we're sure it exists:\n    const ts = (await import(\n      deps.resolvedTypeScript\n    )) as typeof import('typescript')\n\n    // Reconfigure (or create) the user's `tsconfig.json` for them:\n    await writeConfigurationDefaults(ts, tsConfigPath, firstTimeSetup)\n    // Write out the necessary `next-env.d.ts` file to correctly register\n    // Next.js' types:\n    await writeAppTypeDeclarations(dir)\n\n    if (typeCheckPreflight) {\n      // Verify the project passes type-checking before we go to webpack phase:\n      return await runTypeCheck(ts, dir, tsConfigPath)\n    }\n    return true\n  } catch (err) {\n    // These are special errors that should not show a stack trace:\n    if (err instanceof TypeScriptCompileError) {\n      console.error(chalk.red('Failed to compile.\\n'))\n      console.error(err.message)\n      process.exit(1)\n    } else if (err instanceof FatalTypeScriptError) {\n      console.error(err.message)\n      process.exit(1)\n    }\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}