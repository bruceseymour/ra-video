{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.Telemetry = void 0;\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _conf = _interopRequireDefault(require(\"next/dist/compiled/conf\"));\n\nvar _crypto = require(\"crypto\");\n\nvar _isDocker = _interopRequireDefault(require(\"next/dist/compiled/is-docker\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _anonymousMeta = require(\"./anonymous-meta\");\n\nvar ciEnvironment = _interopRequireWildcard(require(\"./ci-info\"));\n\nvar _postPayload2 = require(\"./post-payload\");\n\nvar _projectId = require(\"./project-id\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // This is the key that stores whether or not telemetry is enabled or disabled.\n\n\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled'; // This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\n\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt'; // This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\n\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`; // This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\n\nconst TELEMETRY_KEY_SALT = `telemetry.salt`;\n\nclass Telemetry {\n  constructor({\n    distDir\n  }) {\n    this.conf = void 0;\n    this.sessionId = void 0;\n    this.rawProjectId = void 0;\n    this.NEXT_TELEMETRY_DISABLED = void 0;\n    this.NEXT_TELEMETRY_DEBUG = void 0;\n    this.queue = void 0;\n\n    this.notify = () => {\n      if (this.isDisabled || !this.conf) {\n        return;\n      } // The end-user has already been notified about our telemetry integration. We\n      // don't need to constantly annoy them about it.\n      // We will re-inform users about the telemetry if significant changes are\n      // ever made.\n\n\n      if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n        return;\n      }\n\n      this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());\n      console.log(`${_chalk.default.magenta.bold('Attention')}: Next.js now collects completely anonymous telemetry regarding usage.`);\n      console.log(`This information is used to shape Next.js' roadmap and prioritize features.`);\n      console.log(`You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`);\n      console.log(_chalk.default.cyan('https://nextjs.org/telemetry'));\n      console.log();\n    };\n\n    this.setEnabled = _enabled => {\n      const enabled = !!_enabled;\n      this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled);\n    };\n\n    this.oneWayHash = payload => {\n      const hash = (0, _crypto.createHash)('sha256'); // Always prepend the payload value with salt. This ensures the hash is truly\n      // one-way.\n\n      hash.update(this.salt); // Update is an append operation, not a replacement. The salt from the prior\n      // update is still present!\n\n      hash.update(payload);\n      return hash.digest('hex');\n    };\n\n    this.record = _events => {\n      const _this = this; // pseudo try-catch\n\n\n      async function wrapper() {\n        return await _this.submitRecord(_events);\n      }\n\n      const prom = wrapper().then(value => ({\n        isFulfilled: true,\n        isRejected: false,\n        value\n      })).catch(reason => ({\n        isFulfilled: false,\n        isRejected: true,\n        reason\n      })) // Acts as `Promise#finally` because `catch` transforms the error\n      .then(res => {\n        // Clean up the event to prevent unbounded `Set` growth\n        this.queue.delete(prom);\n        return res;\n      }); // Track this `Promise` so we can flush pending events\n\n      this.queue.add(prom);\n      return prom;\n    };\n\n    this.flush = async () => Promise.all(this.queue).catch(() => null);\n\n    this.submitRecord = _events => {\n      let events;\n\n      if (Array.isArray(_events)) {\n        events = _events;\n      } else {\n        events = [_events];\n      }\n\n      if (events.length < 1) {\n        return Promise.resolve();\n      }\n\n      if (this.NEXT_TELEMETRY_DEBUG) {\n        // Print to standard error to simplify selecting the output\n        events.forEach(({\n          eventName,\n          payload\n        }) => console.error(`[telemetry] ` + JSON.stringify({\n          eventName,\n          payload\n        }, null, 2))); // Do not send the telemetry data if debugging. Users may use this feature\n        // to preview what data would be sent.\n\n        return Promise.resolve();\n      } // Skip recording telemetry if the feature is disabled\n\n\n      if (this.isDisabled) {\n        return Promise.resolve();\n      }\n\n      const context = {\n        anonymousId: this.anonymousId,\n        projectId: this.projectId,\n        sessionId: this.sessionId\n      };\n      const meta = (0, _anonymousMeta.getAnonymousMeta)();\n      return (0, _postPayload2._postPayload)(`https://telemetry.nextjs.org/api/v1/record`, {\n        context,\n        meta,\n        events: events.map(({\n          eventName,\n          payload\n        }) => ({\n          eventName,\n          fields: payload\n        }))\n      });\n    }; // Read in the constructor so that .env can be loaded before reading\n\n\n    const {\n      NEXT_TELEMETRY_DISABLED,\n      NEXT_TELEMETRY_DEBUG\n    } = process.env;\n    this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED;\n    this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG;\n    const storageDirectory = getStorageDirectory(distDir);\n\n    try {\n      // `conf` incorrectly throws a permission error during initialization\n      // instead of waiting for first use. We need to handle it, otherwise the\n      // process may crash.\n      this.conf = new _conf.default({\n        projectName: 'nextjs',\n        cwd: storageDirectory\n      });\n    } catch (_) {\n      this.conf = null;\n    }\n\n    this.sessionId = (0, _crypto.randomBytes)(32).toString('hex');\n    this.rawProjectId = (0, _projectId.getRawProjectId)();\n    this.queue = new Set();\n    this.notify();\n  }\n\n  get anonymousId() {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID);\n\n    if (val) {\n      return val;\n    }\n\n    const generated = (0, _crypto.randomBytes)(32).toString('hex');\n    this.conf && this.conf.set(TELEMETRY_KEY_ID, generated);\n    return generated;\n  }\n\n  get salt() {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT);\n\n    if (val) {\n      return val;\n    }\n\n    const generated = (0, _crypto.randomBytes)(16).toString('hex');\n    this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated);\n    return generated;\n  }\n\n  get isDisabled() {\n    if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n      return true;\n    }\n\n    return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false;\n  }\n\n  get isEnabled() {\n    return !!this.conf && this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false;\n  }\n\n  get projectId() {\n    return this.oneWayHash(this.rawProjectId);\n  }\n\n}\n\nexports.Telemetry = Telemetry;\n\nfunction getStorageDirectory(distDir) {\n  const isLikelyEphemeral = ciEnvironment.isCI || (0, _isDocker.default)();\n\n  if (isLikelyEphemeral) {\n    return _path.default.join(distDir, 'cache');\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../telemetry/storage.ts"],"names":["TELEMETRY_KEY_ENABLED","TELEMETRY_KEY_NOTIFY_DATE","TELEMETRY_KEY_ID","TELEMETRY_KEY_SALT","Telemetry","conf","sessionId","rawProjectId","NEXT_TELEMETRY_DISABLED","NEXT_TELEMETRY_DEBUG","queue","constructor","process","storageDirectory","getStorageDirectory","Conf","projectName","cwd","Date","console","chalk","val","generated","_enabled","enabled","payload","hash","_events","_this","prom","value","isFulfilled","isRejected","reason","res","Promise","Array","events","JSON","context","anonymousId","projectId","meta","fields","isLikelyEphemeral","ciEnvironment","path"],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport Conf from 'next/dist/compiled/conf'\nimport { BinaryLike, createHash, randomBytes } from 'crypto'\nimport isDockerFunction from 'next/dist/compiled/is-docker'\nimport path from 'path'\n\nimport { getAnonymousMeta } from './anonymous-meta'\nimport * as ciEnvironment from './ci-info'\nimport { _postPayload } from './post-payload'\nimport { getRawProjectId } from './project-id'\n\n// This is the key that stores whether or not telemetry is enabled or disabled.\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled'\n\n// This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt'\n\n// This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`\n\n// This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\nconst TELEMETRY_KEY_SALT = `telemetry.salt`\n\ntype TelemetryEvent = { eventName: string; payload: object }\ntype EventContext = {\n  anonymousId: string\n  projectId: string\n  sessionId: string\n}\ntype EventMeta = { [key: string]: unknown }\ntype EventBatchShape = {\n  eventName: string\n  fields: object\n}\n\ntype RecordObject = {\n  isFulfilled: boolean\n  isRejected: boolean\n  value?: any\n  reason?: any\n}\n\nexport class Telemetry {\n  private conf: Conf<any> | null\n  private sessionId: string\n  private rawProjectId: string\n  private NEXT_TELEMETRY_DISABLED: any\n  private NEXT_TELEMETRY_DEBUG: any\n\n  private queue: Set<Promise<RecordObject>>\n\n  constructor({ distDir }: { distDir: string }) {\n    // Read in the constructor so that .env can be loaded before reading\n    const { NEXT_TELEMETRY_DISABLED, NEXT_TELEMETRY_DEBUG } = process.env\n    this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED\n    this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG\n    const storageDirectory = getStorageDirectory(distDir)\n\n    try {\n      // `conf` incorrectly throws a permission error during initialization\n      // instead of waiting for first use. We need to handle it, otherwise the\n      // process may crash.\n      this.conf = new Conf({ projectName: 'nextjs', cwd: storageDirectory })\n    } catch (_) {\n      this.conf = null\n    }\n    this.sessionId = randomBytes(32).toString('hex')\n    this.rawProjectId = getRawProjectId()\n\n    this.queue = new Set()\n\n    this.notify()\n  }\n\n  private notify = () => {\n    if (this.isDisabled || !this.conf) {\n      return\n    }\n\n    // The end-user has already been notified about our telemetry integration. We\n    // don't need to constantly annoy them about it.\n    // We will re-inform users about the telemetry if significant changes are\n    // ever made.\n    if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n      return\n    }\n    this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString())\n\n    console.log(\n      `${chalk.magenta.bold(\n        'Attention'\n      )}: Next.js now collects completely anonymous telemetry regarding usage.`\n    )\n    console.log(\n      `This information is used to shape Next.js' roadmap and prioritize features.`\n    )\n    console.log(\n      `You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`\n    )\n    console.log(chalk.cyan('https://nextjs.org/telemetry'))\n    console.log()\n  }\n\n  get anonymousId(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(32).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_ID, generated)\n    return generated\n  }\n\n  get salt(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(16).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated)\n    return generated\n  }\n\n  private get isDisabled(): boolean {\n    if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n      return true\n    }\n    return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false\n  }\n\n  setEnabled = (_enabled: boolean) => {\n    const enabled = !!_enabled\n    this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled)\n  }\n\n  get isEnabled(): boolean {\n    return !!this.conf && this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false\n  }\n\n  oneWayHash = (payload: BinaryLike): string => {\n    const hash = createHash('sha256')\n\n    // Always prepend the payload value with salt. This ensures the hash is truly\n    // one-way.\n    hash.update(this.salt)\n\n    // Update is an append operation, not a replacement. The salt from the prior\n    // update is still present!\n    hash.update(payload)\n    return hash.digest('hex')\n  }\n\n  private get projectId(): string {\n    return this.oneWayHash(this.rawProjectId)\n  }\n\n  record = (\n    _events: TelemetryEvent | TelemetryEvent[]\n  ): Promise<RecordObject> => {\n    const _this = this\n    // pseudo try-catch\n    async function wrapper() {\n      return await _this.submitRecord(_events)\n    }\n\n    const prom = wrapper()\n      .then((value) => ({\n        isFulfilled: true,\n        isRejected: false,\n        value,\n      }))\n      .catch((reason) => ({\n        isFulfilled: false,\n        isRejected: true,\n        reason,\n      }))\n      // Acts as `Promise#finally` because `catch` transforms the error\n      .then((res) => {\n        // Clean up the event to prevent unbounded `Set` growth\n        this.queue.delete(prom)\n        return res\n      })\n\n    // Track this `Promise` so we can flush pending events\n    this.queue.add(prom)\n\n    return prom\n  }\n\n  flush = async () => Promise.all(this.queue).catch(() => null)\n\n  private submitRecord = (\n    _events: TelemetryEvent | TelemetryEvent[]\n  ): Promise<any> => {\n    let events: TelemetryEvent[]\n    if (Array.isArray(_events)) {\n      events = _events\n    } else {\n      events = [_events]\n    }\n\n    if (events.length < 1) {\n      return Promise.resolve()\n    }\n\n    if (this.NEXT_TELEMETRY_DEBUG) {\n      // Print to standard error to simplify selecting the output\n      events.forEach(({ eventName, payload }) =>\n        console.error(\n          `[telemetry] ` + JSON.stringify({ eventName, payload }, null, 2)\n        )\n      )\n      // Do not send the telemetry data if debugging. Users may use this feature\n      // to preview what data would be sent.\n      return Promise.resolve()\n    }\n\n    // Skip recording telemetry if the feature is disabled\n    if (this.isDisabled) {\n      return Promise.resolve()\n    }\n\n    const context: EventContext = {\n      anonymousId: this.anonymousId,\n      projectId: this.projectId,\n      sessionId: this.sessionId,\n    }\n    const meta: EventMeta = getAnonymousMeta()\n    return _postPayload(`https://telemetry.nextjs.org/api/v1/record`, {\n      context,\n      meta,\n      events: events.map(({ eventName, payload }) => ({\n        eventName,\n        fields: payload,\n      })) as Array<EventBatchShape>,\n    })\n  }\n}\n\nfunction getStorageDirectory(distDir: string): string | undefined {\n  const isLikelyEphemeral = ciEnvironment.isCI || isDockerFunction()\n\n  if (isLikelyEphemeral) {\n    return path.join(distDir, 'cache')\n  }\n\n  return undefined\n}\n"]},"metadata":{},"sourceType":"script"}