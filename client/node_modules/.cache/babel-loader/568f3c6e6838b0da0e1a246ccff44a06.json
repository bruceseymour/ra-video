{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.loadStaticPaths = loadStaticPaths;\n\nvar _utils = require(\"../build/utils\");\n\nvar _loadComponents = require(\"../next-server/server/load-components\");\n\nrequire(\"../next-server/server/node-polyfill-fetch\");\n\nlet workerWasUsed = false; // we call getStaticPaths in a separate process to ensure\n// side-effects aren't relied on in dev that will break\n// during a production build\n\nasync function loadStaticPaths(distDir, pathname, serverless, config, locales, defaultLocale) {\n  // we only want to use each worker once to prevent any invalid\n  // caches\n  if (workerWasUsed) {\n    process.exit(1);\n  } // update work memory runtime-config\n\n\n  require('./../next-server/lib/runtime-config').setConfig(config);\n\n  const components = await (0, _loadComponents.loadComponents)(distDir, pathname, serverless);\n\n  if (!components.getStaticPaths) {\n    // we shouldn't get to this point since the worker should\n    // only be called for SSG pages with getStaticPaths\n    throw new Error(`Invariant: failed to load page with getStaticPaths for ${pathname}`);\n  }\n\n  workerWasUsed = true;\n  return (0, _utils.buildStaticPaths)(pathname, components.getStaticPaths, locales, defaultLocale);\n}","map":{"version":3,"sources":["../../server/static-paths-worker.ts"],"names":["workerWasUsed","process","require","components","pathname"],"mappings":";;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,OAAA,CAAA,2CAAA,CAAA;;AAIA,IAAIA,aAAa,GAAjB,KAAA,C,CAEA;AACA;AACA;;AACO,eAAA,eAAA,CAAA,OAAA,EAAA,QAAA,EAAA,UAAA,EAAA,MAAA,EAAA,OAAA,EAAA,aAAA,EAOL;AACA;AACA;AACA,MAAA,aAAA,EAAmB;AACjBC,IAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AAGF,GAPA,CAOA;;;AACAC,EAAAA,OAAO,CAAPA,qCAAO,CAAPA,CAAAA,SAAAA,CAAAA,MAAAA;;AAEA,QAAMC,UAAU,GAAG,MAAM,CAAA,GAAA,eAAA,CAAA,cAAA,EAAA,OAAA,EAAA,QAAA,EAAzB,UAAyB,CAAzB;;AAEA,MAAI,CAACA,UAAU,CAAf,cAAA,EAAgC;AAC9B;AACA;AACA,UAAM,IAAA,KAAA,CACH,0DAAyDC,QAD5D,EAAM,CAAN;AAKFJ;;AAAAA,EAAAA,aAAa,GAAbA,IAAAA;AACA,SAAO,CAAA,GAAA,MAAA,CAAA,gBAAA,EAAA,QAAA,EAELG,UAAU,CAFL,cAAA,EAAA,OAAA,EAAP,aAAO,CAAP;AAMD","sourcesContent":["import { buildStaticPaths } from '../build/utils'\nimport { loadComponents } from '../next-server/server/load-components'\nimport '../next-server/server/node-polyfill-fetch'\n\ntype RuntimeConfig = any\n\nlet workerWasUsed = false\n\n// we call getStaticPaths in a separate process to ensure\n// side-effects aren't relied on in dev that will break\n// during a production build\nexport async function loadStaticPaths(\n  distDir: string,\n  pathname: string,\n  serverless: boolean,\n  config: RuntimeConfig,\n  locales?: string[],\n  defaultLocale?: string\n) {\n  // we only want to use each worker once to prevent any invalid\n  // caches\n  if (workerWasUsed) {\n    process.exit(1)\n  }\n\n  // update work memory runtime-config\n  require('./../next-server/lib/runtime-config').setConfig(config)\n\n  const components = await loadComponents(distDir, pathname, serverless)\n\n  if (!components.getStaticPaths) {\n    // we shouldn't get to this point since the worker should\n    // only be called for SSG pages with getStaticPaths\n    throw new Error(\n      `Invariant: failed to load page with getStaticPaths for ${pathname}`\n    )\n  }\n\n  workerWasUsed = true\n  return buildStaticPaths(\n    pathname,\n    components.getStaticPaths,\n    locales,\n    defaultLocale\n  )\n}\n"]},"metadata":{},"sourceType":"script"}