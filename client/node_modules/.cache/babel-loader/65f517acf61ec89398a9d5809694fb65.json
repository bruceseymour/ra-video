{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.recursiveDelete = recursiveDelete;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n\nvar _util = require(\"util\");\n\nconst sleep = (0, _util.promisify)(setTimeout);\n\nconst unlinkFile = async (p, t = 1) => {\n  try {\n    await _fs.promises.unlink(p);\n  } catch (e) {\n    if ((e.code === 'EBUSY' || e.code === 'ENOTEMPTY' || e.code === 'EPERM' || e.code === 'EMFILE') && t < 3) {\n      await sleep(t * 100);\n      return unlinkFile(p, t++);\n    }\n\n    if (e.code === 'ENOENT') {\n      return;\n    }\n\n    throw e;\n  }\n};\n/**\n* Recursively delete directory contents\n* @param  {string} dir Directory to delete the contents of\n* @param  {RegExp} [exclude] Exclude based on relative file path\n* @param  {string} [previousPath] Ensures that parameter dir exists, this is not passed recursively\n* @returns Promise void\n*/\n\n\nasync function recursiveDelete(dir, exclude, previousPath = '') {\n  let result;\n\n  try {\n    result = await _fs.promises.readdir(dir);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return;\n    }\n\n    throw e;\n  }\n\n  await Promise.all(result.map(async part => {\n    const absolutePath = (0, _path.join)(dir, part);\n    const pathStat = await _fs.promises.stat(absolutePath).catch(e => {\n      if (e.code !== 'ENOENT') throw e;\n    });\n\n    if (!pathStat) {\n      return;\n    }\n\n    const pp = (0, _path.join)(previousPath, part);\n\n    if (pathStat.isDirectory() && (!exclude || !exclude.test(pp))) {\n      await recursiveDelete(absolutePath, exclude, pp);\n      return _fs.promises.rmdir(absolutePath);\n    }\n\n    if (!exclude || !exclude.test(pp)) {\n      return unlinkFile(absolutePath);\n    }\n  }));\n}","map":{"version":3,"sources":["../../lib/recursive-delete.ts"],"names":["sleep","unlinkFile","t","promises","e","previousPath","result","Promise","absolutePath","pathStat","pp","exclude","recursiveDelete"],"mappings":";;;;;AAAA,IAAA,GAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAEA,MAAMA,KAAK,GAAG,CAAA,GAAA,KAAA,CAAA,SAAA,EAAd,UAAc,CAAd;;AAEA,MAAMC,UAAU,GAAG,OAAA,CAAA,EAAkBC,CAAC,GAAnB,CAAA,KAA2C;AAC5D,MAAI;AACF,UAAMC,GAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAN,CAAMA,CAAN;AACA,GAFF,CAEE,OAAA,CAAA,EAAU;AACV,QACE,CAACC,CAAC,CAADA,IAAAA,KAAAA,OAAAA,IACCA,CAAC,CAADA,IAAAA,KADDA,WAAAA,IAECA,CAAC,CAADA,IAAAA,KAFDA,OAAAA,IAGCA,CAAC,CAADA,IAAAA,KAHF,QAAA,KAIAF,CAAC,GALH,CAAA,EAME;AACA,YAAMF,KAAK,CAACE,CAAC,GAAb,GAAW,CAAX;AACA,aAAOD,UAAU,CAAA,CAAA,EAAIC,CAArB,EAAiB,CAAjB;AAGF;;AAAA,QAAIE,CAAC,CAADA,IAAAA,KAAJ,QAAA,EAAyB;AACvB;AAGF;;AAAA,UAAA,CAAA;AAEH;AArBD,CAAA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAA,eAAA,CAAA,GAAA,EAAA,OAAA,EAGLC,YAAoB,GAHf,EAAA,EAIU;AACf,MAAA,MAAA;;AACA,MAAI;AACFC,IAAAA,MAAM,GAAG,MAAMH,GAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAfG,GAAeH,CAAfG;AACA,GAFF,CAEE,OAAA,CAAA,EAAU;AACV,QAAIF,CAAC,CAADA,IAAAA,KAAJ,QAAA,EAAyB;AACvB;AAEF;;AAAA,UAAA,CAAA;AAGF;;AAAA,QAAMG,OAAO,CAAPA,GAAAA,CACJD,MAAM,CAANA,GAAAA,CAAW,MAAA,IAAA,IAAwB;AACjC,UAAME,YAAY,GAAG,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,GAAA,EAArB,IAAqB,CAArB;AACA,UAAMC,QAAQ,GAAG,MAAMN,GAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAAA,YAAAA,EAAAA,KAAAA,CAAmCC,CAAD,IAAO;AAC9D,UAAIA,CAAC,CAADA,IAAAA,KAAJ,QAAA,EAAyB,MAAA,CAAA;AAD3B,KAAuBD,CAAvB;;AAGA,QAAI,CAAJ,QAAA,EAAe;AACb;AAGF;;AAAA,UAAMO,EAAE,GAAG,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,YAAA,EAAX,IAAW,CAAX;;AACA,QAAID,QAAQ,CAARA,WAAAA,OAA2B,CAAA,OAAA,IAAY,CAACE,OAAO,CAAPA,IAAAA,CAA5C,EAA4CA,CAAxCF,CAAJ,EAA+D;AAC7D,YAAMG,eAAe,CAAA,YAAA,EAAA,OAAA,EAArB,EAAqB,CAArB;AACA,aAAOT,GAAAA,CAAAA,QAAAA,CAAAA,KAAAA,CAAP,YAAOA,CAAP;AAGF;;AAAA,QAAI,CAAA,OAAA,IAAY,CAACQ,OAAO,CAAPA,IAAAA,CAAjB,EAAiBA,CAAjB,EAAmC;AACjC,aAAOV,UAAU,CAAjB,YAAiB,CAAjB;AAEH;AAnBH,GACEK,CADIC,CAAN;AAqBD","sourcesContent":["import { promises } from 'fs'\nimport { join } from 'path'\nimport { promisify } from 'util'\n\nconst sleep = promisify(setTimeout)\n\nconst unlinkFile = async (p: string, t = 1): Promise<void> => {\n  try {\n    await promises.unlink(p)\n  } catch (e) {\n    if (\n      (e.code === 'EBUSY' ||\n        e.code === 'ENOTEMPTY' ||\n        e.code === 'EPERM' ||\n        e.code === 'EMFILE') &&\n      t < 3\n    ) {\n      await sleep(t * 100)\n      return unlinkFile(p, t++)\n    }\n\n    if (e.code === 'ENOENT') {\n      return\n    }\n\n    throw e\n  }\n}\n\n/**\n * Recursively delete directory contents\n * @param  {string} dir Directory to delete the contents of\n * @param  {RegExp} [exclude] Exclude based on relative file path\n * @param  {string} [previousPath] Ensures that parameter dir exists, this is not passed recursively\n * @returns Promise void\n */\nexport async function recursiveDelete(\n  dir: string,\n  exclude?: RegExp,\n  previousPath: string = ''\n): Promise<void> {\n  let result\n  try {\n    result = await promises.readdir(dir)\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return\n    }\n    throw e\n  }\n\n  await Promise.all(\n    result.map(async (part: string) => {\n      const absolutePath = join(dir, part)\n      const pathStat = await promises.stat(absolutePath).catch((e) => {\n        if (e.code !== 'ENOENT') throw e\n      })\n      if (!pathStat) {\n        return\n      }\n\n      const pp = join(previousPath, part)\n      if (pathStat.isDirectory() && (!exclude || !exclude.test(pp))) {\n        await recursiveDelete(absolutePath, exclude, pp)\n        return promises.rmdir(absolutePath)\n      }\n\n      if (!exclude || !exclude.test(pp)) {\n        return unlinkFile(absolutePath)\n      }\n    })\n  )\n}\n"]},"metadata":{},"sourceType":"script"}