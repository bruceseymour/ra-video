{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.runTypeCheck = runTypeCheck;\n\nvar _diagnosticFormatter = require(\"./diagnosticFormatter\");\n\nvar _getTypeScriptConfiguration = require(\"./getTypeScriptConfiguration\");\n\nvar _TypeScriptCompileError = require(\"./TypeScriptCompileError\");\n\nvar _writeConfigurationDefaults = require(\"./writeConfigurationDefaults\");\n\nasync function runTypeCheck(ts, baseDir, tsConfigPath) {\n  var _allDiagnostics$find;\n\n  const effectiveConfiguration = await (0, _getTypeScriptConfiguration.getTypeScriptConfiguration)(ts, tsConfigPath);\n\n  if (effectiveConfiguration.fileNames.length < 1) {\n    return {\n      hasWarnings: false\n    };\n  }\n\n  const requiredConfig = (0, _writeConfigurationDefaults.getRequiredConfiguration)(ts);\n  const program = ts.createProgram(effectiveConfiguration.fileNames, { ...effectiveConfiguration.options,\n    ...requiredConfig,\n    noEmit: true\n  });\n  const result = program.emit(); // Intended to match:\n  // - pages/test.js\n  // - pages/apples.test.js\n  // - pages/__tests__/a.js\n  //\n  // But not:\n  // - pages/contest.js\n  // - pages/other.js\n  // - pages/test/a.js\n  //\n\n  const regexIgnoredFile = /[\\\\/]__(?:tests|mocks)__[\\\\/]|(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/;\n  const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(result.diagnostics).filter(d => !(d.file && regexIgnoredFile.test(d.file.fileName)));\n  const firstError = (_allDiagnostics$find = allDiagnostics.find(d => d.category === _diagnosticFormatter.DiagnosticCategory.Error && Boolean(d.file))) != null ? _allDiagnostics$find : allDiagnostics.find(d => d.category === _diagnosticFormatter.DiagnosticCategory.Error);\n\n  if (firstError) {\n    throw new _TypeScriptCompileError.TypeScriptCompileError(await (0, _diagnosticFormatter.getFormattedDiagnostic)(ts, baseDir, firstError));\n  }\n\n  const warnings = await Promise.all(allDiagnostics.filter(d => d.category === _diagnosticFormatter.DiagnosticCategory.Warning).map(d => (0, _diagnosticFormatter.getFormattedDiagnostic)(ts, baseDir, d)));\n  return {\n    hasWarnings: true,\n    warnings\n  };\n}","map":{"version":3,"sources":["../../../lib/typescript/runTypeCheck.ts"],"names":["effectiveConfiguration","hasWarnings","requiredConfig","program","ts","noEmit","result","regexIgnoredFile","allDiagnostics","d","firstError","DiagnosticCategory","Boolean","TypeScriptCompileError","warnings","Promise"],"mappings":";;;;;AAAA,IAAA,oBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAIA,IAAA,2BAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AACA,IAAA,uBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,IAAA,2BAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AAOO,eAAA,YAAA,CAAA,EAAA,EAAA,OAAA,EAAA,YAAA,EAIqB;AAAA,MAAA,oBAAA;;AAC1B,QAAMA,sBAAsB,GAAG,MAAM,CAAA,GAAA,2BAAA,CAAA,0BAAA,EAAA,EAAA,EAArC,YAAqC,CAArC;;AAKA,MAAIA,sBAAsB,CAAtBA,SAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAAiD;AAC/C,WAAO;AAAEC,MAAAA,WAAW,EAApB;AAAO,KAAP;AAEF;;AAAA,QAAMC,cAAc,GAAG,CAAA,GAAA,2BAAA,CAAA,wBAAA,EAAvB,EAAuB,CAAvB;AAEA,QAAMC,OAAO,GAAGC,EAAE,CAAFA,aAAAA,CAAiBJ,sBAAsB,CAAvCI,SAAAA,EAAmD,EACjE,GAAGJ,sBAAsB,CADwC,OAAA;AAEjE,OAFiE,cAAA;AAGjEK,IAAAA,MAAM,EAHR;AAAmE,GAAnDD,CAAhB;AAKA,QAAME,MAAM,GAAGH,OAAO,CAAtB,IAAeA,EAAf,CAhB0B,CAkB1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMI,gBAAgB,GAAtB,kEAAA;AACA,QAAMC,cAAc,GAAGJ,EAAE,CAAFA,qBAAAA,CAAAA,OAAAA,EAAAA,MAAAA,CAEbE,MAAM,CAFOF,WAAAA,EAAAA,MAAAA,CAGZK,CAAD,IAAO,EAAEA,CAAC,CAADA,IAAAA,IAAUF,gBAAgB,CAAhBA,IAAAA,CAAsBE,CAAC,CAADA,IAAAA,CAHnD,QAG6BF,CAAZ,CAHMH,CAAvB;AAKA,QAAMM,UAAU,GAAA,CAAA,oBAAA,GACdF,cAAc,CAAdA,IAAAA,CACGC,CAAD,IAAOA,CAAC,CAADA,QAAAA,KAAeE,oBAAAA,CAAAA,kBAAAA,CAAfF,KAAAA,IAA2CG,OAAO,CAACH,CAAC,CAF/C,IAE6C,CAD3DD,CADc,KAAA,IAAA,GAAA,oBAAA,GAGTA,cAAc,CAAdA,IAAAA,CAAqBC,CAAD,IAAOA,CAAC,CAADA,QAAAA,KAAeE,oBAAAA,CAAAA,kBAAAA,CAHjD,KAGOH,CAHP;;AAKA,MAAA,UAAA,EAAgB;AACd,UAAM,IAAIK,uBAAAA,CAAJ,sBAAA,CACJ,MAAM,CAAA,GAAA,oBAAA,CAAA,sBAAA,EAAA,EAAA,EAAA,OAAA,EADR,UACQ,CADF,CAAN;AAKF;;AAAA,QAAMC,QAAQ,GAAG,MAAMC,OAAO,CAAPA,GAAAA,CACrBP,cAAc,CAAdA,MAAAA,CACWC,CAAD,IAAOA,CAAC,CAADA,QAAAA,KAAeE,oBAAAA,CAAAA,kBAAAA,CADhCH,OAAAA,EAAAA,GAAAA,CAEQC,CAAD,IAAO,CAAA,GAAA,oBAAA,CAAA,sBAAA,EAAA,EAAA,EAAA,OAAA,EAHhB,CAGgB,CAFdD,CADqBO,CAAvB;AAKA,SAAO;AAAEd,IAAAA,WAAW,EAAb,IAAA;AAAP,IAAA;AAAO,GAAP;AACD","sourcesContent":["import {\n  DiagnosticCategory,\n  getFormattedDiagnostic,\n} from './diagnosticFormatter'\nimport { getTypeScriptConfiguration } from './getTypeScriptConfiguration'\nimport { TypeScriptCompileError } from './TypeScriptCompileError'\nimport { getRequiredConfiguration } from './writeConfigurationDefaults'\n\nexport interface TypeCheckResult {\n  hasWarnings: boolean\n  warnings?: string[]\n}\n\nexport async function runTypeCheck(\n  ts: typeof import('typescript'),\n  baseDir: string,\n  tsConfigPath: string\n): Promise<TypeCheckResult> {\n  const effectiveConfiguration = await getTypeScriptConfiguration(\n    ts,\n    tsConfigPath\n  )\n\n  if (effectiveConfiguration.fileNames.length < 1) {\n    return { hasWarnings: false }\n  }\n  const requiredConfig = getRequiredConfiguration(ts)\n\n  const program = ts.createProgram(effectiveConfiguration.fileNames, {\n    ...effectiveConfiguration.options,\n    ...requiredConfig,\n    noEmit: true,\n  })\n  const result = program.emit()\n\n  // Intended to match:\n  // - pages/test.js\n  // - pages/apples.test.js\n  // - pages/__tests__/a.js\n  //\n  // But not:\n  // - pages/contest.js\n  // - pages/other.js\n  // - pages/test/a.js\n  //\n  const regexIgnoredFile = /[\\\\/]__(?:tests|mocks)__[\\\\/]|(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/\n  const allDiagnostics = ts\n    .getPreEmitDiagnostics(program)\n    .concat(result.diagnostics)\n    .filter((d) => !(d.file && regexIgnoredFile.test(d.file.fileName)))\n\n  const firstError =\n    allDiagnostics.find(\n      (d) => d.category === DiagnosticCategory.Error && Boolean(d.file)\n    ) ?? allDiagnostics.find((d) => d.category === DiagnosticCategory.Error)\n\n  if (firstError) {\n    throw new TypeScriptCompileError(\n      await getFormattedDiagnostic(ts, baseDir, firstError)\n    )\n  }\n\n  const warnings = await Promise.all(\n    allDiagnostics\n      .filter((d) => d.category === DiagnosticCategory.Warning)\n      .map((d) => getFormattedDiagnostic(ts, baseDir, d))\n  )\n  return { hasWarnings: true, warnings }\n}\n"]},"metadata":{},"sourceType":"script"}