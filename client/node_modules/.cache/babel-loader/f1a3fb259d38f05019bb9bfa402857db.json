{"ast":null,"code":"'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Boom = require('@hapi/boom');\n\nconst internals = {};\n\nexports.selection = function (header, preferences, options) {\n  const selections = exports.selections(header, preferences, options);\n  return selections.length ? selections[0] : '';\n};\n\nexports.selections = function (header, preferences, options) {\n  Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n  return internals.parse(header || '', preferences, options);\n}; //      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)\n//\n//      Accept-Charset  = *( \",\" OWS ) ( ( charset / \"*\" ) [ weight ] ) *( OWS \",\" [ OWS ( ( charset / \"*\" ) [ weight ] ) ] )\n//      charset         = token\n//\n//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)\n//\n//      Accept-Encoding = [ ( \",\" / ( codings [ weight ] ) ) *( OWS \",\" [ OWS ( codings [ weight ] ) ] ) ]\n//      codings         = content-coding / \"identity\" / \"*\"\n//      content-coding  = token\n//\n//      Accept-Encoding: compress, gzip\n//      Accept-Encoding:\n//      Accept-Encoding: *\n//      Accept-Encoding: compress;q=0.5, gzip;q=1.0\n//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)\n//\n//      Accept-Language = *( \",\" OWS ) ( language-range [ weight ] ) *( OWS \",\" [ OWS ( language-range [ weight ] ) ] )\n//      language-range  = ( 1*8ALPHA *( \"-\" 1*8alphanum ) ) / \"*\"   ; [RFC4647], Section 2.1\n//      alphanum        = ALPHA / DIGIT\n//\n//       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                        / DIGIT / ALPHA\n//                        ; any VCHAR, except delimiters\n//      OWS             = *( SP / HTAB )\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n\ninternals.parse = function (raw, preferences, options) {\n  // Normalize header (remove spaces and tabs)\n  const header = raw.replace(/[ \\t]/g, ''); // Normalize preferences\n\n  const lowers = new Map();\n\n  if (preferences) {\n    for (let i = 0; i < preferences.length; ++i) {\n      const preference = preferences[i];\n      lowers.set(preference.toLowerCase(), {\n        orig: preference,\n        pos: i\n      });\n    }\n  } // Parse selections\n\n\n  const parts = header.split(',');\n  const selections = [];\n  const map = new Set();\n\n  for (let i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n\n    if (!part) {\n      // Ignore empty parts or leading commas\n      continue;\n    } // Parse parameters\n\n\n    const params = part.split(';');\n\n    if (params.length > 2) {\n      throw Boom.badRequest(`Invalid ${options.type} header`);\n    }\n\n    let token = params[0].toLowerCase();\n\n    if (!token) {\n      throw Boom.badRequest(`Invalid ${options.type} header`);\n    }\n\n    if (options.equivalents && options.equivalents.has(token)) {\n      token = options.equivalents.get(token);\n    }\n\n    const selection = {\n      token,\n      pos: i,\n      q: 1,\n      specificity: options.specificity ? token.split('-') : null\n    };\n\n    if (preferences && lowers.has(token)) {\n      selection.pref = lowers.get(token).pos;\n    }\n\n    map.add(selection.token); // Parse q=value\n\n    if (params.length === 2) {\n      const q = params[1];\n      const [key, value] = q.split('=');\n\n      if (!value || key !== 'q' && key !== 'Q') {\n        throw Boom.badRequest(`Invalid ${options.type} header`);\n      }\n\n      const score = parseFloat(value);\n\n      if (score === 0) {\n        continue;\n      }\n\n      if (Number.isFinite(score) && score <= 1 && score >= 0.001) {\n        selection.q = score;\n      }\n    }\n\n    selections.push(selection); // Only add allowed selections (q !== 0)\n  } // Sort selection based on q and then position in header\n\n\n  selections.sort(internals.sort); // Extract tokens\n\n  const values = selections.map(selection => selection.token);\n\n  if (options.default && !map.has(options.default)) {\n    values.push(options.default);\n  }\n\n  if (!preferences || !preferences.length) {\n    return values;\n  }\n\n  const preferred = [];\n\n  for (const selection of values) {\n    if (selection === '*') {\n      for (const [preference, value] of lowers) {\n        if (!map.has(preference)) {\n          preferred.push(value.orig);\n        }\n      }\n    } else {\n      const lower = selection.toLowerCase();\n\n      if (lowers.has(lower)) {\n        preferred.push(lowers.get(lower).orig);\n      }\n    }\n  }\n\n  return preferred;\n};\n\ninternals.sort = function (a, b) {\n  const aFirst = -1;\n  const bFirst = 1;\n\n  if (b.q !== a.q) {\n    return b.q - a.q;\n  }\n\n  if (b.pref !== a.pref) {\n    if (a.pref === undefined) {\n      return bFirst;\n    }\n\n    if (b.pref === undefined) {\n      return aFirst;\n    }\n\n    return a.pref - b.pref;\n  }\n\n  if (a.specificity && a.specificity[0] === b.specificity[0] && a.specificity.length !== b.specificity.length) {\n    return b.specificity.length - a.specificity.length;\n  }\n\n  return a.pos - b.pos;\n};","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@hapi/accept/lib/header.js"],"names":["Hoek","require","Boom","internals","exports","selection","header","preferences","options","selections","length","assert","Array","isArray","parse","raw","replace","lowers","Map","i","preference","set","toLowerCase","orig","pos","parts","split","map","Set","part","params","badRequest","type","token","equivalents","has","get","q","specificity","pref","add","key","value","score","parseFloat","Number","isFinite","push","sort","values","default","preferred","lower","a","b","aFirst","bFirst","undefined"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,YAAD,CAApB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,YAAD,CAApB;;AAGA,MAAME,SAAS,GAAG,EAAlB;;AAGAC,OAAO,CAACC,SAAR,GAAoB,UAAUC,MAAV,EAAkBC,WAAlB,EAA+BC,OAA/B,EAAwC;AAExD,QAAMC,UAAU,GAAGL,OAAO,CAACK,UAAR,CAAmBH,MAAnB,EAA2BC,WAA3B,EAAwCC,OAAxC,CAAnB;AACA,SAAOC,UAAU,CAACC,MAAX,GAAoBD,UAAU,CAAC,CAAD,CAA9B,GAAoC,EAA3C;AACH,CAJD;;AAOAL,OAAO,CAACK,UAAR,GAAqB,UAAUH,MAAV,EAAkBC,WAAlB,EAA+BC,OAA/B,EAAwC;AAEzDR,EAAAA,IAAI,CAACW,MAAL,CAAY,CAACJ,WAAD,IAAgBK,KAAK,CAACC,OAAN,CAAcN,WAAd,CAA5B,EAAwD,8BAAxD;AAEA,SAAOJ,SAAS,CAACW,KAAV,CAAgBR,MAAM,IAAI,EAA1B,EAA8BC,WAA9B,EAA2CC,OAA3C,CAAP;AACH,CALD,C,CAQA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGAL,SAAS,CAACW,KAAV,GAAkB,UAAUC,GAAV,EAAeR,WAAf,EAA4BC,OAA5B,EAAqC;AAEnD;AAEA,QAAMF,MAAM,GAAGS,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsB,EAAtB,CAAf,CAJmD,CAMnD;;AAEA,QAAMC,MAAM,GAAG,IAAIC,GAAJ,EAAf;;AACA,MAAIX,WAAJ,EAAiB;AACb,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,WAAW,CAACG,MAAhC,EAAwC,EAAES,CAA1C,EAA6C;AACzC,YAAMC,UAAU,GAAGb,WAAW,CAACY,CAAD,CAA9B;AACAF,MAAAA,MAAM,CAACI,GAAP,CAAWD,UAAU,CAACE,WAAX,EAAX,EAAqC;AAAEC,QAAAA,IAAI,EAAEH,UAAR;AAAoBI,QAAAA,GAAG,EAAEL;AAAzB,OAArC;AACH;AACJ,GAdkD,CAgBnD;;;AAEA,QAAMM,KAAK,GAAGnB,MAAM,CAACoB,KAAP,CAAa,GAAb,CAAd;AACA,QAAMjB,UAAU,GAAG,EAAnB;AACA,QAAMkB,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AAEA,OAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,KAAK,CAACf,MAA1B,EAAkC,EAAES,CAApC,EAAuC;AACnC,UAAMU,IAAI,GAAGJ,KAAK,CAACN,CAAD,CAAlB;;AACA,QAAI,CAACU,IAAL,EAAW;AAA6B;AACpC;AACH,KAJkC,CAMnC;;;AAEA,UAAMC,MAAM,GAAGD,IAAI,CAACH,KAAL,CAAW,GAAX,CAAf;;AACA,QAAII,MAAM,CAACpB,MAAP,GAAgB,CAApB,EAAuB;AACnB,YAAMR,IAAI,CAAC6B,UAAL,CAAiB,WAAUvB,OAAO,CAACwB,IAAK,SAAxC,CAAN;AACH;;AAED,QAAIC,KAAK,GAAGH,MAAM,CAAC,CAAD,CAAN,CAAUR,WAAV,EAAZ;;AACA,QAAI,CAACW,KAAL,EAAY;AACR,YAAM/B,IAAI,CAAC6B,UAAL,CAAiB,WAAUvB,OAAO,CAACwB,IAAK,SAAxC,CAAN;AACH;;AAED,QAAIxB,OAAO,CAAC0B,WAAR,IACA1B,OAAO,CAAC0B,WAAR,CAAoBC,GAApB,CAAwBF,KAAxB,CADJ,EACoC;AAEhCA,MAAAA,KAAK,GAAGzB,OAAO,CAAC0B,WAAR,CAAoBE,GAApB,CAAwBH,KAAxB,CAAR;AACH;;AAED,UAAM5B,SAAS,GAAG;AACd4B,MAAAA,KADc;AAEdT,MAAAA,GAAG,EAAEL,CAFS;AAGdkB,MAAAA,CAAC,EAAE,CAHW;AAIdC,MAAAA,WAAW,EAAE9B,OAAO,CAAC8B,WAAR,GAAsBL,KAAK,CAACP,KAAN,CAAY,GAAZ,CAAtB,GAAyC;AAJxC,KAAlB;;AAOA,QAAInB,WAAW,IACXU,MAAM,CAACkB,GAAP,CAAWF,KAAX,CADJ,EACuB;AAEnB5B,MAAAA,SAAS,CAACkC,IAAV,GAAiBtB,MAAM,CAACmB,GAAP,CAAWH,KAAX,EAAkBT,GAAnC;AACH;;AAEDG,IAAAA,GAAG,CAACa,GAAJ,CAAQnC,SAAS,CAAC4B,KAAlB,EArCmC,CAuCnC;;AAEA,QAAIH,MAAM,CAACpB,MAAP,KAAkB,CAAtB,EAAyB;AACrB,YAAM2B,CAAC,GAAGP,MAAM,CAAC,CAAD,CAAhB;AACA,YAAM,CAACW,GAAD,EAAMC,KAAN,IAAeL,CAAC,CAACX,KAAF,CAAQ,GAAR,CAArB;;AAEA,UAAI,CAACgB,KAAD,IACAD,GAAG,KAAK,GAAR,IAAeA,GAAG,KAAK,GAD3B,EACgC;AAE5B,cAAMvC,IAAI,CAAC6B,UAAL,CAAiB,WAAUvB,OAAO,CAACwB,IAAK,SAAxC,CAAN;AACH;;AAED,YAAMW,KAAK,GAAGC,UAAU,CAACF,KAAD,CAAxB;;AACA,UAAIC,KAAK,KAAK,CAAd,EAAiB;AACb;AACH;;AAED,UAAIE,MAAM,CAACC,QAAP,CAAgBH,KAAhB,KACAA,KAAK,IAAI,CADT,IAEAA,KAAK,IAAI,KAFb,EAEoB;AAEhBtC,QAAAA,SAAS,CAACgC,CAAV,GAAcM,KAAd;AACH;AACJ;;AAEDlC,IAAAA,UAAU,CAACsC,IAAX,CAAgB1C,SAAhB,EAhEmC,CAgEK;AAC3C,GAvFkD,CAyFnD;;;AAEAI,EAAAA,UAAU,CAACuC,IAAX,CAAgB7C,SAAS,CAAC6C,IAA1B,EA3FmD,CA6FnD;;AAEA,QAAMC,MAAM,GAAGxC,UAAU,CAACkB,GAAX,CAAgBtB,SAAD,IAAeA,SAAS,CAAC4B,KAAxC,CAAf;;AAEA,MAAIzB,OAAO,CAAC0C,OAAR,IACA,CAACvB,GAAG,CAACQ,GAAJ,CAAQ3B,OAAO,CAAC0C,OAAhB,CADL,EAC+B;AAE3BD,IAAAA,MAAM,CAACF,IAAP,CAAYvC,OAAO,CAAC0C,OAApB;AACH;;AAED,MAAI,CAAC3C,WAAD,IACA,CAACA,WAAW,CAACG,MADjB,EACyB;AAErB,WAAOuC,MAAP;AACH;;AAED,QAAME,SAAS,GAAG,EAAlB;;AACA,OAAK,MAAM9C,SAAX,IAAwB4C,MAAxB,EAAgC;AAC5B,QAAI5C,SAAS,KAAK,GAAlB,EAAuB;AACnB,WAAK,MAAM,CAACe,UAAD,EAAasB,KAAb,CAAX,IAAkCzB,MAAlC,EAA0C;AACtC,YAAI,CAACU,GAAG,CAACQ,GAAJ,CAAQf,UAAR,CAAL,EAA0B;AACtB+B,UAAAA,SAAS,CAACJ,IAAV,CAAeL,KAAK,CAACnB,IAArB;AACH;AACJ;AACJ,KAND,MAOK;AACD,YAAM6B,KAAK,GAAG/C,SAAS,CAACiB,WAAV,EAAd;;AACA,UAAIL,MAAM,CAACkB,GAAP,CAAWiB,KAAX,CAAJ,EAAuB;AACnBD,QAAAA,SAAS,CAACJ,IAAV,CAAe9B,MAAM,CAACmB,GAAP,CAAWgB,KAAX,EAAkB7B,IAAjC;AACH;AACJ;AACJ;;AAED,SAAO4B,SAAP;AACH,CA/HD;;AAkIAhD,SAAS,CAAC6C,IAAV,GAAiB,UAAUK,CAAV,EAAaC,CAAb,EAAgB;AAE7B,QAAMC,MAAM,GAAG,CAAC,CAAhB;AACA,QAAMC,MAAM,GAAG,CAAf;;AAEA,MAAIF,CAAC,CAACjB,CAAF,KAAQgB,CAAC,CAAChB,CAAd,EAAiB;AACb,WAAOiB,CAAC,CAACjB,CAAF,GAAMgB,CAAC,CAAChB,CAAf;AACH;;AAED,MAAIiB,CAAC,CAACf,IAAF,KAAWc,CAAC,CAACd,IAAjB,EAAuB;AACnB,QAAIc,CAAC,CAACd,IAAF,KAAWkB,SAAf,EAA0B;AACtB,aAAOD,MAAP;AACH;;AAED,QAAIF,CAAC,CAACf,IAAF,KAAWkB,SAAf,EAA0B;AACtB,aAAOF,MAAP;AACH;;AAED,WAAOF,CAAC,CAACd,IAAF,GAASe,CAAC,CAACf,IAAlB;AACH;;AAED,MAAIc,CAAC,CAACf,WAAF,IACAe,CAAC,CAACf,WAAF,CAAc,CAAd,MAAqBgB,CAAC,CAAChB,WAAF,CAAc,CAAd,CADrB,IAEAe,CAAC,CAACf,WAAF,CAAc5B,MAAd,KAAyB4C,CAAC,CAAChB,WAAF,CAAc5B,MAF3C,EAEmD;AAE/C,WAAO4C,CAAC,CAAChB,WAAF,CAAc5B,MAAd,GAAuB2C,CAAC,CAACf,WAAF,CAAc5B,MAA5C;AACH;;AAED,SAAO2C,CAAC,CAAC7B,GAAF,GAAQ8B,CAAC,CAAC9B,GAAjB;AACH,CA7BD","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\nconst Boom = require('@hapi/boom');\n\n\nconst internals = {};\n\n\nexports.selection = function (header, preferences, options) {\n\n    const selections = exports.selections(header, preferences, options);\n    return selections.length ? selections[0] : '';\n};\n\n\nexports.selections = function (header, preferences, options) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n\n    return internals.parse(header || '', preferences, options);\n};\n\n\n//      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)\n//\n//      Accept-Charset  = *( \",\" OWS ) ( ( charset / \"*\" ) [ weight ] ) *( OWS \",\" [ OWS ( ( charset / \"*\" ) [ weight ] ) ] )\n//      charset         = token\n//\n//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n\n//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)\n//\n//      Accept-Encoding = [ ( \",\" / ( codings [ weight ] ) ) *( OWS \",\" [ OWS ( codings [ weight ] ) ] ) ]\n//      codings         = content-coding / \"identity\" / \"*\"\n//      content-coding  = token\n//\n//      Accept-Encoding: compress, gzip\n//      Accept-Encoding:\n//      Accept-Encoding: *\n//      Accept-Encoding: compress;q=0.5, gzip;q=1.0\n//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n\n//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)\n//\n//      Accept-Language = *( \",\" OWS ) ( language-range [ weight ] ) *( OWS \",\" [ OWS ( language-range [ weight ] ) ] )\n//      language-range  = ( 1*8ALPHA *( \"-\" 1*8alphanum ) ) / \"*\"   ; [RFC4647], Section 2.1\n//      alphanum        = ALPHA / DIGIT\n//\n//       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                        / DIGIT / ALPHA\n//                        ; any VCHAR, except delimiters\n//      OWS             = *( SP / HTAB )\n\n\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n\ninternals.parse = function (raw, preferences, options) {\n\n    // Normalize header (remove spaces and tabs)\n\n    const header = raw.replace(/[ \\t]/g, '');\n\n    // Normalize preferences\n\n    const lowers = new Map();\n    if (preferences) {\n        for (let i = 0; i < preferences.length; ++i) {\n            const preference = preferences[i];\n            lowers.set(preference.toLowerCase(), { orig: preference, pos: i });\n        }\n    }\n\n    // Parse selections\n\n    const parts = header.split(',');\n    const selections = [];\n    const map = new Set();\n\n    for (let i = 0; i < parts.length; ++i) {\n        const part = parts[i];\n        if (!part) {                            // Ignore empty parts or leading commas\n            continue;\n        }\n\n        // Parse parameters\n\n        const params = part.split(';');\n        if (params.length > 2) {\n            throw Boom.badRequest(`Invalid ${options.type} header`);\n        }\n\n        let token = params[0].toLowerCase();\n        if (!token) {\n            throw Boom.badRequest(`Invalid ${options.type} header`);\n        }\n\n        if (options.equivalents &&\n            options.equivalents.has(token)) {\n\n            token = options.equivalents.get(token);\n        }\n\n        const selection = {\n            token,\n            pos: i,\n            q: 1,\n            specificity: options.specificity ? token.split('-') : null\n        };\n\n        if (preferences &&\n            lowers.has(token)) {\n\n            selection.pref = lowers.get(token).pos;\n        }\n\n        map.add(selection.token);\n\n        // Parse q=value\n\n        if (params.length === 2) {\n            const q = params[1];\n            const [key, value] = q.split('=');\n\n            if (!value ||\n                key !== 'q' && key !== 'Q') {\n\n                throw Boom.badRequest(`Invalid ${options.type} header`);\n            }\n\n            const score = parseFloat(value);\n            if (score === 0) {\n                continue;\n            }\n\n            if (Number.isFinite(score) &&\n                score <= 1 &&\n                score >= 0.001) {\n\n                selection.q = score;\n            }\n        }\n\n        selections.push(selection);             // Only add allowed selections (q !== 0)\n    }\n\n    // Sort selection based on q and then position in header\n\n    selections.sort(internals.sort);\n\n    // Extract tokens\n\n    const values = selections.map((selection) => selection.token);\n\n    if (options.default &&\n        !map.has(options.default)) {\n\n        values.push(options.default);\n    }\n\n    if (!preferences ||\n        !preferences.length) {\n\n        return values;\n    }\n\n    const preferred = [];\n    for (const selection of values) {\n        if (selection === '*') {\n            for (const [preference, value] of lowers) {\n                if (!map.has(preference)) {\n                    preferred.push(value.orig);\n                }\n            }\n        }\n        else {\n            const lower = selection.toLowerCase();\n            if (lowers.has(lower)) {\n                preferred.push(lowers.get(lower).orig);\n            }\n        }\n    }\n\n    return preferred;\n};\n\n\ninternals.sort = function (a, b) {\n\n    const aFirst = -1;\n    const bFirst = 1;\n\n    if (b.q !== a.q) {\n        return b.q - a.q;\n    }\n\n    if (b.pref !== a.pref) {\n        if (a.pref === undefined) {\n            return bFirst;\n        }\n\n        if (b.pref === undefined) {\n            return aFirst;\n        }\n\n        return a.pref - b.pref;\n    }\n\n    if (a.specificity &&\n        a.specificity[0] === b.specificity[0] &&\n        a.specificity.length !== b.specificity.length) {\n\n        return b.specificity.length - a.specificity.length;\n    }\n\n    return a.pos - b.pos;\n};\n"]},"metadata":{},"sourceType":"script"}