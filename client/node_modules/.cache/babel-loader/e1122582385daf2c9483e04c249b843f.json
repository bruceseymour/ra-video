{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.traceFn = traceFn;\nexports.traceAsyncFn = traceAsyncFn;\nexports.tracer = void 0;\n\nvar _api = _interopRequireDefault(require(\"@opentelemetry/api\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst tracer = _api.default.trace.getTracer('next', \"10.0.5\");\n\nexports.tracer = tracer;\n\nfunction traceFn(span, fn) {\n  return tracer.withSpan(span, () => {\n    try {\n      return fn();\n    } finally {\n      span.end();\n    }\n  });\n}\n\nfunction traceAsyncFn(span, fn) {\n  return tracer.withSpan(span, async () => {\n    try {\n      return await fn();\n    } finally {\n      span.end();\n    }\n  });\n}","map":{"version":3,"sources":["../../build/tracer.ts"],"names":["tracer","api","process","__NEXT_VERSION","traceFn","withSpan","fn","traceAsyncFn","span"],"mappings":";;;;;;;AAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;;;;;;AAEO;;AAAA,MAAMA,MAAM,GAAGC,IAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,SAAAA,CAAAA,MAAAA,EAA4BC,QAA5BD,CAAf;;AAA2CC,OAAYC,CAAAA,MAAZD,GAA3C,MAA2CA;;iBAE3C,I,EAAA,E,EAAA;AAASE,SAAT,MAAA,CAAA,QAAA,CAIL,IAJK,EAIEJ,MAAOK;AAAAA,QAAAA;AAAPL,aAAAA,EAAsB,EAAtBA;AAA4B,KAArBK,SAEV;AAAA,MAAA,IAAOC,CADT,GACE;AADF;AAAA,GALG,CAASF;AAKZ;;AAAA,SADF,YACE,CAQG,IARH,EAQYG,EARZ,EAQYA;AAAAA,SAAT,MAAA,CAAA,QAAA,CAIL,IAJK,EAIEP,YAAOK;AAAPL,QAAgBQ;AAAhBR,aAAsB,MAAY,EACvC,EADKA;AAEH,KAFGA,SAEI;AAAA,MAAA,IAAMM,CADf,GACS;AADT;AAAA,GALG,CAASC;AAId","sourcesContent":["import api, { Span } from '@opentelemetry/api'\n\nexport const tracer = api.trace.getTracer('next', process.env.__NEXT_VERSION)\n\nexport function traceFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): ReturnType<T> {\n  return tracer.withSpan(span, () => {\n    try {\n      return fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n\nexport function traceAsyncFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): Promise<ReturnType<T>> {\n  return tracer.withSpan(span, async () => {\n    try {\n      return await fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}