{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRawProjectId = getRawProjectId;\n\nvar _child_process = require(\"child_process\"); // Q: Why does Next.js need a project ID? Why is it looking at my git remote?\n// A:\n// Next.js' telemetry is and always will be completely anonymous. Because of\n// this, we need a way to differentiate different projects to track feature\n// usage accurately. For example, to prevent a feature from appearing to be\n// constantly `used` and then `unused` when switching between local projects.\n// To reiterate,\n// we **never** can read your actual git remote. The value is hashed one-way\n// with random salt data, making it impossible for us to reverse or try to\n// guess the remote by re-computing hashes.\n\n\nfunction _getProjectIdByGit() {\n  try {\n    const originBuffer = (0, _child_process.execSync)(`git config --local --get remote.origin.url`, {\n      timeout: 1000,\n      stdio: `pipe`\n    });\n    return String(originBuffer).trim();\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction getRawProjectId() {\n  return _getProjectIdByGit() || process.env.REPOSITORY_URL || process.cwd();\n}","map":{"version":3,"sources":["../../telemetry/project-id.ts"],"names":["originBuffer","timeout","stdio","String","_getProjectIdByGit","process"],"mappings":";;;;;AAAA,IAAA,cAAA,GAAA,OAAA,CAAA,eAAA,CAAA,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAA,kBAAA,GAA8B;AAC5B,MAAI;AACF,UAAMA,YAAY,GAAG,CAAA,GAAA,cAAA,CAAA,QAAA,EAAA,4CAAA,EAEnB;AACEC,MAAAA,OAAO,EADT,IAAA;AAEEC,MAAAA,KAAK,EAJT;AAEE,KAFmB,CAArB;AAQA,WAAOC,MAAM,CAANA,YAAM,CAANA,CAAP,IAAOA,EAAP;AACA,GAVF,CAUE,OAAA,CAAA,EAAU;AACV,WAAA,IAAA;AAEH;AAEM;;AAAA,SAAA,eAAA,GAAmC;AACxC,SAAOC,kBAAkB,MAAMC,OAAO,CAAPA,GAAAA,CAAxBD,cAAAA,IAAsDC,OAAO,CAApE,GAA6DA,EAA7D;AACD","sourcesContent":["import { execSync } from 'child_process'\n\n// Q: Why does Next.js need a project ID? Why is it looking at my git remote?\n// A:\n// Next.js' telemetry is and always will be completely anonymous. Because of\n// this, we need a way to differentiate different projects to track feature\n// usage accurately. For example, to prevent a feature from appearing to be\n// constantly `used` and then `unused` when switching between local projects.\n// To reiterate,\n// we **never** can read your actual git remote. The value is hashed one-way\n// with random salt data, making it impossible for us to reverse or try to\n// guess the remote by re-computing hashes.\n\nfunction _getProjectIdByGit() {\n  try {\n    const originBuffer = execSync(\n      `git config --local --get remote.origin.url`,\n      {\n        timeout: 1000,\n        stdio: `pipe`,\n      }\n    )\n\n    return String(originBuffer).trim()\n  } catch (_) {\n    return null\n  }\n}\n\nexport function getRawProjectId(): string {\n  return _getProjectIdByGit() || process.env.REPOSITORY_URL || process.cwd()\n}\n"]},"metadata":{},"sourceType":"script"}