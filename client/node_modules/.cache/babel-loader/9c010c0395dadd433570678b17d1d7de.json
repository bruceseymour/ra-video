{"ast":null,"code":"import { AST_Binary, AST_Conditional, AST_Dot, AST_Object, AST_Sequence, AST_Statement, AST_Sub, AST_UnaryPostfix, AST_PrefixedTemplateString } from \"../ast.js\"; // return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\n\nfunction first_in_statement(stack) {\n  let node = stack.parent(-1);\n\n  for (let i = 0, p; p = stack.parent(i); i++) {\n    if (p instanceof AST_Statement && p.body === node) return true;\n\n    if (p instanceof AST_Sequence && p.expressions[0] === node || p.TYPE === \"Call\" && p.expression === node || p instanceof AST_PrefixedTemplateString && p.prefix === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {\n      node = p;\n    } else {\n      return false;\n    }\n  }\n} // Returns whether the leftmost item in the expression is an object\n\n\nfunction left_is_object(node) {\n  if (node instanceof AST_Object) return true;\n  if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);\n  if (node.TYPE === \"Call\") return left_is_object(node.expression);\n  if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);\n  if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);\n  if (node instanceof AST_Conditional) return left_is_object(node.condition);\n  if (node instanceof AST_Binary) return left_is_object(node.left);\n  if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);\n  return false;\n}\n\nexport { first_in_statement, left_is_object };","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/@ampproject/toolbox-optimizer/node_modules/terser/lib/utils/first_in_statement.js"],"names":["AST_Binary","AST_Conditional","AST_Dot","AST_Object","AST_Sequence","AST_Statement","AST_Sub","AST_UnaryPostfix","AST_PrefixedTemplateString","first_in_statement","stack","node","parent","i","p","body","expressions","TYPE","expression","prefix","condition","left","left_is_object"],"mappings":"AAAA,SACIA,UADJ,EAEIC,eAFJ,EAGIC,OAHJ,EAIIC,UAJJ,EAKIC,YALJ,EAMIC,aANJ,EAOIC,OAPJ,EAQIC,gBARJ,EASIC,0BATJ,QAUO,WAVP,C,CAYA;AACA;AACA;;AACA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AAC/B,MAAIC,IAAI,GAAGD,KAAK,CAACE,MAAN,CAAa,CAAC,CAAd,CAAX;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAhB,EAAmBA,CAAC,GAAGJ,KAAK,CAACE,MAAN,CAAaC,CAAb,CAAvB,EAAwCA,CAAC,EAAzC,EAA6C;AACzC,QAAIC,CAAC,YAAYT,aAAb,IAA8BS,CAAC,CAACC,IAAF,KAAWJ,IAA7C,EACI,OAAO,IAAP;;AACJ,QAAKG,CAAC,YAAYV,YAAb,IAA6BU,CAAC,CAACE,WAAF,CAAc,CAAd,MAAqBL,IAAnD,IACCG,CAAC,CAACG,IAAF,KAAW,MAAX,IAAqBH,CAAC,CAACI,UAAF,KAAiBP,IADvC,IAECG,CAAC,YAAYN,0BAAb,IAA2CM,CAAC,CAACK,MAAF,KAAaR,IAFzD,IAGCG,CAAC,YAAYZ,OAAb,IAAwBY,CAAC,CAACI,UAAF,KAAiBP,IAH1C,IAICG,CAAC,YAAYR,OAAb,IAAwBQ,CAAC,CAACI,UAAF,KAAiBP,IAJ1C,IAKCG,CAAC,YAAYb,eAAb,IAAgCa,CAAC,CAACM,SAAF,KAAgBT,IALjD,IAMCG,CAAC,YAAYd,UAAb,IAA2Bc,CAAC,CAACO,IAAF,KAAWV,IANvC,IAOCG,CAAC,YAAYP,gBAAb,IAAiCO,CAAC,CAACI,UAAF,KAAiBP,IAPvD,EAQE;AACEA,MAAAA,IAAI,GAAGG,CAAP;AACH,KAVD,MAUO;AACH,aAAO,KAAP;AACH;AACJ;AACJ,C,CAED;;;AACA,SAASQ,cAAT,CAAwBX,IAAxB,EAA8B;AAC1B,MAAIA,IAAI,YAAYR,UAApB,EAAgC,OAAO,IAAP;AAChC,MAAIQ,IAAI,YAAYP,YAApB,EAAkC,OAAOkB,cAAc,CAACX,IAAI,CAACK,WAAL,CAAiB,CAAjB,CAAD,CAArB;AAClC,MAAIL,IAAI,CAACM,IAAL,KAAc,MAAlB,EAA0B,OAAOK,cAAc,CAACX,IAAI,CAACO,UAAN,CAArB;AAC1B,MAAIP,IAAI,YAAYH,0BAApB,EAAgD,OAAOc,cAAc,CAACX,IAAI,CAACQ,MAAN,CAArB;AAChD,MAAIR,IAAI,YAAYT,OAAhB,IAA2BS,IAAI,YAAYL,OAA/C,EAAwD,OAAOgB,cAAc,CAACX,IAAI,CAACO,UAAN,CAArB;AACxD,MAAIP,IAAI,YAAYV,eAApB,EAAqC,OAAOqB,cAAc,CAACX,IAAI,CAACS,SAAN,CAArB;AACrC,MAAIT,IAAI,YAAYX,UAApB,EAAgC,OAAOsB,cAAc,CAACX,IAAI,CAACU,IAAN,CAArB;AAChC,MAAIV,IAAI,YAAYJ,gBAApB,EAAsC,OAAOe,cAAc,CAACX,IAAI,CAACO,UAAN,CAArB;AACtC,SAAO,KAAP;AACH;;AAED,SAAST,kBAAT,EAA6Ba,cAA7B","sourcesContent":["import {\n    AST_Binary,\n    AST_Conditional,\n    AST_Dot,\n    AST_Object,\n    AST_Sequence,\n    AST_Statement,\n    AST_Sub,\n    AST_UnaryPostfix,\n    AST_PrefixedTemplateString\n} from \"../ast.js\";\n\n// return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\nfunction first_in_statement(stack) {\n    let node = stack.parent(-1);\n    for (let i = 0, p; p = stack.parent(i); i++) {\n        if (p instanceof AST_Statement && p.body === node)\n            return true;\n        if ((p instanceof AST_Sequence && p.expressions[0] === node) ||\n            (p.TYPE === \"Call\" && p.expression === node) ||\n            (p instanceof AST_PrefixedTemplateString && p.prefix === node) ||\n            (p instanceof AST_Dot && p.expression === node) ||\n            (p instanceof AST_Sub && p.expression === node) ||\n            (p instanceof AST_Conditional && p.condition === node) ||\n            (p instanceof AST_Binary && p.left === node) ||\n            (p instanceof AST_UnaryPostfix && p.expression === node)\n        ) {\n            node = p;\n        } else {\n            return false;\n        }\n    }\n}\n\n// Returns whether the leftmost item in the expression is an object\nfunction left_is_object(node) {\n    if (node instanceof AST_Object) return true;\n    if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);\n    if (node.TYPE === \"Call\") return left_is_object(node.expression);\n    if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);\n    if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);\n    if (node instanceof AST_Conditional) return left_is_object(node.condition);\n    if (node instanceof AST_Binary) return left_is_object(node.left);\n    if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);\n    return false;\n}\n\nexport { first_in_statement, left_is_object };\n"]},"metadata":{},"sourceType":"module"}