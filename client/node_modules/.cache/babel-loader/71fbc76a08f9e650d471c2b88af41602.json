{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.IncrementalCache = void 0;\n\nvar _fs = require(\"fs\");\n\nvar _lruCache = _interopRequireDefault(require(\"next/dist/compiled/lru-cache\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _constants = require(\"../lib/constants\");\n\nvar _normalizeLocalePath = require(\"../lib/i18n/normalize-locale-path\");\n\nvar _normalizePagePath = require(\"./normalize-page-path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction toRoute(pathname) {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/';\n}\n\nclass IncrementalCache {\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales\n  }) {\n    this.incrementalOptions = void 0;\n    this.prerenderManifest = void 0;\n    this.cache = void 0;\n    this.locales = void 0;\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk: !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true)\n    };\n    this.locales = locales;\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1,\n        // letting us know this doesn't conform to spec\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null // `preview` is special case read in next-dev-server\n\n      };\n    } else {\n      this.prerenderManifest = JSON.parse((0, _fs.readFileSync)(_path.default.join(distDir, _constants.PRERENDER_MANIFEST), 'utf8'));\n    }\n\n    this.cache = new _lruCache.default({\n      // default to 50MB limit\n      max: max || 50 * 1024 * 1024,\n\n      length(val) {\n        if (val.isNotFound || val.isRedirect) return 25; // rough estimate of size of cache value\n\n        return val.html.length + JSON.stringify(val.pageData).length;\n      }\n\n    });\n  }\n\n  getSeedPath(pathname, ext) {\n    return _path.default.join(this.incrementalOptions.pagesDir, `${pathname}.${ext}`);\n  }\n\n  calculateRevalidate(pathname) {\n    pathname = toRoute(pathname);\n\n    if (!this.prerenderManifest.routes[pathname]) {\n      pathname = toRoute((0, _normalizeLocalePath.normalizeLocalePath)(pathname, this.locales).pathname);\n    } // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n\n\n    const curTime = new Date().getTime();\n    if (this.incrementalOptions.dev) return curTime - 1000;\n    const {\n      initialRevalidateSeconds\n    } = this.prerenderManifest.routes[pathname] || {\n      initialRevalidateSeconds: 1\n    };\n    const revalidateAfter = typeof initialRevalidateSeconds === 'number' ? initialRevalidateSeconds * 1000 + curTime : initialRevalidateSeconds;\n    return revalidateAfter;\n  }\n\n  getFallback(page) {\n    page = (0, _normalizePagePath.normalizePagePath)(page);\n    return _fs.promises.readFile(this.getSeedPath(page, 'html'), 'utf8');\n  } // get data from cache if available\n\n\n  async get(pathname) {\n    if (this.incrementalOptions.dev) return;\n    pathname = (0, _normalizePagePath.normalizePagePath)(pathname);\n    let data = this.cache.get(pathname); // let's check the disk for seed data\n\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        return {\n          isNotFound: true,\n          revalidateAfter: false\n        };\n      }\n\n      try {\n        const html = await _fs.promises.readFile(this.getSeedPath(pathname, 'html'), 'utf8');\n        const pageData = JSON.parse(await _fs.promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8'));\n        data = {\n          html,\n          pageData,\n          revalidateAfter: this.calculateRevalidate(pathname)\n        };\n        this.cache.set(pathname, data);\n      } catch (_) {// unable to get data from disk\n      }\n    }\n\n    if (data && data.revalidateAfter !== false && data.revalidateAfter < new Date().getTime()) {\n      data.isStale = true;\n    }\n\n    const manifestEntry = this.prerenderManifest.routes[pathname];\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds;\n    }\n\n    return data;\n  } // populate the incremental cache with new data\n\n\n  async set(pathname, data, revalidateSeconds) {\n    if (this.incrementalOptions.dev) return;\n\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: _path.default.posix.join('/_next/data', `${(0, _normalizePagePath.normalizePagePath)(pathname)}.json`),\n        srcRoute: null,\n        // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n        initialRevalidateSeconds: revalidateSeconds\n      };\n    }\n\n    pathname = (0, _normalizePagePath.normalizePagePath)(pathname);\n    this.cache.set(pathname, { ...data,\n      revalidateAfter: this.calculateRevalidate(pathname)\n    }); // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n\n    if (this.incrementalOptions.flushToDisk && !data.isNotFound) {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html');\n        await _fs.promises.mkdir(_path.default.dirname(seedPath), {\n          recursive: true\n        });\n        await _fs.promises.writeFile(seedPath, data.html, 'utf8');\n        await _fs.promises.writeFile(this.getSeedPath(pathname, 'json'), JSON.stringify(data.pageData), 'utf8');\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error);\n      }\n    }\n  }\n\n}\n\nexports.IncrementalCache = IncrementalCache;","map":{"version":3,"sources":["../../../next-server/server/incremental-cache.ts"],"names":["pathname","IncrementalCache","incrementalOptions","prerenderManifest","cache","locales","constructor","flushToDisk","version","routes","dynamicRoutes","notFoundRoutes","preview","JSON","path","PRERENDER_MANIFEST","LRUCache","max","length","val","getSeedPath","ext","calculateRevalidate","toRoute","curTime","initialRevalidateSeconds","revalidateAfter","getFallback","page","promises","data","isNotFound","html","pageData","manifestEntry","dataRoute","srcRoute","seedPath","recursive","console"],"mappings":"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","sourcesContent":["import { promises, readFileSync } from 'fs'\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from 'path'\nimport { PrerenderManifest } from '../../build'\nimport { PRERENDER_MANIFEST } from '../lib/constants'\nimport { normalizeLocalePath } from '../lib/i18n/normalize-locale-path'\nimport { normalizePagePath } from './normalize-page-path'\n\nfunction toRoute(pathname: string): string {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/'\n}\n\ntype IncrementalCacheValue = {\n  html?: string\n  pageData?: any\n  isStale?: boolean\n  isNotFound?: boolean\n  isRedirect?: boolean\n  curRevalidate?: number | false\n  // milliseconds to revalidate after\n  revalidateAfter: number | false\n}\n\nexport class IncrementalCache {\n  incrementalOptions: {\n    flushToDisk?: boolean\n    pagesDir?: string\n    distDir?: string\n    dev?: boolean\n  }\n\n  prerenderManifest: PrerenderManifest\n  cache: LRUCache<string, IncrementalCacheValue>\n  locales?: string[]\n\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales,\n  }: {\n    dev: boolean\n    max?: number\n    distDir: string\n    pagesDir: string\n    flushToDisk?: boolean\n    locales?: string[]\n  }) {\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk:\n        !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true),\n    }\n    this.locales = locales\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1 as any, // letting us know this doesn't conform to spec\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null as any, // `preview` is special case read in next-dev-server\n      }\n    } else {\n      this.prerenderManifest = JSON.parse(\n        readFileSync(path.join(distDir, PRERENDER_MANIFEST), 'utf8')\n      )\n    }\n\n    this.cache = new LRUCache({\n      // default to 50MB limit\n      max: max || 50 * 1024 * 1024,\n      length(val) {\n        if (val.isNotFound || val.isRedirect) return 25\n        // rough estimate of size of cache value\n        return val.html!.length + JSON.stringify(val.pageData).length\n      },\n    })\n  }\n\n  private getSeedPath(pathname: string, ext: string): string {\n    return path.join(this.incrementalOptions.pagesDir!, `${pathname}.${ext}`)\n  }\n\n  private calculateRevalidate(pathname: string): number | false {\n    pathname = toRoute(pathname)\n\n    if (!this.prerenderManifest.routes[pathname]) {\n      pathname = toRoute(normalizeLocalePath(pathname, this.locales).pathname)\n    }\n\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    const curTime = new Date().getTime()\n    if (this.incrementalOptions.dev) return curTime - 1000\n\n    const { initialRevalidateSeconds } = this.prerenderManifest.routes[\n      pathname\n    ] || {\n      initialRevalidateSeconds: 1,\n    }\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + curTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  getFallback(page: string): Promise<string> {\n    page = normalizePagePath(page)\n    return promises.readFile(this.getSeedPath(page, 'html'), 'utf8')\n  }\n\n  // get data from cache if available\n  async get(pathname: string): Promise<IncrementalCacheValue | void> {\n    if (this.incrementalOptions.dev) return\n    pathname = normalizePagePath(pathname)\n\n    let data = this.cache.get(pathname)\n\n    // let's check the disk for seed data\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        return { isNotFound: true, revalidateAfter: false }\n      }\n\n      try {\n        const html = await promises.readFile(\n          this.getSeedPath(pathname, 'html'),\n          'utf8'\n        )\n        const pageData = JSON.parse(\n          await promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8')\n        )\n\n        data = {\n          html,\n          pageData,\n          revalidateAfter: this.calculateRevalidate(pathname),\n        }\n        this.cache.set(pathname, data)\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n\n    if (\n      data &&\n      data.revalidateAfter !== false &&\n      data.revalidateAfter < new Date().getTime()\n    ) {\n      data.isStale = true\n    }\n    const manifestEntry = this.prerenderManifest.routes[pathname]\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds\n    }\n    return data\n  }\n\n  // populate the incremental cache with new data\n  async set(\n    pathname: string,\n    data: {\n      html?: string\n      pageData?: any\n      isNotFound?: boolean\n      isRedirect?: boolean\n    },\n    revalidateSeconds?: number | false\n  ) {\n    if (this.incrementalOptions.dev) return\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: path.posix.join(\n          '/_next/data',\n          `${normalizePagePath(pathname)}.json`\n        ),\n        srcRoute: null, // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n        initialRevalidateSeconds: revalidateSeconds,\n      }\n    }\n\n    pathname = normalizePagePath(pathname)\n    this.cache.set(pathname, {\n      ...data,\n      revalidateAfter: this.calculateRevalidate(pathname),\n    })\n\n    // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n    if (this.incrementalOptions.flushToDisk && !data.isNotFound) {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html')\n        await promises.mkdir(path.dirname(seedPath), { recursive: true })\n        await promises.writeFile(seedPath, data.html, 'utf8')\n        await promises.writeFile(\n          this.getSeedPath(pathname, 'json'),\n          JSON.stringify(data.pageData),\n          'utf8'\n        )\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}