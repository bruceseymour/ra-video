{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.recursiveReadDirSync = recursiveReadDirSync;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = require(\"path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* Recursively read directory\n* @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n* @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n* @returns Array holding all relative paths\n*/\n\n\nfunction recursiveReadDirSync(dir, arr = [], rootDir = dir) {\n  const result = _fs.default.readdirSync(dir);\n\n  result.forEach(part => {\n    const absolutePath = (0, _path.join)(dir, part);\n\n    const pathStat = _fs.default.statSync(absolutePath);\n\n    if (pathStat.isDirectory()) {\n      recursiveReadDirSync(absolutePath, arr, rootDir);\n      return;\n    }\n\n    arr.push(absolutePath.replace(rootDir, ''));\n  });\n  return arr;\n}","map":{"version":3,"sources":["../../../../next-server/server/lib/recursive-readdir-sync.ts"],"names":["arr","rootDir","result","fs","part","absolutePath","pathStat","recursiveReadDirSync"],"mappings":";;;;;AAAA,IAAA,GAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;;;;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAAA,oBAAA,CAAA,GAAA,EAELA,GAAa,GAFR,EAAA,EAGLC,OAAO,GAHF,GAAA,EAIK;AACV,QAAMC,MAAM,GAAGC,GAAAA,CAAAA,OAAAA,CAAAA,WAAAA,CAAf,GAAeA,CAAf;;AAEAD,EAAAA,MAAM,CAANA,OAAAA,CAAgBE,IAAD,IAAkB;AAC/B,UAAMC,YAAY,GAAG,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,GAAA,EAArB,IAAqB,CAArB;;AACA,UAAMC,QAAQ,GAAGH,GAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAjB,YAAiBA,CAAjB;;AAEA,QAAIG,QAAQ,CAAZ,WAAIA,EAAJ,EAA4B;AAC1BC,MAAAA,oBAAoB,CAAA,YAAA,EAAA,GAAA,EAApBA,OAAoB,CAApBA;AACA;AAEFP;;AAAAA,IAAAA,GAAG,CAAHA,IAAAA,CAASK,YAAY,CAAZA,OAAAA,CAAAA,OAAAA,EAATL,EAASK,CAATL;AARFE,GAAAA;AAWA,SAAA,GAAA;AACD","sourcesContent":["import fs from 'fs'\nimport { join } from 'path'\n\n/**\n * Recursively read directory\n * @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n * @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n * @returns Array holding all relative paths\n */\nexport function recursiveReadDirSync(\n  dir: string,\n  arr: string[] = [],\n  rootDir = dir\n): string[] {\n  const result = fs.readdirSync(dir)\n\n  result.forEach((part: string) => {\n    const absolutePath = join(dir, part)\n    const pathStat = fs.statSync(absolutePath)\n\n    if (pathStat.isDirectory()) {\n      recursiveReadDirSync(absolutePath, arr, rootDir)\n      return\n    }\n    arr.push(absolutePath.replace(rootDir, ''))\n  })\n\n  return arr\n}\n"]},"metadata":{},"sourceType":"script"}