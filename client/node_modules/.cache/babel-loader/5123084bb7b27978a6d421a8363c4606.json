{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _client = require(\"@next/react-dev-overlay/lib/client\");\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _jestWorker = _interopRequireDefault(require(\"jest-worker\"));\n\nvar _amphtmlValidator = _interopRequireDefault(require(\"next/dist/compiled/amphtml-validator\"));\n\nvar _findUp = _interopRequireDefault(require(\"next/dist/compiled/find-up\"));\n\nvar _path = require(\"path\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _watchpack = _interopRequireDefault(require(\"watchpack\"));\n\nvar _index = require(\"../build/output/index\");\n\nvar Log = _interopRequireWildcard(require(\"../build/output/log\"));\n\nvar _constants = require(\"../lib/constants\");\n\nvar _fileExists = require(\"../lib/file-exists\");\n\nvar _findPagesDir = require(\"../lib/find-pages-dir\");\n\nvar _loadCustomRoutes = _interopRequireDefault(require(\"../lib/load-custom-routes\"));\n\nvar _verifyTypeScriptSetup = require(\"../lib/verifyTypeScriptSetup\");\n\nvar _constants2 = require(\"../next-server/lib/constants\");\n\nvar _utils = require(\"../next-server/lib/router/utils\");\n\nvar _nextServer = _interopRequireDefault(require(\"../next-server/server/next-server\"));\n\nvar _normalizePagePath = require(\"../next-server/server/normalize-page-path\");\n\nvar _router = _interopRequireWildcard(require(\"../next-server/server/router\"));\n\nvar _events = require(\"../telemetry/events\");\n\nvar _storage = require(\"../telemetry/storage\");\n\nvar _hotReloader = _interopRequireDefault(require(\"./hot-reloader\"));\n\nvar _findPageFile = require(\"./lib/find-page-file\");\n\nvar _utils2 = require(\"./lib/utils\");\n\nvar _coalescedFunction = require(\"../lib/coalesced-function\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nif (typeof _react.default.Suspense === 'undefined') {\n  throw new Error(`The version of React you are using is lower than the minimum required version needed for Next.js. Please upgrade \"react\" and \"react-dom\": \"npm install react react-dom\" https://err.sh/vercel/next.js/invalid-react-version`);\n}\n\nclass DevServer extends _nextServer.default {\n  constructor(options) {\n    var _this$nextConfig$expe, _this$nextConfig$expe2, _this$nextConfig$expe3;\n\n    super({ ...options,\n      dev: true\n    });\n    this.devReady = void 0;\n    this.setDevReady = void 0;\n    this.webpackWatcher = void 0;\n    this.hotReloader = void 0;\n    this.isCustomServer = void 0;\n    this.sortedRoutes = void 0;\n    this.staticPathsWorker = void 0;\n    this._devCachedPreviewProps = void 0;\n    this.renderOpts.dev = true;\n    this.renderOpts.ErrorDebug = _client.ReactDevOverlay;\n    this.devReady = new Promise(resolve => {\n      this.setDevReady = resolve;\n    });\n    this.renderOpts.ampSkipValidation = (_this$nextConfig$expe = (_this$nextConfig$expe2 = this.nextConfig.experimental) == null ? void 0 : (_this$nextConfig$expe3 = _this$nextConfig$expe2.amp) == null ? void 0 : _this$nextConfig$expe3.skipValidation) != null ? _this$nextConfig$expe : false;\n\n    this.renderOpts.ampValidator = (html, pathname) => {\n      const validatorPath = this.nextConfig.experimental && this.nextConfig.experimental.amp && this.nextConfig.experimental.amp.validator;\n      return _amphtmlValidator.default.getInstance(validatorPath).then(validator => {\n        const result = validator.validateString(html);\n        (0, _index.ampValidation)(pathname, result.errors.filter(e => e.severity === 'ERROR').filter(e => this._filterAmpDevelopmentScript(html, e)), result.errors.filter(e => e.severity !== 'ERROR'));\n      });\n    };\n\n    if (_fs.default.existsSync((0, _path.join)(this.dir, 'static'))) {\n      console.warn(`The static directory has been deprecated in favor of the public directory. https://err.sh/vercel/next.js/static-dir-deprecated`);\n    }\n\n    this.isCustomServer = !options.isNextDevCommand;\n    this.pagesDir = (0, _findPagesDir.findPagesDir)(this.dir);\n    this.staticPathsWorker = new _jestWorker.default(require.resolve('./static-paths-worker'), {\n      maxRetries: 0,\n      numWorkers: this.nextConfig.experimental.cpus,\n      forkOptions: {\n        env: { ...process.env,\n          // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n          // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n          // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n          // is the main Next.js one\n          NODE_OPTIONS: (0, _utils2.getNodeOptionsWithoutInspect)()\n        }\n      }\n    });\n    this.staticPathsWorker.getStdout().pipe(process.stdout);\n    this.staticPathsWorker.getStderr().pipe(process.stderr);\n  }\n\n  currentPhase() {\n    return _constants2.PHASE_DEVELOPMENT_SERVER;\n  }\n\n  readBuildId() {\n    return 'development';\n  }\n\n  async addExportPathMapRoutes() {\n    // Makes `next export` exportPathMap work in development mode.\n    // So that the user doesn't have to define a custom server reading the exportPathMap\n    if (this.nextConfig.exportPathMap) {\n      console.log('Defining routes from exportPathMap');\n      const exportPathMap = await this.nextConfig.exportPathMap({}, {\n        dev: true,\n        dir: this.dir,\n        outDir: null,\n        distDir: this.distDir,\n        buildId: this.buildId\n      }); // In development we can't give a default path mapping\n\n      for (const path in exportPathMap) {\n        const {\n          page,\n          query = {}\n        } = exportPathMap[path]; // We use unshift so that we're sure the routes is defined before Next's default routes\n\n        this.router.addFsRoute({\n          match: (0, _router.route)(path),\n          type: 'route',\n          name: `${path} exportpathmap route`,\n          fn: async (req, res, _params, parsedUrl) => {\n            const {\n              query: urlQuery\n            } = parsedUrl;\n            Object.keys(urlQuery).filter(key => query[key] === undefined).forEach(key => console.warn(`Url '${path}' defines a query parameter '${key}' that is missing in exportPathMap`));\n            const mergedQuery = { ...urlQuery,\n              ...query\n            };\n            await this.render(req, res, page, mergedQuery, parsedUrl);\n            return {\n              finished: true\n            };\n          }\n        });\n      }\n    }\n  }\n\n  async startWatcher() {\n    if (this.webpackWatcher) {\n      return;\n    }\n\n    const regexPageExtension = new RegExp(`\\\\.+(?:${this.nextConfig.pageExtensions.join('|')})$`);\n    let resolved = false;\n    return new Promise((resolve, reject) => {\n      const pagesDir = this.pagesDir; // Watchpack doesn't emit an event for an empty directory\n\n      _fs.default.readdir(pagesDir, (_, files) => {\n        if (files != null && files.length) {\n          return;\n        }\n\n        if (!resolved) {\n          resolve();\n          resolved = true;\n        }\n      });\n\n      let wp = this.webpackWatcher = new _watchpack.default();\n      wp.watch([], [pagesDir], 0);\n      wp.on('aggregated', () => {\n        const routedPages = [];\n        const knownFiles = wp.getTimeInfoEntries();\n\n        for (const [fileName, {\n          accuracy\n        }] of knownFiles) {\n          if (accuracy === undefined || !regexPageExtension.test(fileName)) {\n            continue;\n          }\n\n          let pageName = '/' + (0, _path.relative)(pagesDir, fileName).replace(/\\\\+/g, '/');\n          pageName = pageName.replace(regexPageExtension, '');\n          pageName = pageName.replace(/\\/index$/, '') || '/';\n          routedPages.push(pageName);\n        }\n\n        try {\n          var _this$sortedRoutes; // we serve a separate manifest with all pages for the client in\n          // dev mode so that we can match a page after a rewrite on the client\n          // before it has been built and is populated in the _buildManifest\n\n\n          const sortedRoutes = (0, _utils.getSortedRoutes)(routedPages);\n\n          if (!((_this$sortedRoutes = this.sortedRoutes) != null && _this$sortedRoutes.every((val, idx) => val === sortedRoutes[idx]))) {\n            // emit the change so clients fetch the update\n            this.hotReloader.send(undefined, {\n              devPagesManifest: true\n            });\n          }\n\n          this.sortedRoutes = sortedRoutes;\n          this.dynamicRoutes = this.sortedRoutes.filter(_utils.isDynamicRoute).map(page => ({\n            page,\n            match: (0, _utils.getRouteMatcher)((0, _utils.getRouteRegex)(page))\n          }));\n          this.router.setDynamicRoutes(this.dynamicRoutes);\n\n          if (!resolved) {\n            resolve();\n            resolved = true;\n          }\n        } catch (e) {\n          if (!resolved) {\n            reject(e);\n            resolved = true;\n          } else {\n            console.warn('Failed to reload dynamic routes:', e);\n          }\n        }\n      });\n    });\n  }\n\n  async stopWatcher() {\n    if (!this.webpackWatcher) {\n      return;\n    }\n\n    this.webpackWatcher.close();\n    this.webpackWatcher = null;\n  }\n\n  async prepare() {\n    await (0, _verifyTypeScriptSetup.verifyTypeScriptSetup)(this.dir, this.pagesDir, false);\n    this.customRoutes = await (0, _loadCustomRoutes.default)(this.nextConfig); // reload router\n\n    const {\n      redirects,\n      rewrites,\n      headers\n    } = this.customRoutes;\n\n    if (redirects.length || rewrites.length || headers.length) {\n      this.router = new _router.default(this.generateRoutes());\n    }\n\n    this.hotReloader = new _hotReloader.default(this.dir, {\n      pagesDir: this.pagesDir,\n      config: this.nextConfig,\n      previewProps: this.getPreviewProps(),\n      buildId: this.buildId,\n      rewrites: this.customRoutes.rewrites\n    });\n    await super.prepare();\n    await this.addExportPathMapRoutes();\n    await this.hotReloader.start();\n    await this.startWatcher();\n    this.setDevReady();\n    const telemetry = new _storage.Telemetry({\n      distDir: this.distDir\n    });\n    telemetry.record((0, _events.eventCliSession)(_constants2.PHASE_DEVELOPMENT_SERVER, this.distDir, {\n      cliCommand: 'dev',\n      isSrcDir: (0, _path.relative)(this.dir, this.pagesDir).startsWith('src'),\n      hasNowJson: !!(await (0, _findUp.default)('now.json', {\n        cwd: this.dir\n      })),\n      isCustomServer: this.isCustomServer\n    }));\n  }\n\n  async close() {\n    await this.stopWatcher();\n    await this.staticPathsWorker.end();\n\n    if (this.hotReloader) {\n      await this.hotReloader.stop();\n    }\n  }\n\n  async hasPage(pathname) {\n    let normalizedPath;\n\n    try {\n      normalizedPath = (0, _normalizePagePath.normalizePagePath)(pathname);\n    } catch (err) {\n      console.error(err); // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n\n      return false;\n    }\n\n    const pageFile = await (0, _findPageFile.findPageFile)(this.pagesDir, normalizedPath, this.nextConfig.pageExtensions);\n    return !!pageFile;\n  }\n\n  async _beforeCatchAllRender(req, res, params, parsedUrl) {\n    const {\n      pathname\n    } = parsedUrl;\n    const pathParts = params.path || [];\n    const path = `/${pathParts.join('/')}`; // check for a public file, throwing error if there's a\n    // conflicting page\n\n    let decodedPath;\n\n    try {\n      decodedPath = decodeURIComponent(path);\n    } catch (_) {\n      const err = new Error('failed to decode param');\n      err.code = 'DECODE_FAILED';\n      throw err;\n    }\n\n    if (await this.hasPublicFile(decodedPath)) {\n      if (await this.hasPage(pathname)) {\n        const err = new Error(`A conflicting public file and page file was found for path ${pathname} https://err.sh/vercel/next.js/conflicting-public-file-page`);\n        res.statusCode = 500;\n        await this.renderError(err, req, res, pathname, {});\n        return true;\n      }\n\n      await this.servePublic(req, res, pathParts);\n      return true;\n    }\n\n    return false;\n  }\n\n  async run(req, res, parsedUrl) {\n    var _parsedUrl$pathname;\n\n    await this.devReady;\n    const {\n      basePath\n    } = this.nextConfig;\n    let originalPathname = null;\n\n    if (basePath && (_parsedUrl$pathname = parsedUrl.pathname) != null && _parsedUrl$pathname.startsWith(basePath)) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname;\n      parsedUrl.pathname = parsedUrl.pathname.slice(basePath.length) || '/';\n    }\n\n    const {\n      pathname\n    } = parsedUrl;\n\n    if (pathname.startsWith('/_next')) {\n      if (await (0, _fileExists.fileExists)((0, _path.join)(this.publicDir, '_next'))) {\n        throw new Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT);\n      }\n    }\n\n    const {\n      finished = false\n    } = await this.hotReloader.run(req, res, parsedUrl);\n\n    if (finished) {\n      return;\n    }\n\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname;\n    }\n\n    return super.run(req, res, parsedUrl);\n  } // override production loading of routes-manifest\n\n\n  getCustomRoutes() {\n    // actual routes will be loaded asynchronously during .prepare()\n    return {\n      redirects: [],\n      rewrites: [],\n      headers: []\n    };\n  }\n\n  getPreviewProps() {\n    if (this._devCachedPreviewProps) {\n      return this._devCachedPreviewProps;\n    }\n\n    return this._devCachedPreviewProps = {\n      previewModeId: _crypto.default.randomBytes(16).toString('hex'),\n      previewModeSigningKey: _crypto.default.randomBytes(32).toString('hex'),\n      previewModeEncryptionKey: _crypto.default.randomBytes(32).toString('hex')\n    };\n  }\n\n  generateRoutes() {\n    const {\n      fsRoutes,\n      ...otherRoutes\n    } = super.generateRoutes(); // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n\n    fsRoutes.unshift({\n      match: (0, _router.route)('/_next/development/:path*'),\n      type: 'route',\n      name: '_next/development catchall',\n      fn: async (req, res, params) => {\n        const p = (0, _path.join)(this.distDir, ...(params.path || []));\n        await this.serveStatic(req, res, p);\n        return {\n          finished: true\n        };\n      }\n    });\n    fsRoutes.unshift({\n      match: (0, _router.route)(`/_next/${_constants2.CLIENT_STATIC_FILES_PATH}/${this.buildId}/${_constants2.DEV_CLIENT_PAGES_MANIFEST}`),\n      type: 'route',\n      name: `_next/${_constants2.CLIENT_STATIC_FILES_PATH}/${this.buildId}/${_constants2.DEV_CLIENT_PAGES_MANIFEST}`,\n      fn: async (_req, res) => {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'application/json; charset=utf-8');\n        res.end(JSON.stringify({\n          pages: this.sortedRoutes\n        }));\n        return {\n          finished: true\n        };\n      }\n    });\n    fsRoutes.push({\n      match: (0, _router.route)('/:path*'),\n      type: 'route',\n      requireBasePath: false,\n      name: 'catchall public directory route',\n      fn: async (req, res, params, parsedUrl) => {\n        const {\n          pathname\n        } = parsedUrl;\n\n        if (!pathname) {\n          throw new Error('pathname is undefined');\n        } // Used in development to check public directory paths\n\n\n        if (await this._beforeCatchAllRender(req, res, params, parsedUrl)) {\n          return {\n            finished: true\n          };\n        }\n\n        return {\n          finished: false\n        };\n      }\n    });\n    return {\n      fsRoutes,\n      ...otherRoutes\n    };\n  } // In development public files are not added to the router but handled as a fallback instead\n\n\n  generatePublicRoutes() {\n    return [];\n  } // In development dynamic routes cannot be known ahead of time\n\n\n  getDynamicRoutes() {\n    return [];\n  }\n\n  _filterAmpDevelopmentScript(html, event) {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true;\n    }\n\n    const snippetChunks = html.split('\\n');\n    let snippet;\n\n    if (!(snippet = html.split('\\n')[event.line - 1]) || !(snippet = snippet.substring(event.col))) {\n      return true;\n    }\n\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n');\n    snippet = snippet.substring(0, snippet.indexOf('</script>'));\n    return !snippet.includes('data-amp-development-mode-only');\n  }\n\n  async getStaticPaths(pathname) {\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n    const __getStaticPaths = async () => {\n      const {\n        publicRuntimeConfig,\n        serverRuntimeConfig\n      } = this.nextConfig;\n      const {\n        locales,\n        defaultLocale\n      } = this.nextConfig.i18n || {};\n      const paths = await this.staticPathsWorker.loadStaticPaths(this.distDir, pathname, !this.renderOpts.dev && this._isLikeServerless, {\n        publicRuntimeConfig,\n        serverRuntimeConfig\n      }, locales, defaultLocale);\n      return paths;\n    };\n\n    const {\n      paths: staticPaths,\n      fallback\n    } = (await (0, _coalescedFunction.withCoalescedInvoke)(__getStaticPaths)(`staticPaths-${pathname}`, [])).value;\n    return {\n      staticPaths,\n      fallbackMode: fallback === 'blocking' ? 'blocking' : fallback === true ? 'static' : false\n    };\n  }\n\n  async ensureApiPage(pathname) {\n    return this.hotReloader.ensurePage(pathname);\n  }\n\n  async renderToHTML(req, res, pathname, query) {\n    await this.devReady;\n    const compilationErr = await this.getCompilationError(pathname);\n\n    if (compilationErr) {\n      res.statusCode = 500;\n      return this.renderErrorToHTML(compilationErr, req, res, pathname, query);\n    } // In dev mode we use on demand entries to compile the page before rendering\n\n\n    try {\n      await this.hotReloader.ensurePage(pathname).catch(async err => {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n\n        for (const dynamicRoute of this.dynamicRoutes || []) {\n          const params = dynamicRoute.match(pathname);\n\n          if (!params) {\n            continue;\n          }\n\n          return this.hotReloader.ensurePage(dynamicRoute.page);\n        }\n\n        throw err;\n      });\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        try {\n          await this.hotReloader.ensurePage('/404');\n        } catch (hotReloaderError) {\n          if (hotReloaderError.code !== 'ENOENT') {\n            throw hotReloaderError;\n          }\n        }\n\n        res.statusCode = 404;\n        return this.renderErrorToHTML(null, req, res, pathname, query);\n      }\n\n      if (!this.quiet) console.error(err);\n    }\n\n    const html = await super.renderToHTML(req, res, pathname, query);\n    return html;\n  }\n\n  async renderErrorToHTML(err, req, res, pathname, query) {\n    await this.devReady;\n\n    if (res.statusCode === 404 && (await this.hasPage('/404'))) {\n      await this.hotReloader.ensurePage('/404');\n    } else {\n      await this.hotReloader.ensurePage('/_error');\n    }\n\n    const compilationErr = await this.getCompilationError(pathname);\n\n    if (compilationErr) {\n      res.statusCode = 500;\n      return super.renderErrorToHTML(compilationErr, req, res, pathname, query);\n    }\n\n    if (!err && res.statusCode === 500) {\n      err = new Error('An undefined error was thrown sometime during render... ' + 'See https://err.sh/vercel/next.js/threw-undefined');\n    }\n\n    try {\n      const out = await super.renderErrorToHTML(err, req, res, pathname, query);\n      return out;\n    } catch (err2) {\n      if (!this.quiet) Log.error(err2);\n      res.statusCode = 500;\n      return super.renderErrorToHTML(err2, req, res, pathname, query);\n    }\n  }\n\n  sendHTML(req, res, html) {\n    // In dev, we should not cache pages for any reason.\n    res.setHeader('Cache-Control', 'no-store, must-revalidate');\n    return super.sendHTML(req, res, html);\n  }\n\n  setImmutableAssetCacheControl(res) {\n    res.setHeader('Cache-Control', 'no-store, must-revalidate');\n  }\n\n  servePublic(req, res, pathParts) {\n    const p = (0, _path.join)(this.publicDir, ...pathParts);\n    return this.serveStatic(req, res, p);\n  }\n\n  async hasPublicFile(path) {\n    try {\n      const info = await _fs.default.promises.stat((0, _path.join)(this.publicDir, path));\n      return info.isFile();\n    } catch (_) {\n      return false;\n    }\n  }\n\n  async getCompilationError(page) {\n    const errors = await this.hotReloader.getCompilationErrors(page);\n    if (errors.length === 0) return; // Return the very first error we found.\n\n    return errors[0];\n  }\n\n  isServeableUrl(untrustedFileUrl) {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n    let decodedUntrustedFilePath;\n\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl);\n    } catch (_unused) {\n      return false;\n    } // (2) Resolve \"up paths\" to determine real request\n\n\n    const untrustedFilePath = (0, _path.resolve)(decodedUntrustedFilePath); // don't allow null bytes anywhere in the file path\n\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false;\n    } // During development mode, files can be added while the server is running.\n    // Checks for .next/static, .next/server, static and public.\n    // Note that in development .next/server is available for error reporting purposes.\n    // see `packages/next/next-server/server/next-server.ts` for more details.\n\n\n    if (untrustedFilePath.startsWith((0, _path.join)(this.distDir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path.join)(this.distDir, 'server') + _path.sep) || untrustedFilePath.startsWith((0, _path.join)(this.dir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path.join)(this.dir, 'public') + _path.sep)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.default = DevServer;","map":{"version":3,"sources":["../../server/next-dev-server.ts"],"names":["React","Server","devReady","setDevReady","webpackWatcher","hotReloader","isCustomServer","sortedRoutes","staticPathsWorker","constructor","dev","ReactDevOverlay","resolve","validatorPath","AmpHtmlValidator","validator","result","e","fs","console","options","Worker","require","maxRetries","numWorkers","forkOptions","env","process","NODE_OPTIONS","currentPhase","PHASE_DEVELOPMENT_SERVER","readBuildId","exportPathMap","dir","outDir","distDir","buildId","query","match","type","name","path","fn","Object","key","mergedQuery","finished","regexPageExtension","resolved","pagesDir","files","wp","Watchpack","routedPages","knownFiles","accuracy","pageName","val","devPagesManifest","isDynamicRoute","page","reject","redirects","rewrites","headers","Router","HotReloader","config","previewProps","telemetry","Telemetry","cliCommand","isSrcDir","hasNowJson","cwd","normalizedPath","pageFile","pathParts","params","decodedPath","decodeURIComponent","err","pathname","res","originalPathname","basePath","parsedUrl","PUBLIC_DIR_MIDDLEWARE_CONFLICT","getCustomRoutes","getPreviewProps","previewModeId","crypto","previewModeSigningKey","previewModeEncryptionKey","generateRoutes","fsRoutes","p","CLIENT_STATIC_FILES_PATH","DEV_CLIENT_PAGES_MANIFEST","JSON","pages","requireBasePath","generatePublicRoutes","getDynamicRoutes","_filterAmpDevelopmentScript","event","snippetChunks","html","snippet","__getStaticPaths","paths","fallbackMode","fallback","compilationErr","dynamicRoute","hotReloaderError","out","Log","sendHTML","setImmutableAssetCacheControl","servePublic","info","errors","isServeableUrl","decodedUntrustedFilePath","untrustedFilePath","sep"],"mappings":"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","sourcesContent":["import { ReactDevOverlay } from '@next/react-dev-overlay/lib/client'\nimport crypto from 'crypto'\nimport fs from 'fs'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport Worker from 'jest-worker'\nimport AmpHtmlValidator from 'next/dist/compiled/amphtml-validator'\nimport findUp from 'next/dist/compiled/find-up'\nimport { join as pathJoin, relative, resolve as pathResolve, sep } from 'path'\nimport React from 'react'\nimport { UrlWithParsedQuery } from 'url'\nimport Watchpack from 'watchpack'\nimport { ampValidation } from '../build/output/index'\nimport * as Log from '../build/output/log'\nimport { PUBLIC_DIR_MIDDLEWARE_CONFLICT } from '../lib/constants'\nimport { fileExists } from '../lib/file-exists'\nimport { findPagesDir } from '../lib/find-pages-dir'\nimport loadCustomRoutes, { CustomRoutes } from '../lib/load-custom-routes'\nimport { verifyTypeScriptSetup } from '../lib/verifyTypeScriptSetup'\nimport {\n  PHASE_DEVELOPMENT_SERVER,\n  CLIENT_STATIC_FILES_PATH,\n  DEV_CLIENT_PAGES_MANIFEST,\n} from '../next-server/lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n} from '../next-server/lib/router/utils'\nimport { __ApiPreviewProps } from '../next-server/server/api-utils'\nimport Server, { ServerConstructor } from '../next-server/server/next-server'\nimport { normalizePagePath } from '../next-server/server/normalize-page-path'\nimport Router, { Params, route } from '../next-server/server/router'\nimport { eventCliSession } from '../telemetry/events'\nimport { Telemetry } from '../telemetry/storage'\nimport HotReloader from './hot-reloader'\nimport { findPageFile } from './lib/find-page-file'\nimport { getNodeOptionsWithoutInspect } from './lib/utils'\nimport { withCoalescedInvoke } from '../lib/coalesced-function'\n\nif (typeof React.Suspense === 'undefined') {\n  throw new Error(\n    `The version of React you are using is lower than the minimum required version needed for Next.js. Please upgrade \"react\" and \"react-dom\": \"npm install react react-dom\" https://err.sh/vercel/next.js/invalid-react-version`\n  )\n}\n\nexport default class DevServer extends Server {\n  private devReady: Promise<void>\n  private setDevReady?: Function\n  private webpackWatcher?: Watchpack | null\n  private hotReloader?: HotReloader\n  private isCustomServer: boolean\n  protected sortedRoutes?: string[]\n\n  protected staticPathsWorker: import('jest-worker').default & {\n    loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n  }\n\n  constructor(options: ServerConstructor & { isNextDevCommand?: boolean }) {\n    super({ ...options, dev: true })\n    this.renderOpts.dev = true\n    ;(this.renderOpts as any).ErrorDebug = ReactDevOverlay\n    this.devReady = new Promise((resolve) => {\n      this.setDevReady = resolve\n    })\n    ;(this.renderOpts as any).ampSkipValidation =\n      this.nextConfig.experimental?.amp?.skipValidation ?? false\n    ;(this.renderOpts as any).ampValidator = (\n      html: string,\n      pathname: string\n    ) => {\n      const validatorPath =\n        this.nextConfig.experimental &&\n        this.nextConfig.experimental.amp &&\n        this.nextConfig.experimental.amp.validator\n      return AmpHtmlValidator.getInstance(validatorPath).then((validator) => {\n        const result = validator.validateString(html)\n        ampValidation(\n          pathname,\n          result.errors\n            .filter((e) => e.severity === 'ERROR')\n            .filter((e) => this._filterAmpDevelopmentScript(html, e)),\n          result.errors.filter((e) => e.severity !== 'ERROR')\n        )\n      })\n    }\n    if (fs.existsSync(pathJoin(this.dir, 'static'))) {\n      console.warn(\n        `The static directory has been deprecated in favor of the public directory. https://err.sh/vercel/next.js/static-dir-deprecated`\n      )\n    }\n    this.isCustomServer = !options.isNextDevCommand\n    this.pagesDir = findPagesDir(this.dir)\n    this.staticPathsWorker = new Worker(\n      require.resolve('./static-paths-worker'),\n      {\n        maxRetries: 0,\n        numWorkers: this.nextConfig.experimental.cpus,\n        forkOptions: {\n          env: {\n            ...process.env,\n            // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n            // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n            // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n            // is the main Next.js one\n            NODE_OPTIONS: getNodeOptionsWithoutInspect(),\n          },\n        },\n      }\n    ) as Worker & {\n      loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n    }\n\n    this.staticPathsWorker.getStdout().pipe(process.stdout)\n    this.staticPathsWorker.getStderr().pipe(process.stderr)\n  }\n\n  protected currentPhase(): string {\n    return PHASE_DEVELOPMENT_SERVER\n  }\n\n  protected readBuildId(): string {\n    return 'development'\n  }\n\n  async addExportPathMapRoutes() {\n    // Makes `next export` exportPathMap work in development mode.\n    // So that the user doesn't have to define a custom server reading the exportPathMap\n    if (this.nextConfig.exportPathMap) {\n      console.log('Defining routes from exportPathMap')\n      const exportPathMap = await this.nextConfig.exportPathMap(\n        {},\n        {\n          dev: true,\n          dir: this.dir,\n          outDir: null,\n          distDir: this.distDir,\n          buildId: this.buildId,\n        }\n      ) // In development we can't give a default path mapping\n      for (const path in exportPathMap) {\n        const { page, query = {} } = exportPathMap[path]\n\n        // We use unshift so that we're sure the routes is defined before Next's default routes\n        this.router.addFsRoute({\n          match: route(path),\n          type: 'route',\n          name: `${path} exportpathmap route`,\n          fn: async (req, res, _params, parsedUrl) => {\n            const { query: urlQuery } = parsedUrl\n\n            Object.keys(urlQuery)\n              .filter((key) => query[key] === undefined)\n              .forEach((key) =>\n                console.warn(\n                  `Url '${path}' defines a query parameter '${key}' that is missing in exportPathMap`\n                )\n              )\n\n            const mergedQuery = { ...urlQuery, ...query }\n\n            await this.render(req, res, page, mergedQuery, parsedUrl)\n            return {\n              finished: true,\n            }\n          },\n        })\n      }\n    }\n  }\n\n  async startWatcher(): Promise<void> {\n    if (this.webpackWatcher) {\n      return\n    }\n\n    const regexPageExtension = new RegExp(\n      `\\\\.+(?:${this.nextConfig.pageExtensions.join('|')})$`\n    )\n\n    let resolved = false\n    return new Promise((resolve, reject) => {\n      const pagesDir = this.pagesDir\n\n      // Watchpack doesn't emit an event for an empty directory\n      fs.readdir(pagesDir!, (_, files) => {\n        if (files?.length) {\n          return\n        }\n\n        if (!resolved) {\n          resolve()\n          resolved = true\n        }\n      })\n\n      let wp = (this.webpackWatcher = new Watchpack())\n      wp.watch([], [pagesDir!], 0)\n\n      wp.on('aggregated', () => {\n        const routedPages = []\n        const knownFiles = wp.getTimeInfoEntries()\n        for (const [fileName, { accuracy }] of knownFiles) {\n          if (accuracy === undefined || !regexPageExtension.test(fileName)) {\n            continue\n          }\n\n          let pageName =\n            '/' + relative(pagesDir!, fileName).replace(/\\\\+/g, '/')\n          pageName = pageName.replace(regexPageExtension, '')\n          pageName = pageName.replace(/\\/index$/, '') || '/'\n\n          routedPages.push(pageName)\n        }\n\n        try {\n          // we serve a separate manifest with all pages for the client in\n          // dev mode so that we can match a page after a rewrite on the client\n          // before it has been built and is populated in the _buildManifest\n          const sortedRoutes = getSortedRoutes(routedPages)\n\n          if (\n            !this.sortedRoutes?.every((val, idx) => val === sortedRoutes[idx])\n          ) {\n            // emit the change so clients fetch the update\n            this.hotReloader!.send(undefined, { devPagesManifest: true })\n          }\n          this.sortedRoutes = sortedRoutes\n\n          this.dynamicRoutes = this.sortedRoutes\n            .filter(isDynamicRoute)\n            .map((page) => ({\n              page,\n              match: getRouteMatcher(getRouteRegex(page)),\n            }))\n\n          this.router.setDynamicRoutes(this.dynamicRoutes)\n\n          if (!resolved) {\n            resolve()\n            resolved = true\n          }\n        } catch (e) {\n          if (!resolved) {\n            reject(e)\n            resolved = true\n          } else {\n            console.warn('Failed to reload dynamic routes:', e)\n          }\n        }\n      })\n    })\n  }\n\n  async stopWatcher(): Promise<void> {\n    if (!this.webpackWatcher) {\n      return\n    }\n\n    this.webpackWatcher.close()\n    this.webpackWatcher = null\n  }\n\n  async prepare(): Promise<void> {\n    await verifyTypeScriptSetup(this.dir, this.pagesDir!, false)\n\n    this.customRoutes = await loadCustomRoutes(this.nextConfig)\n\n    // reload router\n    const { redirects, rewrites, headers } = this.customRoutes\n    if (redirects.length || rewrites.length || headers.length) {\n      this.router = new Router(this.generateRoutes())\n    }\n\n    this.hotReloader = new HotReloader(this.dir, {\n      pagesDir: this.pagesDir!,\n      config: this.nextConfig,\n      previewProps: this.getPreviewProps(),\n      buildId: this.buildId,\n      rewrites: this.customRoutes.rewrites,\n    })\n    await super.prepare()\n    await this.addExportPathMapRoutes()\n    await this.hotReloader.start()\n    await this.startWatcher()\n    this.setDevReady!()\n\n    const telemetry = new Telemetry({ distDir: this.distDir })\n    telemetry.record(\n      eventCliSession(PHASE_DEVELOPMENT_SERVER, this.distDir, {\n        cliCommand: 'dev',\n        isSrcDir: relative(this.dir, this.pagesDir!).startsWith('src'),\n        hasNowJson: !!(await findUp('now.json', { cwd: this.dir })),\n        isCustomServer: this.isCustomServer,\n      })\n    )\n  }\n\n  protected async close(): Promise<void> {\n    await this.stopWatcher()\n    await this.staticPathsWorker.end()\n    if (this.hotReloader) {\n      await this.hotReloader.stop()\n    }\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let normalizedPath: string\n\n    try {\n      normalizedPath = normalizePagePath(pathname)\n    } catch (err) {\n      console.error(err)\n      // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n      return false\n    }\n\n    const pageFile = await findPageFile(\n      this.pagesDir!,\n      normalizedPath,\n      this.nextConfig.pageExtensions\n    )\n    return !!pageFile\n  }\n\n  protected async _beforeCatchAllRender(\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    const { pathname } = parsedUrl\n    const pathParts = params.path || []\n    const path = `/${pathParts.join('/')}`\n    // check for a public file, throwing error if there's a\n    // conflicting page\n    let decodedPath: string\n\n    try {\n      decodedPath = decodeURIComponent(path)\n    } catch (_) {\n      const err: Error & { code?: string } = new Error('failed to decode param')\n      err.code = 'DECODE_FAILED'\n      throw err\n    }\n\n    if (await this.hasPublicFile(decodedPath)) {\n      if (await this.hasPage(pathname!)) {\n        const err = new Error(\n          `A conflicting public file and page file was found for path ${pathname} https://err.sh/vercel/next.js/conflicting-public-file-page`\n        )\n        res.statusCode = 500\n        await this.renderError(err, req, res, pathname!, {})\n        return true\n      }\n      await this.servePublic(req, res, pathParts)\n      return true\n    }\n\n    return false\n  }\n\n  async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    await this.devReady\n\n    const { basePath } = this.nextConfig\n    let originalPathname: string | null = null\n\n    if (basePath && parsedUrl.pathname?.startsWith(basePath)) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname\n      parsedUrl.pathname = parsedUrl.pathname!.slice(basePath.length) || '/'\n    }\n\n    const { pathname } = parsedUrl\n\n    if (pathname!.startsWith('/_next')) {\n      if (await fileExists(pathJoin(this.publicDir, '_next'))) {\n        throw new Error(PUBLIC_DIR_MIDDLEWARE_CONFLICT)\n      }\n    }\n\n    const { finished = false } = await this.hotReloader!.run(\n      req,\n      res,\n      parsedUrl\n    )\n\n    if (finished) {\n      return\n    }\n\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname\n    }\n\n    return super.run(req, res, parsedUrl)\n  }\n\n  // override production loading of routes-manifest\n  protected getCustomRoutes(): CustomRoutes {\n    // actual routes will be loaded asynchronously during .prepare()\n    return { redirects: [], rewrites: [], headers: [] }\n  }\n\n  private _devCachedPreviewProps: __ApiPreviewProps | undefined\n  protected getPreviewProps() {\n    if (this._devCachedPreviewProps) {\n      return this._devCachedPreviewProps\n    }\n    return (this._devCachedPreviewProps = {\n      previewModeId: crypto.randomBytes(16).toString('hex'),\n      previewModeSigningKey: crypto.randomBytes(32).toString('hex'),\n      previewModeEncryptionKey: crypto.randomBytes(32).toString('hex'),\n    })\n  }\n\n  generateRoutes() {\n    const { fsRoutes, ...otherRoutes } = super.generateRoutes()\n\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    fsRoutes.unshift({\n      match: route('/_next/development/:path*'),\n      type: 'route',\n      name: '_next/development catchall',\n      fn: async (req, res, params) => {\n        const p = pathJoin(this.distDir, ...(params.path || []))\n        await this.serveStatic(req, res, p)\n        return {\n          finished: true,\n        }\n      },\n    })\n\n    fsRoutes.unshift({\n      match: route(\n        `/_next/${CLIENT_STATIC_FILES_PATH}/${this.buildId}/${DEV_CLIENT_PAGES_MANIFEST}`\n      ),\n      type: 'route',\n      name: `_next/${CLIENT_STATIC_FILES_PATH}/${this.buildId}/${DEV_CLIENT_PAGES_MANIFEST}`,\n      fn: async (_req, res) => {\n        res.statusCode = 200\n        res.setHeader('Content-Type', 'application/json; charset=utf-8')\n        res.end(\n          JSON.stringify({\n            pages: this.sortedRoutes,\n          })\n        )\n        return {\n          finished: true,\n        }\n      },\n    })\n\n    fsRoutes.push({\n      match: route('/:path*'),\n      type: 'route',\n      requireBasePath: false,\n      name: 'catchall public directory route',\n      fn: async (req, res, params, parsedUrl) => {\n        const { pathname } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // Used in development to check public directory paths\n        if (await this._beforeCatchAllRender(req, res, params, parsedUrl)) {\n          return {\n            finished: true,\n          }\n        }\n\n        return {\n          finished: false,\n        }\n      },\n    })\n\n    return { fsRoutes, ...otherRoutes }\n  }\n\n  // In development public files are not added to the router but handled as a fallback instead\n  protected generatePublicRoutes(): never[] {\n    return []\n  }\n\n  // In development dynamic routes cannot be known ahead of time\n  protected getDynamicRoutes(): never[] {\n    return []\n  }\n\n  _filterAmpDevelopmentScript(\n    html: string,\n    event: { line: number; col: number; code: string }\n  ): boolean {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true\n    }\n\n    const snippetChunks = html.split('\\n')\n\n    let snippet\n    if (\n      !(snippet = html.split('\\n')[event.line - 1]) ||\n      !(snippet = snippet.substring(event.col))\n    ) {\n      return true\n    }\n\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n')\n    snippet = snippet.substring(0, snippet.indexOf('</script>'))\n\n    return !snippet.includes('data-amp-development-mode-only')\n  }\n\n  protected async getStaticPaths(\n    pathname: string\n  ): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: false | 'static' | 'blocking'\n  }> {\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n\n    const __getStaticPaths = async () => {\n      const { publicRuntimeConfig, serverRuntimeConfig } = this.nextConfig\n      const { locales, defaultLocale } = this.nextConfig.i18n || {}\n\n      const paths = await this.staticPathsWorker.loadStaticPaths(\n        this.distDir,\n        pathname,\n        !this.renderOpts.dev && this._isLikeServerless,\n        {\n          publicRuntimeConfig,\n          serverRuntimeConfig,\n        },\n        locales,\n        defaultLocale\n      )\n      return paths\n    }\n    const { paths: staticPaths, fallback } = (\n      await withCoalescedInvoke(__getStaticPaths)(`staticPaths-${pathname}`, [])\n    ).value\n\n    return {\n      staticPaths,\n      fallbackMode:\n        fallback === 'blocking'\n          ? 'blocking'\n          : fallback === true\n          ? 'static'\n          : false,\n    }\n  }\n\n  protected async ensureApiPage(pathname: string) {\n    return this.hotReloader!.ensurePage(pathname)\n  }\n\n  async renderToHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: { [key: string]: string }\n  ): Promise<string | null> {\n    await this.devReady\n    const compilationErr = await this.getCompilationError(pathname)\n    if (compilationErr) {\n      res.statusCode = 500\n      return this.renderErrorToHTML(compilationErr, req, res, pathname, query)\n    }\n\n    // In dev mode we use on demand entries to compile the page before rendering\n    try {\n      await this.hotReloader!.ensurePage(pathname).catch(async (err: Error) => {\n        if ((err as any).code !== 'ENOENT') {\n          throw err\n        }\n\n        for (const dynamicRoute of this.dynamicRoutes || []) {\n          const params = dynamicRoute.match(pathname)\n          if (!params) {\n            continue\n          }\n\n          return this.hotReloader!.ensurePage(dynamicRoute.page)\n        }\n        throw err\n      })\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        try {\n          await this.hotReloader!.ensurePage('/404')\n        } catch (hotReloaderError) {\n          if (hotReloaderError.code !== 'ENOENT') {\n            throw hotReloaderError\n          }\n        }\n\n        res.statusCode = 404\n        return this.renderErrorToHTML(null, req, res, pathname, query)\n      }\n      if (!this.quiet) console.error(err)\n    }\n    const html = await super.renderToHTML(req, res, pathname, query)\n    return html\n  }\n\n  async renderErrorToHTML(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: { [key: string]: string }\n  ): Promise<string | null> {\n    await this.devReady\n    if (res.statusCode === 404 && (await this.hasPage('/404'))) {\n      await this.hotReloader!.ensurePage('/404')\n    } else {\n      await this.hotReloader!.ensurePage('/_error')\n    }\n\n    const compilationErr = await this.getCompilationError(pathname)\n    if (compilationErr) {\n      res.statusCode = 500\n      return super.renderErrorToHTML(compilationErr, req, res, pathname, query)\n    }\n\n    if (!err && res.statusCode === 500) {\n      err = new Error(\n        'An undefined error was thrown sometime during render... ' +\n          'See https://err.sh/vercel/next.js/threw-undefined'\n      )\n    }\n\n    try {\n      const out = await super.renderErrorToHTML(err, req, res, pathname, query)\n      return out\n    } catch (err2) {\n      if (!this.quiet) Log.error(err2)\n      res.statusCode = 500\n      return super.renderErrorToHTML(err2, req, res, pathname, query)\n    }\n  }\n\n  sendHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    html: string\n  ): Promise<void> {\n    // In dev, we should not cache pages for any reason.\n    res.setHeader('Cache-Control', 'no-store, must-revalidate')\n    return super.sendHTML(req, res, html)\n  }\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'no-store, must-revalidate')\n  }\n\n  private servePublic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathParts: string[]\n  ): Promise<void> {\n    const p = pathJoin(this.publicDir, ...pathParts)\n    return this.serveStatic(req, res, p)\n  }\n\n  async hasPublicFile(path: string): Promise<boolean> {\n    try {\n      const info = await fs.promises.stat(pathJoin(this.publicDir, path))\n      return info.isFile()\n    } catch (_) {\n      return false\n    }\n  }\n\n  async getCompilationError(page: string): Promise<any> {\n    const errors = await this.hotReloader!.getCompilationErrors(page)\n    if (errors.length === 0) return\n\n    // Return the very first error we found.\n    return errors[0]\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = pathResolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // During development mode, files can be added while the server is running.\n    // Checks for .next/static, .next/server, static and public.\n    // Note that in development .next/server is available for error reporting purposes.\n    // see `packages/next/next-server/server/next-server.ts` for more details.\n    if (\n      untrustedFilePath.startsWith(pathJoin(this.distDir, 'static') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.distDir, 'server') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.dir, 'static') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.dir, 'public') + sep)\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}