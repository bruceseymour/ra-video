{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _webpackSources = _interopRequireDefault(require(\"webpack-sources\"));\n\nvar _CssDependency = _interopRequireDefault(require(\"./CssDependency\"));\n\nvar _CssModule = _interopRequireDefault(require(\"./CssModule\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable class-methods-use-this */\n\n\nconst {\n  ConcatSource,\n  SourceMapSource,\n  OriginalSource\n} = _webpack.default.sources || _webpackSources.default;\nconst {\n  Template,\n  util: {\n    createHash\n  }\n} = _webpack.default;\nconst isWebpack5 = parseInt(_webpack.default.version) === 5;\nconst MODULE_TYPE = 'css/mini-extract';\nconst pluginName = 'mini-css-extract-plugin';\nconst REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/i;\nconst REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/i;\nconst REGEXP_NAME = /\\[name\\]/i;\nconst REGEXP_PLACEHOLDERS = /\\[(name|id|chunkhash)\\]/g;\nconst DEFAULT_FILENAME = '[name].css';\n\nfunction getModulesIterable(compilation, chunk) {\n  if (isWebpack5) {\n    return compilation.chunkGraph.getChunkModulesIterable(chunk);\n  }\n\n  return chunk.modulesIterable;\n}\n\nclass CssDependencyTemplate {\n  apply() {}\n\n}\n\nclass CssModuleFactory {\n  create({\n    dependencies: [dependency]\n  }, callback) {\n    callback(null, new _CssModule.default(dependency));\n  }\n\n}\n\nclass MiniCssExtractPlugin {\n  constructor(options = {}) {\n    this.options = Object.assign({\n      filename: DEFAULT_FILENAME,\n      moduleFilename: () => this.options.filename || DEFAULT_FILENAME,\n      ignoreOrder: false\n    }, options);\n\n    if (!this.options.chunkFilename) {\n      const {\n        filename\n      } = this.options; // Anything changing depending on chunk is fine\n\n      if (filename.match(REGEXP_PLACEHOLDERS)) {\n        this.options.chunkFilename = filename;\n      } else {\n        // Elsewise prefix '[id].' in front of the basename to make it changing\n        this.options.chunkFilename = filename.replace(/(^|\\/)([^/]*(?:\\?|$))/, '$1[id].$2');\n      }\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      compilation.dependencyFactories.set(_CssDependency.default, new CssModuleFactory());\n      compilation.dependencyTemplates.set(_CssDependency.default, new CssDependencyTemplate());\n\n      const renderManifestFn = (result, {\n        chunk\n      }) => {\n        const renderedModules = Array.from(getModulesIterable(compilation, chunk)).filter(module => module.type === MODULE_TYPE);\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () => this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener),\n            filenameTemplate: ({\n              chunk: chunkData\n            }) => this.options.moduleFilename(chunkData),\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE]\n          });\n        }\n      };\n\n      if (isWebpack5) {\n        compilation.hooks.renderManifest.tap(pluginName, renderManifestFn);\n      } else {\n        // In webpack 5 the 2 separate hooks are now one hook: `compilation.hooks.renderManifest`\n        // So we no longer have to double-apply the same function\n        compilation.mainTemplate.hooks.renderManifest.tap(pluginName, renderManifestFn);\n        compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, renderManifestFn);\n      }\n\n      const handleHashForChunk = (hash, chunk) => {\n        const {\n          chunkFilename\n        } = this.options;\n\n        if (REGEXP_CHUNKHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n\n        if (REGEXP_CONTENTHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}));\n        }\n\n        if (REGEXP_NAME.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      };\n\n      if (isWebpack5) {\n        const JSModulesHooks = _webpack.default.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);\n\n        JSModulesHooks.chunkHash.tap(pluginName, (chunk, hash) => {\n          if (!chunk.hasRuntime()) return;\n          return handleHashForChunk(hash, chunk);\n        });\n      } else {\n        compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, handleHashForChunk);\n      }\n\n      compilation.hooks.contentHash.tap(pluginName, chunk => {\n        const {\n          outputOptions\n        } = compilation;\n        const {\n          hashFunction,\n          hashDigest,\n          hashDigestLength\n        } = outputOptions;\n        const hash = createHash(hashFunction);\n        const modules = getModulesIterable(compilation, chunk);\n\n        if (modules) {\n          if (isWebpack5) {\n            const xor = new (require('webpack/lib/util/StringXor'))();\n\n            for (const m of modules) {\n              if (m.type === MODULE_TYPE) {\n                xor.add(compilation.chunkGraph.getModuleHash(m, chunk.runtime));\n              }\n            }\n\n            xor.updateHash(hash);\n          } else {\n            for (const m of modules) {\n              if (m.type === MODULE_TYPE) {\n                m.updateHash(hash);\n              }\n            }\n          }\n        }\n\n        const {\n          contentHash\n        } = chunk;\n        contentHash[MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);\n      });\n      const {\n        mainTemplate\n      } = compilation;\n      mainTemplate.hooks.localVars.tap(pluginName, (source, chunk) => {\n        const chunkMap = this.getCssChunkObject(compilation, chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(',\\n')), '};']);\n        }\n\n        return source;\n      });\n      mainTemplate.hooks.requireEnsure.tap(pluginName, (source, chunk, hash) => {\n        const chunkMap = this.getCssChunkObject(compilation, chunk);\n\n        if (Object.keys(chunkMap).length > 0) {\n          const chunkMaps = chunk.getChunkMaps();\n          const {\n            crossOriginLoading\n          } = mainTemplate.outputOptions;\n          const linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(this.options.chunkFilename), {\n            hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n            hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n            chunk: {\n              id: '\" + chunkId + \"',\n              hash: `\" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + \"`,\n\n              hashWithLength(length) {\n                const shortChunkHashMap = Object.create(null);\n\n                for (const chunkId of Object.keys(chunkMaps.hash)) {\n                  if (typeof chunkMaps.hash[chunkId] === 'string') {\n                    shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);\n                  }\n                }\n\n                return `\" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + \"`;\n              },\n\n              contentHash: {\n                [MODULE_TYPE]: `\" + ${JSON.stringify(chunkMaps.contentHash[MODULE_TYPE])}[chunkId] + \"`\n              },\n              contentHashWithLength: {\n                [MODULE_TYPE]: length => {\n                  const shortContentHashMap = {};\n                  const contentHash = chunkMaps.contentHash[MODULE_TYPE];\n\n                  for (const chunkId of Object.keys(contentHash)) {\n                    if (typeof contentHash[chunkId] === 'string') {\n                      shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);\n                    }\n                  }\n\n                  return `\" + ${JSON.stringify(shortContentHashMap)}[chunkId] + \"`;\n                }\n              },\n              name: `\" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + \"`\n            },\n            contentHashType: MODULE_TYPE\n          });\n          return Template.asString([source, '', `// ${pluginName} CSS loading`, `var cssChunks = ${JSON.stringify(chunkMap)};`, 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent([`var href = ${linkHrefPath};`, `var fullhref = ${mainTemplate.requireFn}.p + href;`, 'var existingLinkTags = document.getElementsByTagName(\"link\");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");', 'if(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName(\"style\");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute(\"data-href\");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement(\"link\");', 'linkTag.rel = \"stylesheet\";', 'linkTag.type = \"text/css\";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\\\n(\" + request + \")\");', 'err.code = \"CSS_CHUNK_LOAD_FAILED\";', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString([`if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {`, Template.indent(`linkTag.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), '}']) : '', 'var head = document.getElementsByTagName(\"head\")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);\n        }\n\n        return source;\n      });\n    });\n  }\n\n  getCssChunkObject(compilation, mainChunk) {\n    const obj = {};\n\n    for (const chunk of mainChunk.getAllAsyncChunks()) {\n      for (const module of getModulesIterable(compilation, chunk)) {\n        if (module.type === MODULE_TYPE) {\n          obj[chunk.id] = 1;\n          break;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  renderContentAsset(compilation, chunk, modules, requestShortener) {\n    let usedModules;\n    const [chunkGroup] = chunk.groupsIterable;\n    const getModulePostOrderIndex = chunkGroup.getModulePostOrderIndex || chunkGroup.getModuleIndex2;\n\n    if (typeof getModulePostOrderIndex === 'function') {\n      // Store dependencies for modules\n      const moduleDependencies = new Map(modules.map(m => [m, new Set()]));\n      const moduleDependenciesReasons = new Map(modules.map(m => [m, new Map()])); // Get ordered list of modules per chunk group\n      // This loop also gathers dependencies from the ordered lists\n      // Lists are in reverse order to allow to use Array.pop()\n\n      const modulesByChunkGroup = Array.from(chunk.groupsIterable, cg => {\n        const sortedModules = modules.map(m => {\n          return {\n            module: m,\n            index: isWebpack5 ? cg.getModulePostOrderIndex(m) : cg.getModuleIndex2(m)\n          };\n        }) // eslint-disable-next-line no-undefined\n        .filter(item => item.index !== undefined).sort((a, b) => b.index - a.index).map(item => item.module);\n\n        for (let i = 0; i < sortedModules.length; i++) {\n          const set = moduleDependencies.get(sortedModules[i]);\n          const reasons = moduleDependenciesReasons.get(sortedModules[i]);\n\n          for (let j = i + 1; j < sortedModules.length; j++) {\n            const module = sortedModules[j];\n            set.add(module);\n            const reason = reasons.get(module) || new Set();\n            reason.add(cg);\n            reasons.set(module, reason);\n          }\n        }\n\n        return sortedModules;\n      }); // set with already included modules in correct order\n\n      usedModules = new Set();\n\n      const unusedModulesFilter = m => !usedModules.has(m);\n\n      while (usedModules.size < modules.length) {\n        let success = false;\n        let bestMatch;\n        let bestMatchDeps; // get first module where dependencies are fulfilled\n\n        for (const list of modulesByChunkGroup) {\n          // skip and remove already added modules\n          while (list.length > 0 && usedModules.has(list[list.length - 1])) {\n            list.pop();\n          } // skip empty lists\n\n\n          if (list.length !== 0) {\n            const module = list[list.length - 1];\n            const deps = moduleDependencies.get(module); // determine dependencies that are not yet included\n\n            const failedDeps = Array.from(deps).filter(unusedModulesFilter); // store best match for fallback behavior\n\n            if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {\n              bestMatch = list;\n              bestMatchDeps = failedDeps;\n            }\n\n            if (failedDeps.length === 0) {\n              // use this module and remove it from list\n              usedModules.add(list.pop());\n              success = true;\n              break;\n            }\n          }\n        }\n\n        if (!success) {\n          // no module found => there is a conflict\n          // use list with fewest failed deps\n          // and emit a warning\n          const fallbackModule = bestMatch.pop();\n\n          if (!this.options.ignoreOrder) {\n            const reasons = moduleDependenciesReasons.get(fallbackModule);\n            compilation.warnings.push(new Error([`chunk ${chunk.name || chunk.id} [${pluginName}]`, 'Conflicting order. Following module has been added:', ` * ${fallbackModule.readableIdentifier(requestShortener)}`, 'despite it was not able to fulfill desired ordering with these modules:', ...bestMatchDeps.map(m => {\n              const goodReasonsMap = moduleDependenciesReasons.get(m);\n              const goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);\n              const failedChunkGroups = Array.from(reasons.get(m), cg => cg.name).join(', ');\n              const goodChunkGroups = goodReasons && Array.from(goodReasons, cg => cg.name).join(', ');\n              return [` * ${m.readableIdentifier(requestShortener)}`, `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups}`, goodChunkGroups && `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups}`].filter(Boolean).join('\\n');\n            })].join('\\n')));\n          }\n\n          usedModules.add(fallbackModule);\n        }\n      }\n    } else {\n      // fallback for older webpack versions\n      // (to avoid a breaking change)\n      // TODO remove this in next major version\n      // and increase minimum webpack version to 4.12.0\n      modules.sort((a, b) => a.index2 - b.index2);\n      usedModules = modules;\n    }\n\n    const source = new ConcatSource();\n    const externalsSource = new ConcatSource();\n\n    for (const m of usedModules) {\n      if (/^@import url/.test(m.content)) {\n        // HACK for IE\n        // http://stackoverflow.com/a/14676665/1458162\n        let {\n          content\n        } = m;\n\n        if (m.media) {\n          // insert media into the @import\n          // this is rar\n          // TODO improve this and parse the CSS to support multiple medias\n          content = content.replace(/;|\\s*$/, m.media);\n        }\n\n        externalsSource.add(content);\n        externalsSource.add('\\n');\n      } else {\n        if (m.media) {\n          source.add(`@media ${m.media} {\\n`);\n        }\n\n        if (m.sourceMap) {\n          source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));\n        } else {\n          source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));\n        }\n\n        source.add('\\n');\n\n        if (m.media) {\n          source.add('}\\n');\n        }\n      }\n    }\n\n    return new ConcatSource(externalsSource, source);\n  }\n\n}\n\nMiniCssExtractPlugin.loader = require.resolve('./loader');\nvar _default = MiniCssExtractPlugin;\nexports.default = _default;","map":{"version":3,"sources":["../../../../../../build/webpack/plugins/mini-css-extract-plugin/src/index.js"],"names":["webpack","sources","util","isWebpack5","parseInt","MODULE_TYPE","pluginName","REGEXP_CHUNKHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_PLACEHOLDERS","DEFAULT_FILENAME","compilation","chunk","CssDependencyTemplate","apply","CssModuleFactory","create","dependencies","callback","CssModule","MiniCssExtractPlugin","constructor","options","Object","filename","moduleFilename","ignoreOrder","compiler","CssDependency","renderManifestFn","renderedModules","Array","getModulesIterable","module","result","render","filenameTemplate","pathOptions","contentHashType","identifier","id","hash","handleHashForChunk","JSON","JSModulesHooks","createHash","modules","xor","require","m","contentHash","mainTemplate","chunkMap","Template","chunkMaps","linkHrefPath","hashWithLength","length","shortChunkHashMap","contentHashWithLength","shortContentHashMap","name","requireFn","crossOriginLoading","getCssChunkObject","obj","mainChunk","renderContentAsset","getModulePostOrderIndex","chunkGroup","moduleDependencies","moduleDependenciesReasons","modulesByChunkGroup","cg","sortedModules","index","item","b","a","i","set","reasons","j","reason","usedModules","unusedModulesFilter","success","list","deps","failedDeps","bestMatchDeps","bestMatch","fallbackModule","goodReasonsMap","goodReasons","failedChunkGroups","goodChunkGroups","source","externalsSource","content","media"],"mappings":"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","sourcesContent":["/* eslint-disable class-methods-use-this */\n\nimport webpack from 'webpack'\nimport sources from 'webpack-sources'\n\nimport CssDependency from './CssDependency'\nimport CssModule from './CssModule'\n\nconst { ConcatSource, SourceMapSource, OriginalSource } =\n  webpack.sources || sources\nconst {\n  Template,\n  util: { createHash },\n} = webpack\n\nconst isWebpack5 = parseInt(webpack.version) === 5\nconst MODULE_TYPE = 'css/mini-extract'\n\nconst pluginName = 'mini-css-extract-plugin'\n\nconst REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/i\nconst REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/i\nconst REGEXP_NAME = /\\[name\\]/i\nconst REGEXP_PLACEHOLDERS = /\\[(name|id|chunkhash)\\]/g\nconst DEFAULT_FILENAME = '[name].css'\n\nfunction getModulesIterable(compilation, chunk) {\n  if (isWebpack5) {\n    return compilation.chunkGraph.getChunkModulesIterable(chunk)\n  }\n\n  return chunk.modulesIterable\n}\n\nclass CssDependencyTemplate {\n  apply() {}\n}\n\nclass CssModuleFactory {\n  create({ dependencies: [dependency] }, callback) {\n    callback(null, new CssModule(dependency))\n  }\n}\n\nclass MiniCssExtractPlugin {\n  constructor(options = {}) {\n    this.options = Object.assign(\n      {\n        filename: DEFAULT_FILENAME,\n        moduleFilename: () => this.options.filename || DEFAULT_FILENAME,\n        ignoreOrder: false,\n      },\n      options\n    )\n\n    if (!this.options.chunkFilename) {\n      const { filename } = this.options\n\n      // Anything changing depending on chunk is fine\n      if (filename.match(REGEXP_PLACEHOLDERS)) {\n        this.options.chunkFilename = filename\n      } else {\n        // Elsewise prefix '[id].' in front of the basename to make it changing\n        this.options.chunkFilename = filename.replace(\n          /(^|\\/)([^/]*(?:\\?|$))/,\n          '$1[id].$2'\n        )\n      }\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {\n      compilation.dependencyFactories.set(CssDependency, new CssModuleFactory())\n\n      compilation.dependencyTemplates.set(\n        CssDependency,\n        new CssDependencyTemplate()\n      )\n\n      const renderManifestFn = (result, { chunk }) => {\n        const renderedModules = Array.from(\n          getModulesIterable(compilation, chunk)\n        ).filter((module) => module.type === MODULE_TYPE)\n\n        if (renderedModules.length > 0) {\n          result.push({\n            render: () =>\n              this.renderContentAsset(\n                compilation,\n                chunk,\n                renderedModules,\n                compilation.runtimeTemplate.requestShortener\n              ),\n            filenameTemplate: ({ chunk: chunkData }) =>\n              this.options.moduleFilename(chunkData),\n            pathOptions: {\n              chunk,\n              contentHashType: MODULE_TYPE,\n            },\n            identifier: `${pluginName}.${chunk.id}`,\n            hash: chunk.contentHash[MODULE_TYPE],\n          })\n        }\n      }\n\n      if (isWebpack5) {\n        compilation.hooks.renderManifest.tap(pluginName, renderManifestFn)\n      } else {\n        // In webpack 5 the 2 separate hooks are now one hook: `compilation.hooks.renderManifest`\n        // So we no longer have to double-apply the same function\n        compilation.mainTemplate.hooks.renderManifest.tap(\n          pluginName,\n          renderManifestFn\n        )\n        compilation.chunkTemplate.hooks.renderManifest.tap(\n          pluginName,\n          renderManifestFn\n        )\n      }\n\n      const handleHashForChunk = (hash, chunk) => {\n        const { chunkFilename } = this.options\n\n        if (REGEXP_CHUNKHASH.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash))\n        }\n\n        if (REGEXP_CONTENTHASH.test(chunkFilename)) {\n          hash.update(\n            JSON.stringify(\n              chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}\n            )\n          )\n        }\n\n        if (REGEXP_NAME.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name))\n        }\n      }\n      if (isWebpack5) {\n        const JSModulesHooks = webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(\n          compilation\n        )\n        JSModulesHooks.chunkHash.tap(pluginName, (chunk, hash) => {\n          if (!chunk.hasRuntime()) return\n          return handleHashForChunk(hash, chunk)\n        })\n      } else {\n        compilation.mainTemplate.hooks.hashForChunk.tap(\n          pluginName,\n          handleHashForChunk\n        )\n      }\n\n      compilation.hooks.contentHash.tap(pluginName, (chunk) => {\n        const { outputOptions } = compilation\n        const { hashFunction, hashDigest, hashDigestLength } = outputOptions\n        const hash = createHash(hashFunction)\n\n        const modules = getModulesIterable(compilation, chunk)\n\n        if (modules) {\n          if (isWebpack5) {\n            const xor = new (require('webpack/lib/util/StringXor'))()\n            for (const m of modules) {\n              if (m.type === MODULE_TYPE) {\n                xor.add(compilation.chunkGraph.getModuleHash(m, chunk.runtime))\n              }\n            }\n            xor.updateHash(hash)\n          } else {\n            for (const m of modules) {\n              if (m.type === MODULE_TYPE) {\n                m.updateHash(hash)\n              }\n            }\n          }\n        }\n\n        const { contentHash } = chunk\n\n        contentHash[MODULE_TYPE] = hash\n          .digest(hashDigest)\n          .substring(0, hashDigestLength)\n      })\n\n      const { mainTemplate } = compilation\n\n      mainTemplate.hooks.localVars.tap(pluginName, (source, chunk) => {\n        const chunkMap = this.getCssChunkObject(compilation, chunk)\n\n        if (Object.keys(chunkMap).length > 0) {\n          return Template.asString([\n            source,\n            '',\n            '// object to store loaded CSS chunks',\n            'var installedCssChunks = {',\n            Template.indent(\n              chunk.ids.map((id) => `${JSON.stringify(id)}: 0`).join(',\\n')\n            ),\n            '};',\n          ])\n        }\n\n        return source\n      })\n\n      mainTemplate.hooks.requireEnsure.tap(\n        pluginName,\n        (source, chunk, hash) => {\n          const chunkMap = this.getCssChunkObject(compilation, chunk)\n\n          if (Object.keys(chunkMap).length > 0) {\n            const chunkMaps = chunk.getChunkMaps()\n            const { crossOriginLoading } = mainTemplate.outputOptions\n            const linkHrefPath = mainTemplate.getAssetPath(\n              JSON.stringify(this.options.chunkFilename),\n              {\n                hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n                hashWithLength: (length) =>\n                  `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n                chunk: {\n                  id: '\" + chunkId + \"',\n                  hash: `\" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + \"`,\n                  hashWithLength(length) {\n                    const shortChunkHashMap = Object.create(null)\n\n                    for (const chunkId of Object.keys(chunkMaps.hash)) {\n                      if (typeof chunkMaps.hash[chunkId] === 'string') {\n                        shortChunkHashMap[chunkId] = chunkMaps.hash[\n                          chunkId\n                        ].substring(0, length)\n                      }\n                    }\n\n                    return `\" + ${JSON.stringify(\n                      shortChunkHashMap\n                    )}[chunkId] + \"`\n                  },\n                  contentHash: {\n                    [MODULE_TYPE]: `\" + ${JSON.stringify(\n                      chunkMaps.contentHash[MODULE_TYPE]\n                    )}[chunkId] + \"`,\n                  },\n                  contentHashWithLength: {\n                    [MODULE_TYPE]: (length) => {\n                      const shortContentHashMap = {}\n                      const contentHash = chunkMaps.contentHash[MODULE_TYPE]\n\n                      for (const chunkId of Object.keys(contentHash)) {\n                        if (typeof contentHash[chunkId] === 'string') {\n                          shortContentHashMap[chunkId] = contentHash[\n                            chunkId\n                          ].substring(0, length)\n                        }\n                      }\n\n                      return `\" + ${JSON.stringify(\n                        shortContentHashMap\n                      )}[chunkId] + \"`\n                    },\n                  },\n                  name: `\" + (${JSON.stringify(\n                    chunkMaps.name\n                  )}[chunkId]||chunkId) + \"`,\n                },\n                contentHashType: MODULE_TYPE,\n              }\n            )\n\n            return Template.asString([\n              source,\n              '',\n              `// ${pluginName} CSS loading`,\n              `var cssChunks = ${JSON.stringify(chunkMap)};`,\n              'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);',\n              'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {',\n              Template.indent([\n                'promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {',\n                Template.indent([\n                  `var href = ${linkHrefPath};`,\n                  `var fullhref = ${mainTemplate.requireFn}.p + href;`,\n                  'var existingLinkTags = document.getElementsByTagName(\"link\");',\n                  'for(var i = 0; i < existingLinkTags.length; i++) {',\n                  Template.indent([\n                    'var tag = existingLinkTags[i];',\n                    'var dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");',\n                    'if(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();',\n                  ]),\n                  '}',\n                  'var existingStyleTags = document.getElementsByTagName(\"style\");',\n                  'for(var i = 0; i < existingStyleTags.length; i++) {',\n                  Template.indent([\n                    'var tag = existingStyleTags[i];',\n                    'var dataHref = tag.getAttribute(\"data-href\");',\n                    'if(dataHref === href || dataHref === fullhref) return resolve();',\n                  ]),\n                  '}',\n                  'var linkTag = document.createElement(\"link\");',\n                  'linkTag.rel = \"stylesheet\";',\n                  'linkTag.type = \"text/css\";',\n                  'linkTag.onload = resolve;',\n                  'linkTag.onerror = function(event) {',\n                  Template.indent([\n                    'var request = event && event.target && event.target.src || fullhref;',\n                    'var err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\\\n(\" + request + \")\");',\n                    'err.code = \"CSS_CHUNK_LOAD_FAILED\";',\n                    'err.request = request;',\n                    'delete installedCssChunks[chunkId]',\n                    'linkTag.parentNode.removeChild(linkTag)',\n                    'reject(err);',\n                  ]),\n                  '};',\n                  'linkTag.href = fullhref;',\n                  crossOriginLoading\n                    ? Template.asString([\n                        `if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {`,\n                        Template.indent(\n                          `linkTag.crossOrigin = ${JSON.stringify(\n                            crossOriginLoading\n                          )};`\n                        ),\n                        '}',\n                      ])\n                    : '',\n                  'var head = document.getElementsByTagName(\"head\")[0];',\n                  'head.appendChild(linkTag);',\n                ]),\n                '}).then(function() {',\n                Template.indent(['installedCssChunks[chunkId] = 0;']),\n                '}));',\n              ]),\n              '}',\n            ])\n          }\n\n          return source\n        }\n      )\n    })\n  }\n\n  getCssChunkObject(compilation, mainChunk) {\n    const obj = {}\n\n    for (const chunk of mainChunk.getAllAsyncChunks()) {\n      for (const module of getModulesIterable(compilation, chunk)) {\n        if (module.type === MODULE_TYPE) {\n          obj[chunk.id] = 1\n          break\n        }\n      }\n    }\n\n    return obj\n  }\n\n  renderContentAsset(compilation, chunk, modules, requestShortener) {\n    let usedModules\n\n    const [chunkGroup] = chunk.groupsIterable\n\n    const getModulePostOrderIndex =\n      chunkGroup.getModulePostOrderIndex || chunkGroup.getModuleIndex2\n    if (typeof getModulePostOrderIndex === 'function') {\n      // Store dependencies for modules\n      const moduleDependencies = new Map(modules.map((m) => [m, new Set()]))\n      const moduleDependenciesReasons = new Map(\n        modules.map((m) => [m, new Map()])\n      )\n\n      // Get ordered list of modules per chunk group\n      // This loop also gathers dependencies from the ordered lists\n      // Lists are in reverse order to allow to use Array.pop()\n      const modulesByChunkGroup = Array.from(chunk.groupsIterable, (cg) => {\n        const sortedModules = modules\n          .map((m) => {\n            return {\n              module: m,\n              index: isWebpack5\n                ? cg.getModulePostOrderIndex(m)\n                : cg.getModuleIndex2(m),\n            }\n          })\n          // eslint-disable-next-line no-undefined\n          .filter((item) => item.index !== undefined)\n          .sort((a, b) => b.index - a.index)\n          .map((item) => item.module)\n\n        for (let i = 0; i < sortedModules.length; i++) {\n          const set = moduleDependencies.get(sortedModules[i])\n          const reasons = moduleDependenciesReasons.get(sortedModules[i])\n\n          for (let j = i + 1; j < sortedModules.length; j++) {\n            const module = sortedModules[j]\n            set.add(module)\n            const reason = reasons.get(module) || new Set()\n            reason.add(cg)\n            reasons.set(module, reason)\n          }\n        }\n\n        return sortedModules\n      })\n\n      // set with already included modules in correct order\n      usedModules = new Set()\n\n      const unusedModulesFilter = (m) => !usedModules.has(m)\n\n      while (usedModules.size < modules.length) {\n        let success = false\n        let bestMatch\n        let bestMatchDeps\n\n        // get first module where dependencies are fulfilled\n        for (const list of modulesByChunkGroup) {\n          // skip and remove already added modules\n          while (list.length > 0 && usedModules.has(list[list.length - 1])) {\n            list.pop()\n          }\n\n          // skip empty lists\n          if (list.length !== 0) {\n            const module = list[list.length - 1]\n            const deps = moduleDependencies.get(module)\n            // determine dependencies that are not yet included\n            const failedDeps = Array.from(deps).filter(unusedModulesFilter)\n\n            // store best match for fallback behavior\n            if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {\n              bestMatch = list\n              bestMatchDeps = failedDeps\n            }\n\n            if (failedDeps.length === 0) {\n              // use this module and remove it from list\n              usedModules.add(list.pop())\n              success = true\n              break\n            }\n          }\n        }\n\n        if (!success) {\n          // no module found => there is a conflict\n          // use list with fewest failed deps\n          // and emit a warning\n          const fallbackModule = bestMatch.pop()\n\n          if (!this.options.ignoreOrder) {\n            const reasons = moduleDependenciesReasons.get(fallbackModule)\n            compilation.warnings.push(\n              new Error(\n                [\n                  `chunk ${chunk.name || chunk.id} [${pluginName}]`,\n                  'Conflicting order. Following module has been added:',\n                  ` * ${fallbackModule.readableIdentifier(requestShortener)}`,\n                  'despite it was not able to fulfill desired ordering with these modules:',\n                  ...bestMatchDeps.map((m) => {\n                    const goodReasonsMap = moduleDependenciesReasons.get(m)\n                    const goodReasons =\n                      goodReasonsMap && goodReasonsMap.get(fallbackModule)\n                    const failedChunkGroups = Array.from(\n                      reasons.get(m),\n                      (cg) => cg.name\n                    ).join(', ')\n                    const goodChunkGroups =\n                      goodReasons &&\n                      Array.from(goodReasons, (cg) => cg.name).join(', ')\n                    return [\n                      ` * ${m.readableIdentifier(requestShortener)}`,\n                      `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups}`,\n                      goodChunkGroups &&\n                        `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups}`,\n                    ]\n                      .filter(Boolean)\n                      .join('\\n')\n                  }),\n                ].join('\\n')\n              )\n            )\n          }\n\n          usedModules.add(fallbackModule)\n        }\n      }\n    } else {\n      // fallback for older webpack versions\n      // (to avoid a breaking change)\n      // TODO remove this in next major version\n      // and increase minimum webpack version to 4.12.0\n      modules.sort((a, b) => a.index2 - b.index2)\n      usedModules = modules\n    }\n\n    const source = new ConcatSource()\n    const externalsSource = new ConcatSource()\n\n    for (const m of usedModules) {\n      if (/^@import url/.test(m.content)) {\n        // HACK for IE\n        // http://stackoverflow.com/a/14676665/1458162\n        let { content } = m\n\n        if (m.media) {\n          // insert media into the @import\n          // this is rar\n          // TODO improve this and parse the CSS to support multiple medias\n          content = content.replace(/;|\\s*$/, m.media)\n        }\n\n        externalsSource.add(content)\n        externalsSource.add('\\n')\n      } else {\n        if (m.media) {\n          source.add(`@media ${m.media} {\\n`)\n        }\n\n        if (m.sourceMap) {\n          source.add(\n            new SourceMapSource(\n              m.content,\n              m.readableIdentifier(requestShortener),\n              m.sourceMap\n            )\n          )\n        } else {\n          source.add(\n            new OriginalSource(\n              m.content,\n              m.readableIdentifier(requestShortener)\n            )\n          )\n        }\n        source.add('\\n')\n\n        if (m.media) {\n          source.add('}\\n')\n        }\n      }\n    }\n\n    return new ConcatSource(externalsSource, source)\n  }\n}\n\nMiniCssExtractPlugin.loader = require.resolve('./loader')\n\nexport default MiniCssExtractPlugin\n"]},"metadata":{},"sourceType":"script"}