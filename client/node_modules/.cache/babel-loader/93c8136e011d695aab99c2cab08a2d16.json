{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.collectPlugins = exports.getPluginId = exports.VALID_MIDDLEWARE = void 0;\n\nvar _findUp = _interopRequireDefault(require(\"next/dist/compiled/find-up\"));\n\nvar _fs = require(\"fs\");\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _index = _interopRequireDefault(require(\"next/dist/compiled/resolve/index.js\"));\n\nvar _utils = require(\"../../next-server/lib/utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst {\n  version\n} = require('next/package.json'); // currently supported middleware\n\n\nconst VALID_MIDDLEWARE = ['document-head-tags-server', 'on-init-client', 'on-init-server', 'on-error-client', 'on-error-server', 'babel-preset-build'];\nexports.VALID_MIDDLEWARE = VALID_MIDDLEWARE;\n\nconst exitWithError = error => {\n  console.error(error);\n  process.exit(1);\n};\n\nasync function collectPluginMeta(env, pluginPackagePath, pluginName, requiredVersion) {\n  const pkgDir = _path.default.dirname(pluginPackagePath);\n\n  const pluginPackageJson = require(pluginPackagePath);\n\n  const pluginMetaData = pluginPackageJson.nextjs;\n\n  if (pluginPackageJson.version !== requiredVersion) {\n    exitWithError(`Next.js plugin versions must match the Next.js version being used, received ${pluginName}@${pluginPackageJson.version} need ${requiredVersion}`);\n  }\n\n  if (!pluginMetaData) {\n    exitWithError(`Next.js plugins need to have a \"nextjs\" key in package.json for ${pluginName}`);\n  }\n\n  if (!pluginMetaData.name) {\n    exitWithError(`Next.js plugins need to have a \"nextjs.name\" key in package.json for ${pluginName}`);\n  } // TODO: add err.sh explaining requirements\n\n\n  let middleware = [];\n\n  try {\n    middleware = (await _fs.promises.readdir(_path.default.join(pkgDir, 'src'), {\n      withFileTypes: true\n    })).filter(dirent => dirent.isFile()).map(file => file.name);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      console.error(err);\n    }\n\n    exitWithError(`Failed to read src/ directory for Next.js plugin: ${pluginName}`);\n  } // remove the extension from the middleware\n\n\n  middleware = middleware.map(item => {\n    const parts = item.split('.');\n    parts.pop();\n    return parts.join('.');\n  });\n  const invalidMiddleware = [];\n\n  for (const item of middleware) {\n    if (!VALID_MIDDLEWARE.includes(item)) {\n      invalidMiddleware.push(item);\n    }\n  }\n\n  if (invalidMiddleware.length > 0) {\n    console.error(`Next.js Plugin: ${pluginName} listed invalid middleware ${invalidMiddleware.join(', ')}`);\n  } // TODO: investigate requiring plugins' env be prefixed\n  // somehow to prevent collision\n\n\n  if (!Array.isArray(pluginMetaData['required-env'])) {\n    exitWithError('Next.js plugins need to have a \"nextjs.required-env\" key in package.json');\n  }\n\n  const missingEnvFields = [];\n\n  for (const field of pluginMetaData['required-env']) {\n    if (typeof env[field] === 'undefined') {\n      missingEnvFields.push(field);\n    }\n  }\n\n  if (missingEnvFields.length > 0) {\n    exitWithError(`Next.js Plugin: ${pluginName} required env ${missingEnvFields.join(', ')} but was missing in your \\`next.config.js\\``);\n  }\n\n  return {\n    middleware,\n    directory: pkgDir.replace(/\\\\/g, '/'),\n    requiredEnv: pluginMetaData['required-env'],\n    version: pluginPackageJson.version,\n    pluginName: pluginMetaData.name,\n    pkgName: pluginPackageJson.name\n  };\n} // clean package name so it can be used as variable\n\n\nconst getPluginId = pkg => {\n  pkg = pkg.replace(/\\W/g, '');\n\n  if (pkg.match(/^[0-9]/)) {\n    pkg = `_${pkg}`;\n  }\n\n  return pkg;\n};\n\nexports.getPluginId = getPluginId;\n\nasync function _collectPlugins(dir, env, pluginsConfig) {\n  let nextPluginNames = [];\n  const skippedPluginNames = [];\n  const hasPluginConfig = Array.isArray(pluginsConfig);\n  const nextPluginConfigNames = hasPluginConfig ? pluginsConfig.map(config => typeof config === 'string' ? config : config.name) : null;\n  const rootPackageJsonPath = await (0, _findUp.default)('package.json', {\n    cwd: dir\n  });\n\n  if (!rootPackageJsonPath && !nextPluginConfigNames) {\n    console.log('Failed to load plugins, no package.json');\n    return [];\n  }\n\n  if (rootPackageJsonPath) {\n    const rootPackageJson = require(rootPackageJsonPath);\n\n    let dependencies = [];\n\n    if (rootPackageJson.dependencies) {\n      dependencies = dependencies.concat(Object.keys(rootPackageJson.dependencies));\n    }\n\n    if (rootPackageJson.devDependencies) {\n      dependencies = dependencies.concat(Object.keys(rootPackageJson.devDependencies));\n    } // find packages with the naming convention\n    // @next/plugin-[name]\n\n\n    const filteredDeps = dependencies.filter(name => {\n      return name.match(/^@next\\/plugin/);\n    });\n\n    if (nextPluginConfigNames) {\n      for (const dep of filteredDeps) {\n        if (!nextPluginConfigNames.includes(dep)) {\n          skippedPluginNames.push(dep);\n        }\n      }\n\n      nextPluginNames = nextPluginConfigNames;\n    } else {\n      nextPluginNames = filteredDeps;\n    }\n  }\n\n  const nextPluginMetaData = await Promise.all(nextPluginNames.map(name => collectPluginMeta(env, _index.default.sync(_path.default.join(name, 'package.json'), {\n    basedir: dir,\n    preserveSymlinks: true\n  }), name, version)));\n\n  for (const plugin of nextPluginMetaData) {\n    // Add plugin config from `next.config.js`\n    if (hasPluginConfig) {\n      const curPlugin = pluginsConfig.find(config => config && typeof config === 'object' && config.name === plugin.pkgName);\n\n      if (curPlugin && typeof curPlugin === 'object') {\n        plugin.config = curPlugin.config;\n      }\n    }\n\n    console.log(`Loaded plugin: ${plugin.pkgName}${plugin.version ? `@${plugin.version}` : ''}`);\n  }\n\n  if (skippedPluginNames.length) {\n    console.log(`Plugins config used skipped loading: ${skippedPluginNames.join(', ')}`);\n  }\n\n  console.log();\n  return nextPluginMetaData;\n} // only execute it once between server/client configs\n// since the plugins need to match\n\n\nconst collectPlugins = (0, _utils.execOnce)(_collectPlugins);\nexports.collectPlugins = collectPlugins;","map":{"version":3,"sources":["../../../build/plugins/collect-plugins.ts"],"names":["require","VALID_MIDDLEWARE","exitWithError","error","console","process","pkgDir","path","pluginPackageJson","pluginMetaData","pluginName","version","requiredVersion","middleware","promises","withFileTypes","dirent","file","err","item","parts","invalidMiddleware","Array","missingEnvFields","env","directory","requiredEnv","pkgName","getPluginId","pkg","nextPluginNames","skippedPluginNames","hasPluginConfig","nextPluginConfigNames","pluginsConfig","config","rootPackageJsonPath","cwd","rootPackageJson","dependencies","Object","filteredDeps","name","nextPluginMetaData","Promise","collectPluginMeta","resolve","basedir","preserveSymlinks","curPlugin","plugin","collectPlugins"],"mappings":"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","sourcesContent":["import findUp from 'next/dist/compiled/find-up'\nimport { promises } from 'fs'\nimport path from 'path'\nimport resolve from 'next/dist/compiled/resolve/index.js'\nimport { execOnce } from '../../next-server/lib/utils'\n\nconst { version } = require('next/package.json')\n\nexport type PluginMetaData = {\n  requiredEnv: string[]\n  middleware: string[]\n  pluginName: string\n  directory: string\n  pkgName: string\n  version: string\n  config?: { [name: string]: any }\n}\n\n// currently supported middleware\nexport const VALID_MIDDLEWARE = [\n  'document-head-tags-server',\n  'on-init-client',\n  'on-init-server',\n  'on-error-client',\n  'on-error-server',\n  'babel-preset-build',\n]\n\ntype ENV_OPTIONS = { [name: string]: string }\n\nconst exitWithError = (error: string) => {\n  console.error(error)\n  process.exit(1)\n}\n\nasync function collectPluginMeta(\n  env: ENV_OPTIONS,\n  pluginPackagePath: string,\n  pluginName: string,\n  requiredVersion: string\n): Promise<PluginMetaData> {\n  const pkgDir = path.dirname(pluginPackagePath)\n  const pluginPackageJson = require(pluginPackagePath)\n  const pluginMetaData: {\n    name: string\n    'required-env': string[]\n  } = pluginPackageJson.nextjs\n\n  if (pluginPackageJson.version !== requiredVersion) {\n    exitWithError(\n      `Next.js plugin versions must match the Next.js version being used, received ${pluginName}@${pluginPackageJson.version} need ${requiredVersion}`\n    )\n  }\n\n  if (!pluginMetaData) {\n    exitWithError(\n      `Next.js plugins need to have a \"nextjs\" key in package.json for ${pluginName}`\n    )\n  }\n\n  if (!pluginMetaData.name) {\n    exitWithError(\n      `Next.js plugins need to have a \"nextjs.name\" key in package.json for ${pluginName}`\n    )\n  }\n\n  // TODO: add err.sh explaining requirements\n  let middleware: string[] = []\n  try {\n    middleware = (\n      await promises.readdir(path.join(pkgDir, 'src'), { withFileTypes: true })\n    )\n      .filter((dirent) => dirent.isFile())\n      .map((file) => file.name)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      console.error(err)\n    }\n    exitWithError(\n      `Failed to read src/ directory for Next.js plugin: ${pluginName}`\n    )\n  }\n\n  // remove the extension from the middleware\n  middleware = middleware.map((item) => {\n    const parts = item.split('.')\n    parts.pop()\n    return parts.join('.')\n  })\n\n  const invalidMiddleware: string[] = []\n\n  for (const item of middleware) {\n    if (!VALID_MIDDLEWARE.includes(item)) {\n      invalidMiddleware.push(item)\n    }\n  }\n\n  if (invalidMiddleware.length > 0) {\n    console.error(\n      `Next.js Plugin: ${pluginName} listed invalid middleware ${invalidMiddleware.join(\n        ', '\n      )}`\n    )\n  }\n\n  // TODO: investigate requiring plugins' env be prefixed\n  // somehow to prevent collision\n  if (!Array.isArray(pluginMetaData['required-env'])) {\n    exitWithError(\n      'Next.js plugins need to have a \"nextjs.required-env\" key in package.json'\n    )\n  }\n\n  const missingEnvFields: string[] = []\n\n  for (const field of pluginMetaData['required-env']) {\n    if (typeof env[field] === 'undefined') {\n      missingEnvFields.push(field)\n    }\n  }\n\n  if (missingEnvFields.length > 0) {\n    exitWithError(\n      `Next.js Plugin: ${pluginName} required env ${missingEnvFields.join(\n        ', '\n      )} but was missing in your \\`next.config.js\\``\n    )\n  }\n\n  return {\n    middleware,\n    directory: pkgDir.replace(/\\\\/g, '/'),\n    requiredEnv: pluginMetaData['required-env'],\n    version: pluginPackageJson.version,\n    pluginName: pluginMetaData.name,\n    pkgName: pluginPackageJson.name,\n  }\n}\n\n// clean package name so it can be used as variable\nexport const getPluginId = (pkg: string): string => {\n  pkg = pkg.replace(/\\W/g, '')\n\n  if (pkg.match(/^[0-9]/)) {\n    pkg = `_${pkg}`\n  }\n  return pkg\n}\n\ntype PluginConfig =\n  | string\n  | {\n      name: string\n      config: { [name: string]: any }\n    }\n\nasync function _collectPlugins(\n  dir: string,\n  env: ENV_OPTIONS,\n  pluginsConfig: PluginConfig[] | undefined\n): Promise<PluginMetaData[]> {\n  let nextPluginNames: string[] = []\n  const skippedPluginNames: string[] = []\n  const hasPluginConfig = Array.isArray(pluginsConfig)\n\n  const nextPluginConfigNames = hasPluginConfig\n    ? pluginsConfig!.map((config) =>\n        typeof config === 'string' ? config : config.name\n      )\n    : null\n\n  const rootPackageJsonPath = await findUp('package.json', { cwd: dir })\n  if (!rootPackageJsonPath && !nextPluginConfigNames) {\n    console.log('Failed to load plugins, no package.json')\n    return []\n  }\n\n  if (rootPackageJsonPath) {\n    const rootPackageJson = require(rootPackageJsonPath)\n    let dependencies: string[] = []\n    if (rootPackageJson.dependencies) {\n      dependencies = dependencies.concat(\n        Object.keys(rootPackageJson.dependencies)\n      )\n    }\n\n    if (rootPackageJson.devDependencies) {\n      dependencies = dependencies.concat(\n        Object.keys(rootPackageJson.devDependencies)\n      )\n    }\n\n    // find packages with the naming convention\n    // @next/plugin-[name]\n    const filteredDeps = dependencies.filter((name) => {\n      return name.match(/^@next\\/plugin/)\n    })\n\n    if (nextPluginConfigNames) {\n      for (const dep of filteredDeps) {\n        if (!nextPluginConfigNames.includes(dep)) {\n          skippedPluginNames.push(dep)\n        }\n      }\n      nextPluginNames = nextPluginConfigNames\n    } else {\n      nextPluginNames = filteredDeps\n    }\n  }\n\n  const nextPluginMetaData = await Promise.all(\n    nextPluginNames.map((name) =>\n      collectPluginMeta(\n        env,\n        resolve.sync(path.join(name, 'package.json'), {\n          basedir: dir,\n          preserveSymlinks: true,\n        }),\n        name,\n        version\n      )\n    )\n  )\n\n  for (const plugin of nextPluginMetaData) {\n    // Add plugin config from `next.config.js`\n    if (hasPluginConfig) {\n      const curPlugin = pluginsConfig!.find(\n        (config) =>\n          config && typeof config === 'object' && config.name === plugin.pkgName\n      )\n      if (curPlugin && typeof curPlugin === 'object') {\n        plugin.config = curPlugin.config\n      }\n    }\n    console.log(\n      `Loaded plugin: ${plugin.pkgName}${\n        plugin.version ? `@${plugin.version}` : ''\n      }`\n    )\n  }\n\n  if (skippedPluginNames.length) {\n    console.log(\n      `Plugins config used skipped loading: ${skippedPluginNames.join(', ')}`\n    )\n  }\n  console.log()\n\n  return nextPluginMetaData\n}\n\n// only execute it once between server/client configs\n// since the plugins need to match\nexport const collectPlugins = execOnce(_collectPlugins)\n"]},"metadata":{},"sourceType":"script"}