{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = onDemandEntryHandler;\nexports.entries = exports.BUILT = exports.BUILDING = exports.ADDED = void 0;\n\nvar _events = require(\"events\");\n\nvar _path = require(\"path\");\n\nvar _url = require(\"url\");\n\nvar Log = _interopRequireWildcard(require(\"../build/output/log\"));\n\nvar _normalizePagePath = require(\"../next-server/server/normalize-page-path\");\n\nvar _require = require(\"../next-server/server/require\");\n\nvar _findPageFile = require(\"./lib/find-page-file\");\n\nvar _getRouteFromEntrypoint = _interopRequireDefault(require(\"../next-server/server/get-route-from-entrypoint\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst ADDED = Symbol('added');\nexports.ADDED = ADDED;\nconst BUILDING = Symbol('building');\nexports.BUILDING = BUILDING;\nconst BUILT = Symbol('built');\nexports.BUILT = BUILT;\nlet entries = {};\nexports.entries = entries;\n\nfunction onDemandEntryHandler(watcher, multiCompiler, {\n  pagesDir,\n  pageExtensions,\n  maxInactiveAge,\n  pagesBufferLength\n}) {\n  const {\n    compilers\n  } = multiCompiler;\n  const invalidator = new Invalidator(watcher, multiCompiler);\n  let lastAccessPages = [''];\n  let doneCallbacks = new _events.EventEmitter();\n\n  for (const compiler of compilers) {\n    compiler.hooks.make.tap('NextJsOnDemandEntries', _compilation => {\n      invalidator.startBuilding();\n    });\n  }\n\n  function getPagePathsFromEntrypoints(entrypoints) {\n    const pagePaths = [];\n\n    for (const entrypoint of entrypoints.values()) {\n      const page = (0, _getRouteFromEntrypoint.default)(entrypoint.name);\n\n      if (page) {\n        pagePaths.push(page);\n      }\n    }\n\n    return pagePaths;\n  }\n\n  multiCompiler.hooks.done.tap('NextJsOnDemandEntries', multiStats => {\n    const [clientStats, serverStats] = multiStats.stats;\n    const pagePaths = new Set([...getPagePathsFromEntrypoints(clientStats.compilation.entrypoints), ...getPagePathsFromEntrypoints(serverStats.compilation.entrypoints)]);\n\n    for (const page of pagePaths) {\n      const entry = entries[page];\n\n      if (!entry) {\n        continue;\n      }\n\n      if (entry.status !== BUILDING) {\n        continue;\n      }\n\n      entry.status = BUILT;\n      entry.lastActiveTime = Date.now();\n      doneCallbacks.emit(page);\n    }\n\n    invalidator.doneBuilding();\n  });\n  const disposeHandler = setInterval(function () {\n    disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge);\n  }, 5000);\n  disposeHandler.unref();\n\n  function handlePing(pg) {\n    const page = (0, _normalizePagePath.normalizePathSep)(pg);\n    const entryInfo = entries[page];\n    let toSend; // If there's no entry, it may have been invalidated and needs to be re-built.\n\n    if (!entryInfo) {\n      // if (page !== lastEntry) client pings, but there's no entry for page\n      return {\n        invalid: true\n      };\n    } // 404 is an on demand entry but when a new page is added we have to refresh the page\n\n\n    if (page === '/_error') {\n      toSend = {\n        invalid: true\n      };\n    } else {\n      toSend = {\n        success: true\n      };\n    } // We don't need to maintain active state of anything other than BUILT entries\n\n\n    if (entryInfo.status !== BUILT) return; // If there's an entryInfo\n\n    if (!lastAccessPages.includes(page)) {\n      lastAccessPages.unshift(page); // Maintain the buffer max length\n\n      if (lastAccessPages.length > pagesBufferLength) {\n        lastAccessPages.pop();\n      }\n    }\n\n    entryInfo.lastActiveTime = Date.now();\n    return toSend;\n  }\n\n  return {\n    async ensurePage(page) {\n      let normalizedPagePath;\n\n      try {\n        normalizedPagePath = (0, _normalizePagePath.normalizePagePath)(page);\n      } catch (err) {\n        console.error(err);\n        throw (0, _require.pageNotFoundError)(page);\n      }\n\n      let pagePath = await (0, _findPageFile.findPageFile)(pagesDir, normalizedPagePath, pageExtensions); // Default the /_error route to the Next.js provided default page\n\n      if (page === '/_error' && pagePath === null) {\n        pagePath = 'next/dist/pages/_error';\n      }\n\n      if (pagePath === null) {\n        throw (0, _require.pageNotFoundError)(normalizedPagePath);\n      }\n\n      let pageUrl = pagePath.replace(/\\\\/g, '/');\n      pageUrl = `${pageUrl[0] !== '/' ? '/' : ''}${pageUrl.replace(new RegExp(`\\\\.+(?:${pageExtensions.join('|')})$`), '').replace(/\\/index$/, '')}`;\n      pageUrl = pageUrl === '' ? '/' : pageUrl;\n      const bundleFile = (0, _normalizePagePath.normalizePagePath)(pageUrl);\n\n      const serverBundlePath = _path.posix.join('pages', bundleFile);\n\n      const clientBundlePath = _path.posix.join('pages', bundleFile);\n\n      const absolutePagePath = pagePath.startsWith('next/dist/pages') ? require.resolve(pagePath) : (0, _path.join)(pagesDir, pagePath);\n      page = _path.posix.normalize(pageUrl);\n      return new Promise((resolve, reject) => {\n        // Makes sure the page that is being kept in on-demand-entries matches the webpack output\n        const normalizedPage = (0, _normalizePagePath.normalizePathSep)(page);\n        const entryInfo = entries[normalizedPage];\n\n        if (entryInfo) {\n          if (entryInfo.status === BUILT) {\n            resolve();\n            return;\n          }\n\n          if (entryInfo.status === BUILDING) {\n            doneCallbacks.once(normalizedPage, handleCallback);\n            return;\n          }\n        }\n\n        Log.event(`build page: ${normalizedPage}`);\n        entries[normalizedPage] = {\n          serverBundlePath,\n          clientBundlePath,\n          absolutePagePath,\n          status: ADDED\n        };\n        doneCallbacks.once(normalizedPage, handleCallback);\n        invalidator.invalidate();\n\n        function handleCallback(err) {\n          if (err) return reject(err);\n          resolve();\n        }\n      });\n    },\n\n    middleware(req, res, next) {\n      var _req$url;\n\n      if (!((_req$url = req.url) != null && _req$url.startsWith('/_next/webpack-hmr'))) return next();\n      const {\n        query\n      } = (0, _url.parse)(req.url, true);\n      const page = query.page;\n      if (!page) return next();\n\n      const runPing = () => {\n        const data = handlePing(query.page);\n        if (!data) return;\n        res.write('data: ' + JSON.stringify(data) + '\\n\\n');\n      };\n\n      const pingInterval = setInterval(() => runPing(), 5000);\n      req.on('close', () => {\n        clearInterval(pingInterval);\n      });\n      next();\n    }\n\n  };\n}\n\nfunction disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge) {\n  const disposingPages = [];\n  Object.keys(entries).forEach(page => {\n    const {\n      lastActiveTime,\n      status\n    } = entries[page]; // This means this entry is currently building or just added\n    // We don't need to dispose those entries.\n\n    if (status !== BUILT) return; // We should not build the last accessed page even we didn't get any pings\n    // Sometimes, it's possible our XHR ping to wait before completing other requests.\n    // In that case, we should not dispose the current viewing page\n\n    if (lastAccessPages.includes(page)) return;\n\n    if (lastActiveTime && Date.now() - lastActiveTime > maxInactiveAge) {\n      disposingPages.push(page);\n    }\n  });\n\n  if (disposingPages.length > 0) {\n    disposingPages.forEach(page => {\n      delete entries[page];\n    }); // disposing inactive page(s)\n\n    watcher.invalidate();\n  }\n} // Make sure only one invalidation happens at a time\n// Otherwise, webpack hash gets changed and it'll force the client to reload.\n\n\nclass Invalidator {\n  constructor(watcher, multiCompiler) {\n    this.multiCompiler = void 0;\n    this.watcher = void 0;\n    this.building = void 0;\n    this.rebuildAgain = void 0;\n    this.multiCompiler = multiCompiler;\n    this.watcher = watcher; // contains an array of types of compilers currently building\n\n    this.building = false;\n    this.rebuildAgain = false;\n  }\n\n  invalidate() {\n    // If there's a current build is processing, we won't abort it by invalidating.\n    // (If aborted, it'll cause a client side hard reload)\n    // But let it to invalidate just after the completion.\n    // So, it can re-build the queued pages at once.\n    if (this.building) {\n      this.rebuildAgain = true;\n      return;\n    }\n\n    this.building = true; // Work around a bug in webpack, calling `invalidate` on Watching.js\n    // doesn't trigger the invalid call used to keep track of the `.done` hook on multiCompiler\n\n    for (const compiler of this.multiCompiler.compilers) {\n      // @ts-ignore TODO: Check if this is still needed with webpack 5\n      compiler.hooks.invalid.call();\n    }\n\n    this.watcher.invalidate();\n  }\n\n  startBuilding() {\n    this.building = true;\n  }\n\n  doneBuilding() {\n    this.building = false;\n\n    if (this.rebuildAgain) {\n      this.rebuildAgain = false;\n      this.invalidate();\n    }\n  }\n\n}","map":{"version":3,"sources":["../../server/on-demand-entry-handler.ts"],"names":["ADDED","Symbol","BUILDING","BUILT","entries","invalidator","lastAccessPages","doneCallbacks","EventEmitter","compiler","_compilation","pagePaths","entrypoints","page","entrypoint","multiCompiler","multiStats","getPagePathsFromEntrypoints","clientStats","serverStats","entry","Date","disposeHandler","setInterval","disposeInactiveEntries","entryInfo","invalid","toSend","success","normalizedPagePath","console","pagePath","pageUrl","pageExtensions","bundleFile","serverBundlePath","posix","clientBundlePath","absolutePagePath","require","normalizedPage","resolve","Log","status","reject","middleware","req","next","query","runPing","data","handlePing","res","JSON","pingInterval","clearInterval","disposingPages","lastActiveTime","watcher","Invalidator","building","rebuildAgain","constructor","invalidate","startBuilding","doneBuilding"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { join, posix } from 'path'\nimport { parse } from 'url'\nimport webpack from 'webpack'\nimport * as Log from '../build/output/log'\nimport {\n  normalizePagePath,\n  normalizePathSep,\n} from '../next-server/server/normalize-page-path'\nimport { pageNotFoundError } from '../next-server/server/require'\nimport { findPageFile } from './lib/find-page-file'\nimport getRouteFromEntrypoint from '../next-server/server/get-route-from-entrypoint'\n\nexport const ADDED = Symbol('added')\nexport const BUILDING = Symbol('building')\nexport const BUILT = Symbol('built')\n\nexport let entries: {\n  [page: string]: {\n    serverBundlePath: string\n    clientBundlePath: string\n    absolutePagePath: string\n    status?: typeof ADDED | typeof BUILDING | typeof BUILT\n    lastActiveTime?: number\n  }\n} = {}\n\nexport default function onDemandEntryHandler(\n  watcher: any,\n  multiCompiler: webpack.MultiCompiler,\n  {\n    pagesDir,\n    pageExtensions,\n    maxInactiveAge,\n    pagesBufferLength,\n  }: {\n    pagesDir: string\n    pageExtensions: string[]\n    maxInactiveAge: number\n    pagesBufferLength: number\n  }\n) {\n  const { compilers } = multiCompiler\n  const invalidator = new Invalidator(watcher, multiCompiler)\n\n  let lastAccessPages = ['']\n  let doneCallbacks: EventEmitter | null = new EventEmitter()\n\n  for (const compiler of compilers) {\n    compiler.hooks.make.tap(\n      'NextJsOnDemandEntries',\n      (_compilation: webpack.compilation.Compilation) => {\n        invalidator.startBuilding()\n      }\n    )\n  }\n\n  function getPagePathsFromEntrypoints(entrypoints: any): string[] {\n    const pagePaths = []\n    for (const entrypoint of entrypoints.values()) {\n      const page = getRouteFromEntrypoint(entrypoint.name)\n      if (page) {\n        pagePaths.push(page)\n      }\n    }\n\n    return pagePaths\n  }\n\n  multiCompiler.hooks.done.tap('NextJsOnDemandEntries', (multiStats) => {\n    const [clientStats, serverStats] = multiStats.stats\n    const pagePaths = new Set([\n      ...getPagePathsFromEntrypoints(clientStats.compilation.entrypoints),\n      ...getPagePathsFromEntrypoints(serverStats.compilation.entrypoints),\n    ])\n\n    for (const page of pagePaths) {\n      const entry = entries[page]\n      if (!entry) {\n        continue\n      }\n\n      if (entry.status !== BUILDING) {\n        continue\n      }\n\n      entry.status = BUILT\n      entry.lastActiveTime = Date.now()\n      doneCallbacks!.emit(page)\n    }\n\n    invalidator.doneBuilding()\n  })\n\n  const disposeHandler = setInterval(function () {\n    disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge)\n  }, 5000)\n\n  disposeHandler.unref()\n\n  function handlePing(pg: string) {\n    const page = normalizePathSep(pg)\n    const entryInfo = entries[page]\n    let toSend\n\n    // If there's no entry, it may have been invalidated and needs to be re-built.\n    if (!entryInfo) {\n      // if (page !== lastEntry) client pings, but there's no entry for page\n      return { invalid: true }\n    }\n\n    // 404 is an on demand entry but when a new page is added we have to refresh the page\n    if (page === '/_error') {\n      toSend = { invalid: true }\n    } else {\n      toSend = { success: true }\n    }\n\n    // We don't need to maintain active state of anything other than BUILT entries\n    if (entryInfo.status !== BUILT) return\n\n    // If there's an entryInfo\n    if (!lastAccessPages.includes(page)) {\n      lastAccessPages.unshift(page)\n\n      // Maintain the buffer max length\n      if (lastAccessPages.length > pagesBufferLength) {\n        lastAccessPages.pop()\n      }\n    }\n    entryInfo.lastActiveTime = Date.now()\n    return toSend\n  }\n\n  return {\n    async ensurePage(page: string) {\n      let normalizedPagePath: string\n      try {\n        normalizedPagePath = normalizePagePath(page)\n      } catch (err) {\n        console.error(err)\n        throw pageNotFoundError(page)\n      }\n\n      let pagePath = await findPageFile(\n        pagesDir,\n        normalizedPagePath,\n        pageExtensions\n      )\n\n      // Default the /_error route to the Next.js provided default page\n      if (page === '/_error' && pagePath === null) {\n        pagePath = 'next/dist/pages/_error'\n      }\n\n      if (pagePath === null) {\n        throw pageNotFoundError(normalizedPagePath)\n      }\n\n      let pageUrl = pagePath.replace(/\\\\/g, '/')\n\n      pageUrl = `${pageUrl[0] !== '/' ? '/' : ''}${pageUrl\n        .replace(new RegExp(`\\\\.+(?:${pageExtensions.join('|')})$`), '')\n        .replace(/\\/index$/, '')}`\n\n      pageUrl = pageUrl === '' ? '/' : pageUrl\n\n      const bundleFile = normalizePagePath(pageUrl)\n      const serverBundlePath = posix.join('pages', bundleFile)\n      const clientBundlePath = posix.join('pages', bundleFile)\n      const absolutePagePath = pagePath.startsWith('next/dist/pages')\n        ? require.resolve(pagePath)\n        : join(pagesDir, pagePath)\n\n      page = posix.normalize(pageUrl)\n\n      return new Promise((resolve, reject) => {\n        // Makes sure the page that is being kept in on-demand-entries matches the webpack output\n        const normalizedPage = normalizePathSep(page)\n        const entryInfo = entries[normalizedPage]\n\n        if (entryInfo) {\n          if (entryInfo.status === BUILT) {\n            resolve()\n            return\n          }\n\n          if (entryInfo.status === BUILDING) {\n            doneCallbacks!.once(normalizedPage, handleCallback)\n            return\n          }\n        }\n\n        Log.event(`build page: ${normalizedPage}`)\n\n        entries[normalizedPage] = {\n          serverBundlePath,\n          clientBundlePath,\n          absolutePagePath,\n          status: ADDED,\n        }\n        doneCallbacks!.once(normalizedPage, handleCallback)\n\n        invalidator.invalidate()\n\n        function handleCallback(err: Error) {\n          if (err) return reject(err)\n          resolve()\n        }\n      })\n    },\n\n    middleware(req: IncomingMessage, res: ServerResponse, next: Function) {\n      if (!req.url?.startsWith('/_next/webpack-hmr')) return next()\n\n      const { query } = parse(req.url!, true)\n      const page = query.page\n      if (!page) return next()\n\n      const runPing = () => {\n        const data = handlePing(query.page as string)\n        if (!data) return\n        res.write('data: ' + JSON.stringify(data) + '\\n\\n')\n      }\n      const pingInterval = setInterval(() => runPing(), 5000)\n\n      req.on('close', () => {\n        clearInterval(pingInterval)\n      })\n      next()\n    },\n  }\n}\n\nfunction disposeInactiveEntries(\n  watcher: any,\n  lastAccessPages: any,\n  maxInactiveAge: number\n) {\n  const disposingPages: any = []\n\n  Object.keys(entries).forEach((page) => {\n    const { lastActiveTime, status } = entries[page]\n\n    // This means this entry is currently building or just added\n    // We don't need to dispose those entries.\n    if (status !== BUILT) return\n\n    // We should not build the last accessed page even we didn't get any pings\n    // Sometimes, it's possible our XHR ping to wait before completing other requests.\n    // In that case, we should not dispose the current viewing page\n    if (lastAccessPages.includes(page)) return\n\n    if (lastActiveTime && Date.now() - lastActiveTime > maxInactiveAge) {\n      disposingPages.push(page)\n    }\n  })\n\n  if (disposingPages.length > 0) {\n    disposingPages.forEach((page: any) => {\n      delete entries[page]\n    })\n    // disposing inactive page(s)\n    watcher.invalidate()\n  }\n}\n\n// Make sure only one invalidation happens at a time\n// Otherwise, webpack hash gets changed and it'll force the client to reload.\nclass Invalidator {\n  private multiCompiler: webpack.MultiCompiler\n  private watcher: any\n  private building: boolean\n  private rebuildAgain: boolean\n\n  constructor(watcher: any, multiCompiler: webpack.MultiCompiler) {\n    this.multiCompiler = multiCompiler\n    this.watcher = watcher\n    // contains an array of types of compilers currently building\n    this.building = false\n    this.rebuildAgain = false\n  }\n\n  invalidate() {\n    // If there's a current build is processing, we won't abort it by invalidating.\n    // (If aborted, it'll cause a client side hard reload)\n    // But let it to invalidate just after the completion.\n    // So, it can re-build the queued pages at once.\n    if (this.building) {\n      this.rebuildAgain = true\n      return\n    }\n\n    this.building = true\n    // Work around a bug in webpack, calling `invalidate` on Watching.js\n    // doesn't trigger the invalid call used to keep track of the `.done` hook on multiCompiler\n    for (const compiler of this.multiCompiler.compilers) {\n      // @ts-ignore TODO: Check if this is still needed with webpack 5\n      compiler.hooks.invalid.call()\n    }\n    this.watcher.invalidate()\n  }\n\n  startBuilding() {\n    this.building = true\n  }\n\n  doneBuilding() {\n    this.building = false\n\n    if (this.rebuildAgain) {\n      this.rebuildAgain = false\n      this.invalidate()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}