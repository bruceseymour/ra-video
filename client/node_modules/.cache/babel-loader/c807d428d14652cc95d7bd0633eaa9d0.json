{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.findConfig = findConfig;\n\nvar _findUp = _interopRequireDefault(require(\"next/dist/compiled/find-up\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _json = _interopRequireDefault(require(\"next/dist/compiled/json5\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // We'll allow configuration to be typed, but we force everything provided to\n// become optional. We do not perform any schema validation. We should maybe\n// force all the types to be `unknown` as well.\n\n\nasync function findConfig(directory, key) {\n  // `package.json` configuration always wins. Let's check that first.\n  const packageJsonPath = await (0, _findUp.default)('package.json', {\n    cwd: directory\n  });\n\n  if (packageJsonPath) {\n    const packageJson = require(packageJsonPath);\n\n    if (packageJson[key] != null && typeof packageJson[key] === 'object') {\n      return packageJson[key];\n    }\n  } // If we didn't find the configuration in `package.json`, we should look for\n  // known filenames.\n\n\n  const filePath = await (0, _findUp.default)([`.${key}rc.json`, `${key}.config.json`, `.${key}rc.js`, `${key}.config.js`], {\n    cwd: directory\n  });\n\n  if (filePath) {\n    if (filePath.endsWith('.js')) {\n      return require(filePath);\n    } // We load JSON contents with JSON5 to allow users to comment in their\n    // configuration file. This pattern was popularized by TypeScript.\n\n\n    const fileContents = _fs.default.readFileSync(filePath, 'utf8');\n\n    return _json.default.parse(fileContents);\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../lib/find-config.ts"],"names":["packageJsonPath","cwd","packageJson","require","filePath","key","fileContents","fs","JSON5"],"mappings":";;;;;AAAA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA;;AACA,IAAA,GAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;AACA,IAAA,KAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,0BAAA,CAAA,CAAA;;;;;;AAMA,C,CAAA;AACA;AACA;;;AACO,eAAA,UAAA,CAAA,SAAA,EAAA,GAAA,EAGgC;AACrC;AACA,QAAMA,eAAe,GAAG,MAAM,CAAA,GAAA,OAAA,CAAA,OAAA,EAAA,cAAA,EAAuB;AAAEC,IAAAA,GAAG,EAA1D;AAAqD,GAAvB,CAA9B;;AACA,MAAA,eAAA,EAAqB;AACnB,UAAMC,WAAW,GAAGC,OAAO,CAA3B,eAA2B,CAA3B;;AACA,QAAID,WAAW,CAAXA,GAAW,CAAXA,IAAAA,IAAAA,IAA4B,OAAOA,WAAW,CAAlB,GAAkB,CAAlB,KAAhC,QAAA,EAAsE;AACpE,aAAOA,WAAW,CAAlB,GAAkB,CAAlB;AAEH;AAED,GAVqC,CAUrC;AACA;;;AACA,QAAME,QAAQ,GAAG,MAAM,CAAA,GAAA,OAAA,CAAA,OAAA,EACrB,CACG,IAAGC,GADN,SAAA,EAEG,GAAEA,GAFL,cAAA,EAGG,IAAGA,GAHN,OAAA,EAIG,GAAEA,GALgB,YACrB,CADqB,EAOrB;AACEJ,IAAAA,GAAG,EARP;AAOE,GAPqB,CAAvB;;AAWA,MAAA,QAAA,EAAc;AACZ,QAAIG,QAAQ,CAARA,QAAAA,CAAJ,KAAIA,CAAJ,EAA8B;AAC5B,aAAOD,OAAO,CAAd,QAAc,CAAd;AAGF,KALY,CAKZ;AACA;;;AACA,UAAMG,YAAY,GAAGC,GAAAA,CAAAA,OAAAA,CAAAA,YAAAA,CAAAA,QAAAA,EAArB,MAAqBA,CAArB;;AACA,WAAOC,KAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAP,YAAOA,CAAP;AAGF;;AAAA,SAAA,IAAA;AACD","sourcesContent":["import findUp from 'next/dist/compiled/find-up'\nimport fs from 'fs'\nimport JSON5 from 'next/dist/compiled/json5'\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>\n}\n\n// We'll allow configuration to be typed, but we force everything provided to\n// become optional. We do not perform any schema validation. We should maybe\n// force all the types to be `unknown` as well.\nexport async function findConfig<T>(\n  directory: string,\n  key: string\n): Promise<RecursivePartial<T> | null> {\n  // `package.json` configuration always wins. Let's check that first.\n  const packageJsonPath = await findUp('package.json', { cwd: directory })\n  if (packageJsonPath) {\n    const packageJson = require(packageJsonPath)\n    if (packageJson[key] != null && typeof packageJson[key] === 'object') {\n      return packageJson[key]\n    }\n  }\n\n  // If we didn't find the configuration in `package.json`, we should look for\n  // known filenames.\n  const filePath = await findUp(\n    [\n      `.${key}rc.json`,\n      `${key}.config.json`,\n      `.${key}rc.js`,\n      `${key}.config.js`,\n    ],\n    {\n      cwd: directory,\n    }\n  )\n  if (filePath) {\n    if (filePath.endsWith('.js')) {\n      return require(filePath)\n    }\n\n    // We load JSON contents with JSON5 to allow users to comment in their\n    // configuration file. This pattern was popularized by TypeScript.\n    const fileContents = fs.readFileSync(filePath, 'utf8')\n    return JSON5.parse(fileContents)\n  }\n\n  return null\n}\n"]},"metadata":{},"sourceType":"script"}