{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRedirectStatus = getRedirectStatus;\nexports.normalizeRouteRegex = normalizeRouteRegex;\nexports.default = loadCustomRoutes;\nexports.allowedStatusCodes = void 0;\n\nvar _url = require(\"url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nvar _escapeStringRegexp = _interopRequireDefault(require(\"next/dist/compiled/escape-string-regexp\"));\n\nvar _constants = require(\"../next-server/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst allowedStatusCodes = new Set([301, 302, 303, 307, 308]);\nexports.allowedStatusCodes = allowedStatusCodes;\n\nfunction getRedirectStatus(route) {\n  return route.statusCode || (route.permanent ? _constants.PERMANENT_REDIRECT_STATUS : _constants.TEMPORARY_REDIRECT_STATUS);\n}\n\nfunction normalizeRouteRegex(regex) {\n  // clean up un-necessary escaping from regex.source which turns / into \\\\/\n  return regex.replace(/\\\\\\//g, '/');\n}\n\nfunction checkRedirect(route) {\n  const invalidParts = [];\n  let hadInvalidStatus = false;\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true;\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`);\n  }\n\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``);\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus\n  };\n}\n\nfunction checkHeader(route) {\n  const invalidParts = [];\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array');\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\"`headers` items must be object with { key: '', value: '' }\");\n        break;\n      }\n\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string');\n        break;\n      }\n\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string');\n        break;\n      }\n    }\n  }\n\n  return invalidParts;\n}\n\nfunction tryParsePath(route, handleUrl) {\n  const result = {};\n  let routePath = route;\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = (0, _url.parse)(route, true);\n      routePath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n    } // Make sure we can parse the source properly\n\n\n    result.tokens = pathToRegexp.parse(routePath);\n    pathToRegexp.tokensToRegexp(result.tokens);\n  } catch (err) {\n    // If there is an error show our err.sh but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/);\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10);\n      console.error(`\\nError parsing \\`${route}\\` ` + `https://err.sh/vercel/next.js/invalid-route-source\\n` + `Reason: ${err.message}\\n\\n` + `  ${routePath}\\n` + `  ${new Array(position).fill(' ').join('')}^\\n`);\n    } else {\n      console.error(`\\nError parsing ${route} https://err.sh/vercel/next.js/invalid-route-source`, err);\n    }\n\n    result.error = true;\n  }\n\n  return result;\n}\n\nfunction checkCustomRoutes(routes, type) {\n  if (!Array.isArray(routes)) {\n    throw new Error(`${type}s must return an array, received ${typeof routes}.\\n` + `See here for more info: https://err.sh/next.js/routes-must-be-array`);\n  }\n\n  let numInvalidRoutes = 0;\n  let hadInvalidStatus = false;\n  const isRedirect = type === 'redirect';\n  let allowedKeys;\n\n  if (type === 'rewrite' || isRedirect) {\n    allowedKeys = new Set(['source', 'destination', 'basePath', 'locale', ...(isRedirect ? ['statusCode', 'permanent'] : [])]);\n  } else {\n    allowedKeys = new Set(['source', 'headers', 'basePath', 'locale']);\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(`The route ${JSON.stringify(route)} is not a valid object with \\`source\\` and \\`${type === 'header' ? 'headers' : 'destination'}\\``);\n      numInvalidRoutes++;\n      continue;\n    }\n\n    if (type === 'rewrite' && route.basePath === false && !(route.destination.startsWith('http://') || route.destination.startsWith('https://'))) {\n      console.error(`The route ${route.source} rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://err.sh/vercel/next.js/invalid-external-rewrite.md`);\n      numInvalidRoutes++;\n      continue;\n    }\n\n    const keys = Object.keys(route);\n    const invalidKeys = keys.filter(key => !allowedKeys.has(key));\n    const invalidParts = [];\n\n    if (typeof route.basePath !== 'undefined' && route.basePath !== false) {\n      invalidParts.push('`basePath` must be undefined or false');\n    }\n\n    if (typeof route.locale !== 'undefined' && route.locale !== false) {\n      invalidParts.push('`locale` must be undefined or false');\n    }\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing');\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string');\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /');\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route));\n    } else {\n      let _route = route;\n\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing');\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string');\n      } else if (type === 'rewrite' && !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)) {\n        invalidParts.push('`destination` does not start with `/`, `http://`, or `https://`');\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route);\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus;\n      invalidParts.push(...result.invalidParts);\n    }\n\n    let sourceTokens;\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const {\n        tokens,\n        error\n      } = tryParsePath(route.source);\n\n      if (error) {\n        invalidParts.push('`source` parse failed');\n      }\n\n      sourceTokens = tokens;\n    } // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n\n\n    if (typeof route.destination === 'string') {\n      if (route.destination.startsWith('/') && Array.isArray(sourceTokens)) {\n        const unnamedInDest = new Set();\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`);\n\n            if (route.destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`);\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(`\\`destination\\` has unnamed params ${[...unnamedInDest].join(', ')}`);\n        } else {\n          const {\n            tokens: destTokens,\n            error: destinationParseFailed\n          } = tryParsePath(route.destination, true);\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed');\n          } else {\n            const sourceSegments = new Set(sourceTokens.map(item => typeof item === 'object' && item.name).filter(Boolean));\n            const invalidDestSegments = new Set();\n\n            for (const token of destTokens) {\n              if (typeof token === 'object' && !sourceSegments.has(token.name)) {\n                invalidDestSegments.add(token.name);\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(`\\`destination\\` has segments not in \\`source\\` (${[...invalidDestSegments].join(', ')})`);\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0;\n    const hasInvalidParts = invalidParts.length > 0;\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(`${invalidParts.join(', ')}${invalidKeys.length ? (hasInvalidParts ? ',' : '') + ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` + invalidKeys.join(',') : ''} for route ${JSON.stringify(route)}`);\n      numInvalidRoutes++;\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(`\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(', ')}`);\n    }\n\n    console.error();\n    throw new Error(`Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`);\n  }\n}\n\nfunction processRoutes(routes, config, type) {\n  const _routes = routes;\n  const newRoutes = [];\n  const defaultLocales = [];\n\n  if (config.i18n && type === 'redirect') {\n    for (const item of ((_config$i18n = config.i18n) == null ? void 0 : _config$i18n.domains) || []) {\n      var _config$i18n;\n\n      defaultLocales.push({\n        locale: item.defaultLocale,\n        base: `http${item.http ? '' : 's'}://${item.domain}`\n      });\n    }\n\n    defaultLocales.push({\n      locale: config.i18n.defaultLocale,\n      base: ''\n    });\n  }\n\n  for (const r of _routes) {\n    var _r$destination;\n\n    const srcBasePath = config.basePath && r.basePath !== false ? config.basePath : '';\n    const isExternal = !((_r$destination = r.destination) != null && _r$destination.startsWith('/'));\n    const destBasePath = srcBasePath && !isExternal ? srcBasePath : '';\n\n    if (config.i18n && r.locale !== false) {\n      var _r$destination2;\n\n      defaultLocales.forEach(item => {\n        let destination;\n\n        if (r.destination) {\n          destination = item.base ? `${item.base}${destBasePath}${r.destination}` : `${destBasePath}${r.destination}`;\n        }\n\n        newRoutes.push({ ...r,\n          destination,\n          source: `${srcBasePath}/${item.locale}${r.source}`\n        });\n      });\n      r.source = `/:nextInternalLocale(${config.i18n.locales.map(locale => (0, _escapeStringRegexp.default)(locale)).join('|')})${r.source === '/' && !config.trailingSlash ? '' : r.source}`;\n\n      if (r.destination && (_r$destination2 = r.destination) != null && _r$destination2.startsWith('/')) {\n        r.destination = `/:nextInternalLocale${r.destination === '/' && !config.trailingSlash ? '' : r.destination}`;\n      }\n    }\n\n    r.source = `${srcBasePath}${r.source}`;\n\n    if (r.destination) {\n      r.destination = `${destBasePath}${r.destination}`;\n    }\n\n    newRoutes.push(r);\n  }\n\n  return newRoutes;\n}\n\nasync function loadRedirects(config) {\n  if (typeof config.redirects !== 'function') {\n    return [];\n  }\n\n  let redirects = await config.redirects();\n  checkCustomRoutes(redirects, 'redirect');\n  return processRoutes(redirects, config, 'redirect');\n}\n\nasync function loadRewrites(config) {\n  if (typeof config.rewrites !== 'function') {\n    return [];\n  }\n\n  let rewrites = await config.rewrites();\n  checkCustomRoutes(rewrites, 'rewrite');\n  return processRoutes(rewrites, config, 'rewrite');\n}\n\nasync function loadHeaders(config) {\n  if (typeof config.headers !== 'function') {\n    return [];\n  }\n\n  let headers = await config.headers();\n  checkCustomRoutes(headers, 'header');\n  return processRoutes(headers, config, 'header');\n}\n\nasync function loadCustomRoutes(config) {\n  const [headers, rewrites, redirects] = await Promise.all([loadHeaders(config), loadRewrites(config), loadRedirects(config)]);\n\n  if (config.trailingSlash) {\n    redirects.unshift({\n      source: '/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',\n      destination: '/:file',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    }, {\n      source: '/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',\n      destination: '/:notfile/',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    });\n\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath,\n        destination: config.basePath + '/',\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true\n      });\n    }\n  } else {\n    redirects.unshift({\n      source: '/:path+/',\n      destination: '/:path+',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    });\n\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath + '/',\n        destination: config.basePath,\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true\n      });\n    }\n  }\n\n  return {\n    headers,\n    rewrites,\n    redirects\n  };\n}","map":{"version":3,"sources":["../../lib/load-custom-routes.ts"],"names":["allowedStatusCodes","route","PERMANENT_REDIRECT_STATUS","TEMPORARY_REDIRECT_STATUS","regex","invalidParts","hadInvalidStatus","Array","header","result","routePath","parsedDestination","pathname","pathToRegexp","errMatches","err","position","parseInt","console","message","type","routes","numInvalidRoutes","isRedirect","allowedKeys","JSON","source","keys","Object","invalidKeys","key","checkHeader","_route","checkRedirect","tryParsePath","sourceTokens","unnamedInDest","token","unnamedIndex","name","tokens","error","sourceSegments","item","invalidDestSegments","hasInvalidKeys","hasInvalidParts","_routes","newRoutes","defaultLocales","config","locale","base","domain","srcBasePath","r","isExternal","destBasePath","destination","redirects","checkCustomRoutes","processRoutes","rewrites","headers","Promise","loadHeaders","loadRewrites","loadRedirects","permanent","internal","basePath"],"mappings":"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","sourcesContent":["import { parse as parseUrl } from 'url'\nimport { NextConfig } from '../next-server/server/config'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport escapeStringRegexp from 'next/dist/compiled/escape-string-regexp'\nimport {\n  PERMANENT_REDIRECT_STATUS,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../next-server/lib/constants'\n\nexport type Rewrite = {\n  source: string\n  destination: string\n  basePath?: false\n  locale?: false\n}\n\nexport type Header = {\n  source: string\n  basePath?: false\n  locale?: false\n  headers: Array<{ key: string; value: string }>\n}\n\n// internal type used for validation (not user facing)\nexport type Redirect = Rewrite & {\n  statusCode?: number\n  permanent?: boolean\n}\n\nexport const allowedStatusCodes = new Set([301, 302, 303, 307, 308])\n\nexport function getRedirectStatus(route: {\n  statusCode?: number\n  permanent?: boolean\n}): number {\n  return (\n    route.statusCode ||\n    (route.permanent ? PERMANENT_REDIRECT_STATUS : TEMPORARY_REDIRECT_STATUS)\n  )\n}\n\nexport function normalizeRouteRegex(regex: string) {\n  // clean up un-necessary escaping from regex.source which turns / into \\\\/\n  return regex.replace(/\\\\\\//g, '/')\n}\n\nfunction checkRedirect(\n  route: Redirect\n): { invalidParts: string[]; hadInvalidStatus: boolean } {\n  const invalidParts: string[] = []\n  let hadInvalidStatus: boolean = false\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`)\n  }\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``)\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus,\n  }\n}\n\nfunction checkHeader(route: Header): string[] {\n  const invalidParts: string[] = []\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array')\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\n          \"`headers` items must be object with { key: '', value: '' }\"\n        )\n        break\n      }\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string')\n        break\n      }\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string')\n        break\n      }\n    }\n  }\n  return invalidParts\n}\n\ntype ParseAttemptResult = {\n  error?: boolean\n  tokens?: pathToRegexp.Token[]\n}\n\nfunction tryParsePath(route: string, handleUrl?: boolean): ParseAttemptResult {\n  const result: ParseAttemptResult = {}\n  let routePath = route\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = parseUrl(route, true)\n      routePath = `${parsedDestination.pathname!}${\n        parsedDestination.hash || ''\n      }`\n    }\n\n    // Make sure we can parse the source properly\n    result.tokens = pathToRegexp.parse(routePath)\n    pathToRegexp.tokensToRegexp(result.tokens)\n  } catch (err) {\n    // If there is an error show our err.sh but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/)\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10)\n      console.error(\n        `\\nError parsing \\`${route}\\` ` +\n          `https://err.sh/vercel/next.js/invalid-route-source\\n` +\n          `Reason: ${err.message}\\n\\n` +\n          `  ${routePath}\\n` +\n          `  ${new Array(position).fill(' ').join('')}^\\n`\n      )\n    } else {\n      console.error(\n        `\\nError parsing ${route} https://err.sh/vercel/next.js/invalid-route-source`,\n        err\n      )\n    }\n    result.error = true\n  }\n\n  return result\n}\n\nexport type RouteType = 'rewrite' | 'redirect' | 'header'\n\nfunction checkCustomRoutes(\n  routes: Redirect[] | Header[] | Rewrite[],\n  type: RouteType\n): void {\n  if (!Array.isArray(routes)) {\n    throw new Error(\n      `${type}s must return an array, received ${typeof routes}.\\n` +\n        `See here for more info: https://err.sh/next.js/routes-must-be-array`\n    )\n  }\n\n  let numInvalidRoutes = 0\n  let hadInvalidStatus = false\n\n  const isRedirect = type === 'redirect'\n  let allowedKeys: Set<string>\n\n  if (type === 'rewrite' || isRedirect) {\n    allowedKeys = new Set([\n      'source',\n      'destination',\n      'basePath',\n      'locale',\n      ...(isRedirect ? ['statusCode', 'permanent'] : []),\n    ])\n  } else {\n    allowedKeys = new Set(['source', 'headers', 'basePath', 'locale'])\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(\n        `The route ${JSON.stringify(\n          route\n        )} is not a valid object with \\`source\\` and \\`${\n          type === 'header' ? 'headers' : 'destination'\n        }\\``\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    if (\n      type === 'rewrite' &&\n      (route as Rewrite).basePath === false &&\n      !(\n        (route as Rewrite).destination.startsWith('http://') ||\n        (route as Rewrite).destination.startsWith('https://')\n      )\n    ) {\n      console.error(\n        `The route ${\n          (route as Rewrite).source\n        } rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://err.sh/vercel/next.js/invalid-external-rewrite.md`\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    const keys = Object.keys(route)\n    const invalidKeys = keys.filter((key) => !allowedKeys.has(key))\n    const invalidParts: string[] = []\n\n    if (typeof route.basePath !== 'undefined' && route.basePath !== false) {\n      invalidParts.push('`basePath` must be undefined or false')\n    }\n\n    if (typeof route.locale !== 'undefined' && route.locale !== false) {\n      invalidParts.push('`locale` must be undefined or false')\n    }\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing')\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string')\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /')\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route as Header))\n    } else {\n      let _route = route as Rewrite | Redirect\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing')\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string')\n      } else if (\n        type === 'rewrite' &&\n        !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)\n      ) {\n        invalidParts.push(\n          '`destination` does not start with `/`, `http://`, or `https://`'\n        )\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route as Redirect)\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus\n      invalidParts.push(...result.invalidParts)\n    }\n\n    let sourceTokens: pathToRegexp.Token[] | undefined\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const { tokens, error } = tryParsePath(route.source)\n\n      if (error) {\n        invalidParts.push('`source` parse failed')\n      }\n      sourceTokens = tokens\n    }\n\n    // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n    if (typeof (route as Rewrite).destination === 'string') {\n      if (\n        (route as Rewrite).destination.startsWith('/') &&\n        Array.isArray(sourceTokens)\n      ) {\n        const unnamedInDest = new Set()\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`)\n            if ((route as Rewrite).destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`)\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(\n            `\\`destination\\` has unnamed params ${[...unnamedInDest].join(\n              ', '\n            )}`\n          )\n        } else {\n          const {\n            tokens: destTokens,\n            error: destinationParseFailed,\n          } = tryParsePath((route as Rewrite).destination, true)\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed')\n          } else {\n            const sourceSegments = new Set(\n              sourceTokens\n                .map((item) => typeof item === 'object' && item.name)\n                .filter(Boolean)\n            )\n            const invalidDestSegments = new Set()\n\n            for (const token of destTokens!) {\n              if (\n                typeof token === 'object' &&\n                !sourceSegments.has(token.name)\n              ) {\n                invalidDestSegments.add(token.name)\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(\n                `\\`destination\\` has segments not in \\`source\\` (${[\n                  ...invalidDestSegments,\n                ].join(', ')})`\n              )\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0\n    const hasInvalidParts = invalidParts.length > 0\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(\n        `${invalidParts.join(', ')}${\n          invalidKeys.length\n            ? (hasInvalidParts ? ',' : '') +\n              ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` +\n              invalidKeys.join(',')\n            : ''\n        } for route ${JSON.stringify(route)}`\n      )\n      numInvalidRoutes++\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(\n        `\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(\n          ', '\n        )}`\n      )\n    }\n    console.error()\n\n    throw new Error(`Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`)\n  }\n}\n\nexport interface CustomRoutes {\n  headers: Header[]\n  rewrites: Rewrite[]\n  redirects: Redirect[]\n}\n\nfunction processRoutes<T>(\n  routes: T,\n  config: NextConfig,\n  type: 'redirect' | 'rewrite' | 'header'\n): T {\n  const _routes = (routes as any) as Array<{\n    source: string\n    locale?: false\n    basePath?: false\n    destination?: string\n  }>\n  const newRoutes: typeof _routes = []\n  const defaultLocales: Array<{\n    locale: string\n    base: string\n  }> = []\n\n  if (config.i18n && type === 'redirect') {\n    for (const item of config.i18n?.domains || []) {\n      defaultLocales.push({\n        locale: item.defaultLocale,\n        base: `http${item.http ? '' : 's'}://${item.domain}`,\n      })\n    }\n\n    defaultLocales.push({\n      locale: config.i18n.defaultLocale,\n      base: '',\n    })\n  }\n\n  for (const r of _routes) {\n    const srcBasePath =\n      config.basePath && r.basePath !== false ? config.basePath : ''\n    const isExternal = !r.destination?.startsWith('/')\n    const destBasePath = srcBasePath && !isExternal ? srcBasePath : ''\n\n    if (config.i18n && r.locale !== false) {\n      defaultLocales.forEach((item) => {\n        let destination\n\n        if (r.destination) {\n          destination = item.base\n            ? `${item.base}${destBasePath}${r.destination}`\n            : `${destBasePath}${r.destination}`\n        }\n\n        newRoutes.push({\n          ...r,\n          destination,\n          source: `${srcBasePath}/${item.locale}${r.source}`,\n        })\n      })\n\n      r.source = `/:nextInternalLocale(${config.i18n.locales\n        .map((locale: string) => escapeStringRegexp(locale))\n        .join('|')})${\n        r.source === '/' && !config.trailingSlash ? '' : r.source\n      }`\n\n      if (r.destination && r.destination?.startsWith('/')) {\n        r.destination = `/:nextInternalLocale${\n          r.destination === '/' && !config.trailingSlash ? '' : r.destination\n        }`\n      }\n    }\n    r.source = `${srcBasePath}${r.source}`\n\n    if (r.destination) {\n      r.destination = `${destBasePath}${r.destination}`\n    }\n    newRoutes.push(r)\n  }\n  return (newRoutes as any) as T\n}\n\nasync function loadRedirects(config: NextConfig) {\n  if (typeof config.redirects !== 'function') {\n    return []\n  }\n  let redirects = await config.redirects()\n  checkCustomRoutes(redirects, 'redirect')\n  return processRoutes(redirects, config, 'redirect')\n}\n\nasync function loadRewrites(config: NextConfig) {\n  if (typeof config.rewrites !== 'function') {\n    return []\n  }\n  let rewrites = await config.rewrites()\n  checkCustomRoutes(rewrites, 'rewrite')\n  return processRoutes(rewrites, config, 'rewrite')\n}\n\nasync function loadHeaders(config: NextConfig) {\n  if (typeof config.headers !== 'function') {\n    return []\n  }\n  let headers = await config.headers()\n  checkCustomRoutes(headers, 'header')\n  return processRoutes(headers, config, 'header')\n}\n\nexport default async function loadCustomRoutes(\n  config: NextConfig\n): Promise<CustomRoutes> {\n  const [headers, rewrites, redirects] = await Promise.all([\n    loadHeaders(config),\n    loadRewrites(config),\n    loadRedirects(config),\n  ])\n\n  if (config.trailingSlash) {\n    redirects.unshift(\n      {\n        source: '/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',\n        destination: '/:file',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect,\n      {\n        source: '/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',\n        destination: '/:notfile/',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect\n    )\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath,\n        destination: config.basePath + '/',\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  } else {\n    redirects.unshift({\n      source: '/:path+/',\n      destination: '/:path+',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true,\n    } as Redirect)\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath + '/',\n        destination: config.basePath,\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  }\n\n  return {\n    headers,\n    rewrites,\n    redirects,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}