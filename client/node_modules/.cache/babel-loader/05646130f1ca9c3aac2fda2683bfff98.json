{"ast":null,"code":"import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true); // ul: true,\n// ol: true,\n\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true); // table: true,\n// tr: true,\n\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\n\nexport default class HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n    super();\n    this.rawAttrs = rawAttrs;\n    this.parentNode = parentNode;\n    this.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawTagName = tagName;\n    this.rawAttrs = rawAttrs || '';\n    this.parentNode = parentNode || null;\n    this.childNodes = [];\n\n    if (keyAttrs.id) {\n      this.id = keyAttrs.id;\n\n      if (!rawAttrs) {\n        this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n      }\n    }\n\n    if (keyAttrs.class) {\n      this.classNames = keyAttrs.class.split(/\\s+/);\n\n      if (!rawAttrs) {\n        const cls = `class=\"${this.classNames.join(' ')}\"`;\n\n        if (this.rawAttrs) {\n          this.rawAttrs += ` ${cls}`;\n        } else {\n          this.rawAttrs = cls;\n        }\n      }\n    }\n  }\n  /**\n   * Remove current element\n   */\n\n\n  remove() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      this.parentNode.childNodes = children.filter(child => {\n        return this !== child;\n      });\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n\n\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n\n\n  exchangeChild(oldNode, newNode) {\n    const children = this.childNodes;\n    this.childNodes = children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n\n      return child;\n    });\n  }\n\n  get tagName() {\n    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get rawText() {\n    return this.childNodes.reduce((pre, cur) => {\n      return pre += cur.rawText;\n    }, '');\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n\n\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements.get(node.rawTagName)) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n\n          node.childNodes.forEach(dfs);\n\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.text;\n\n          if (currentBlock.prependWhitespace) {\n            text = ` ${text}`;\n            currentBlock.prependWhitespace = false;\n          }\n\n          currentBlock.push(text);\n        }\n      }\n    }\n\n    dfs(this);\n    return blocks.map(block => {\n      // Normalize each line's whitespace\n      return block.join('').trim().replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n\n  toString() {\n    const tag = this.rawTagName;\n\n    if (tag) {\n      const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n\n      if (is_void) {\n        return `<${tag}${attrs}>`;\n      }\n\n      return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n    }\n\n    return this.innerHTML;\n  }\n\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n\n  set_content(content, options = {}) {\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content, options);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n    }\n\n    this.childNodes = content;\n  }\n\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n\n\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index); // trim all following nodes.\n\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n\n\n  get structure() {\n    const res = [];\n    let indention = 0;\n\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n\n    function dfs(node) {\n      const idStr = node.id ? `#${node.id}` : '';\n      const classStr = node.classNames.length ? `.${node.classNames.join('.')}` : '';\n      write(node.rawTagName + idStr + classStr);\n      indention++;\n      node.childNodes.forEach(childNode => {\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) {\n            write('#text');\n          }\n        }\n      });\n      indention--;\n    }\n\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n\n\n  removeWhitespace() {\n    let o = 0;\n    this.childNodes.forEach(node => {\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          return;\n        }\n\n        node.rawText = node.rawText.trim();\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n\n      this.childNodes[o++] = node;\n    });\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement[]}  matching elements\n   */\n\n\n  querySelectorAll(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      if (selector.includes(',')) {\n        const selectors = selector.split(',');\n        return Array.from(selectors.reduce((pre, cur) => {\n          const result = this.querySelectorAll(cur.trim());\n          return result.reduce((p, c) => {\n            return p.add(c);\n          }, pre);\n        }, new Set()));\n      }\n\n      matcher = new Matcher(selector);\n    }\n\n    const stack = [];\n    return this.childNodes.reduce((res, cur) => {\n      stack.push([cur, 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack); // get last element\n\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          const html_el = el;\n          state[2] = matcher.advance(html_el);\n\n          if (state[2]) {\n            if (matcher.matched) {\n              res.push(html_el);\n              res.push(...html_el.querySelectorAll(selector)); // no need to go further.\n\n              matcher.rewind();\n              stack.pop();\n              continue;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n\n          stack.pop();\n        }\n      }\n\n      return res;\n    }, []);\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement}    matching node\n   */\n\n\n  querySelector(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      matcher = new Matcher(selector);\n    }\n\n    const stack = [];\n\n    for (const node of this.childNodes) {\n      stack.push([node, 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack);\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          state[2] = matcher.advance(el);\n\n          if (state[2]) {\n            if (matcher.matched) {\n              return el;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) {\n            matcher.rewind();\n          }\n\n          stack.pop();\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n\n\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n\n    if (node instanceof HTMLElement) {\n      node.parentNode = this;\n    }\n\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n\n\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n\n\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @return {Object} parsed and unescaped attributes\n   */\n\n\n  get attributes() {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n\n    for (const key in attrs) {\n      const val = attrs[key] || '';\n      this._attrs[key] = decode(val);\n    }\n\n    return this._attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n\n\n  get rawAttributes() {\n    if (this._rawAttrs) {\n      return this._rawAttrs;\n    }\n\n    const attrs = {};\n\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || null;\n      }\n    }\n\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n\n  removeAttribute(key) {\n    const attrs = this.rawAttributes;\n    delete attrs[key]; // Update this.attribute\n\n    if (this._attrs) {\n      delete this._attrs[key];\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n\n      if (val === undefined || val === 'null') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n\n  hasAttribute(key) {\n    return key in this.attributes;\n  }\n  /**\n   * Get an attribute\n   * @return {string} value of the attribute\n   */\n\n\n  getAttribute(key) {\n    return this.attributes[key];\n  }\n  /**\n   * Set an attribute value to the HTMLElement\n   * @param {string} key The attribute name\n   * @param {string} value The value to set, or null / undefined to remove an attribute\n   */\n\n\n  setAttribute(key, value) {\n    if (arguments.length < 2) {\n      throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n    }\n\n    const attrs = this.rawAttributes;\n    attrs[key] = String(value);\n\n    if (this._attrs) {\n      this._attrs[key] = decode(attrs[key]);\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attrs).map(name => {\n      const val = JSON.stringify(attrs[name]);\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${val}`;\n    }).join(' ');\n  }\n  /**\n   * Replace all the attributes of the HTMLElement by the provided attributes\n   * @param {Attributes} attributes the new attribute set\n   */\n\n\n  setAttributes(attributes) {\n    // Invalidate current this.attributes\n    if (this._attrs) {\n      delete this._attrs;\n    } // Invalidate current this.rawAttributes\n\n\n    if (this._rawAttrs) {\n      delete this._rawAttrs;\n    } // Update rawString\n\n\n    this.rawAttrs = Object.keys(attributes).map(name => {\n      const val = attributes[name];\n\n      if (val === 'null' || val === '\"\"') {\n        return name;\n      }\n\n      return `${name}=${JSON.stringify(String(val))}`;\n    }).join(' ');\n  }\n\n  insertAdjacentHTML(where, html) {\n    if (arguments.length < 2) {\n      throw new Error('2 arguments required');\n    }\n\n    const p = parse(html);\n\n    if (where === 'afterend') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else if (where === 'afterbegin') {\n      this.childNodes.unshift(...p.childNodes);\n    } else if (where === 'beforeend') {\n      p.childNodes.forEach(n => {\n        this.appendChild(n);\n      });\n    } else if (where === 'beforebegin') {\n      const idx = this.parentNode.childNodes.findIndex(child => {\n        return child === this;\n      });\n      this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n      p.childNodes.forEach(n => {\n        if (n instanceof HTMLElement) {\n          n.parentNode = this.parentNode;\n        }\n      });\n    } else {\n      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n    } // if (!where || html === undefined || html === null) {\n    // \treturn;\n    // }\n\n  }\n\n  get nextSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (this === child) {\n          return children[i] || null;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  get nextElementSibling() {\n    if (this.parentNode) {\n      const children = this.parentNode.childNodes;\n      let i = 0;\n      let find = false;\n\n      while (i < children.length) {\n        const child = children[i++];\n\n        if (find) {\n          if (child instanceof HTMLElement) {\n            return child || null;\n          }\n        } else if (this === child) {\n          find = true;\n        }\n      }\n\n      return null;\n    }\n  }\n\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig; // <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  AREA: true,\n  base: true,\n  BASE: true,\n  br: true,\n  BR: true,\n  col: true,\n  COL: true,\n  hr: true,\n  HR: true,\n  img: true,\n  IMG: true,\n  input: true,\n  INPUT: true,\n  link: true,\n  LINK: true,\n  meta: true,\n  META: true,\n  source: true,\n  SOURCE: true,\n  embed: true,\n  EMBED: true,\n  param: true,\n  PARAM: true,\n  track: true,\n  TRACK: true,\n  wbr: true,\n  WBR: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true,\n    LI: true\n  },\n  LI: {\n    li: true,\n    LI: true\n  },\n  p: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  P: {\n    p: true,\n    div: true,\n    P: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TD: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  th: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  TH: {\n    td: true,\n    th: true,\n    TD: true,\n    TH: true\n  },\n  h1: {\n    h1: true,\n    H1: true\n  },\n  H1: {\n    h1: true,\n    H1: true\n  },\n  h2: {\n    h2: true,\n    H2: true\n  },\n  H2: {\n    h2: true,\n    H2: true\n  },\n  h3: {\n    h3: true,\n    H3: true\n  },\n  H3: {\n    h3: true,\n    H3: true\n  },\n  h4: {\n    h4: true,\n    H4: true\n  },\n  H4: {\n    h4: true,\n    H4: true\n  },\n  h5: {\n    h5: true,\n    H5: true\n  },\n  H5: {\n    h5: true,\n    H5: true\n  },\n  h6: {\n    h6: true,\n    H6: true\n  },\n  H6: {\n    h6: true,\n    H6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  LI: {\n    ul: true,\n    ol: true,\n    UL: true,\n    OL: true\n  },\n  a: {\n    div: true,\n    DIV: true\n  },\n  A: {\n    div: true,\n    DIV: true\n  },\n  b: {\n    div: true,\n    DIV: true\n  },\n  B: {\n    div: true,\n    DIV: true\n  },\n  i: {\n    div: true,\n    DIV: true\n  },\n  I: {\n    div: true,\n    DIV: true\n  },\n  p: {\n    div: true,\n    DIV: true\n  },\n  P: {\n    div: true,\n    DIV: true\n  },\n  td: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TD: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  th: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  },\n  TH: {\n    tr: true,\n    table: true,\n    TR: true,\n    TABLE: true\n  }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data, options = {\n  lowerCaseTagName: false,\n  comment: false\n}) {\n  const elements = options.blockTextElements || {\n    script: true,\n    noscript: true,\n    style: true,\n    pre: true\n  };\n  const element_names = Object.keys(elements);\n  const kBlockTextElements = element_names.map(it => {\n    return new RegExp(it, 'i');\n  });\n  const kIgnoreElements = element_names.filter(it => {\n    return elements[it];\n  }).map(it => {\n    return new RegExp(it, 'i');\n  });\n\n  function element_should_be_ignore(tag) {\n    return kIgnoreElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  function is_block_text_element(tag) {\n    return kBlockTextElements.some(it => {\n      return it.test(tag);\n    });\n  }\n\n  const root = new HTMLElement(null, {});\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  let match; // https://github.com/taoqf/node-html-parser/issues/38\n\n  data = `<${frameflag}>${data}</${frameflag}>`;\n\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n\n    lastTextPos = kMarkupPattern.lastIndex;\n\n    if (match[2] === frameflag) {\n      continue;\n    }\n\n    if (match[0][1] === '!') {\n      // this is a comment\n      if (options.comment) {\n        // Only keep what is in between <!-- and -->\n        const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n        currentParent.appendChild(new CommentNode(text));\n      }\n\n      continue;\n    }\n\n    if (options.lowerCaseTagName) {\n      match[2] = match[2].toLowerCase();\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      const attrs = {};\n\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n\n      const tagName = currentParent.rawTagName;\n\n      if (!match[4] && kElementsClosedByOpening[tagName]) {\n        if (kElementsClosedByOpening[tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      } // ignore container tag we add above\n      // https://github.com/taoqf/node-html-parser/issues/38\n\n\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n\n      if (is_block_text_element(match[2])) {\n        // a little test to find next </script> or </style> ...\n        const closeMarkup = `</${match[2]}>`;\n\n        const index = (() => {\n          if (options.lowerCaseTagName) {\n            return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n          }\n\n          return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n        })();\n\n        if (element_should_be_ignore(match[2])) {\n          let text;\n\n          if (index === -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text));\n          }\n        }\n\n        if (index === -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.rawTagName === match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          const tagName = currentParent.tagName; // Trying to close current tag, and move on\n\n          if (kElementsClosedByClosing[tagName]) {\n            if (kElementsClosedByClosing[tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          } // Use aggressive strategy to handle unmatching markups.\n\n\n          break;\n        }\n      }\n    }\n  }\n\n  const valid = Boolean(stack.length === 1);\n\n  if (!options.noFix) {\n    const response = root;\n    response.valid = valid;\n\n    while (stack.length > 1) {\n      // Handle each error elements.\n      const last = stack.pop();\n      const oneBefore = arr_back(stack);\n\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {// If it's final element just skip.\n      }\n    }\n\n    response.childNodes.forEach(node => {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return response;\n  }\n\n  const response = new TextNode(data);\n  response.valid = valid;\n  return response;\n}","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/node-html-parser/dist/esm/nodes/html.js"],"names":["decode","Node","NodeType","TextNode","Matcher","arr_back","CommentNode","kBlockElements","Map","set","HTMLElement","constructor","tagName","keyAttrs","rawAttrs","parentNode","classNames","nodeType","ELEMENT_NODE","rawTagName","childNodes","id","class","split","cls","join","remove","children","filter","child","removeChild","node","exchangeChild","oldNode","newNode","map","toUpperCase","rawText","reduce","pre","cur","text","structuredText","currentBlock","blocks","dfs","get","length","push","forEach","TEXT_NODE","isWhitespace","prependWhitespace","block","trim","replace","toString","tag","is_void","test","attrs","innerHTML","set_content","content","options","r","parse","outerHTML","trimRight","pattern","i","childNode","index","search","substr","structure","res","indention","write","str","repeat","idStr","classStr","removeWhitespace","o","querySelectorAll","selector","matcher","reset","includes","selectors","Array","from","result","p","c","add","Set","stack","state","el","pop","html_el","advance","matched","rewind","querySelector","appendChild","firstChild","lastChild","attributes","_attrs","rawAttributes","key","val","_rawAttrs","re","match","exec","removeAttribute","Object","keys","name","JSON","stringify","undefined","hasAttribute","getAttribute","setAttribute","value","arguments","Error","String","setAttributes","insertAdjacentHTML","where","html","idx","findIndex","splice","n","unshift","nextSibling","nextElementSibling","find","kMarkupPattern","kAttributePattern","kSelfClosingElements","area","AREA","base","BASE","br","BR","col","COL","hr","HR","img","IMG","input","INPUT","link","LINK","meta","META","source","SOURCE","embed","EMBED","param","PARAM","track","TRACK","wbr","WBR","kElementsClosedByOpening","li","LI","div","P","DIV","b","B","td","th","TD","TH","h1","H1","h2","H2","h3","H3","h4","H4","h5","H5","h6","H6","kElementsClosedByClosing","ul","ol","UL","OL","a","A","I","tr","table","TR","TABLE","frameflag","data","lowerCaseTagName","comment","elements","blockTextElements","script","noscript","style","element_names","kBlockTextElements","it","RegExp","kIgnoreElements","element_should_be_ignore","some","is_block_text_element","root","currentParent","lastTextPos","lastIndex","substring","toLowerCase","attMatch","closeMarkup","toLocaleLowerCase","indexOf","valid","Boolean","noFix","response","last","oneBefore"],"mappings":"AAAA,SAASA,MAAT,QAAuB,IAAvB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAOC,QAAP,MAAqB,SAArB;AACA,OAAOC,WAAP,MAAwB,WAAxB;AACA,MAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AACAD,cAAc,CAACE,GAAf,CAAmB,KAAnB,EAA0B,IAA1B;AACAF,cAAc,CAACE,GAAf,CAAmB,KAAnB,EAA0B,IAA1B;AACAF,cAAc,CAACE,GAAf,CAAmB,GAAnB,EAAwB,IAAxB;AACAF,cAAc,CAACE,GAAf,CAAmB,GAAnB,EAAwB,IAAxB,E,CACA;AACA;;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB,E,CACA;AACA;;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB;AACAF,cAAc,CAACE,GAAf,CAAmB,SAAnB,EAA8B,IAA9B;AACAF,cAAc,CAACE,GAAf,CAAmB,SAAnB,EAA8B,IAA9B;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB;AACAF,cAAc,CAACE,GAAf,CAAmB,IAAnB,EAAyB,IAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,WAAN,SAA0BT,IAA1B,CAA+B;AAC1C;AACJ;AACA;AACA;AACA;AACA;AACA;AACIU,EAAAA,WAAW,CAACC,OAAD,EAAUC,QAAV,EAAoBC,QAAQ,GAAG,EAA/B,EAAmCC,UAAU,GAAG,IAAhD,EAAsD;AAC7D;AACA,SAAKD,QAAL,GAAgBA,QAAhB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA;AACR;AACA;;AACQ,SAAKC,QAAL,GAAgBf,QAAQ,CAACgB,YAAzB;AACA,SAAKC,UAAL,GAAkBP,OAAlB;AACA,SAAKE,QAAL,GAAgBA,QAAQ,IAAI,EAA5B;AACA,SAAKC,UAAL,GAAkBA,UAAU,IAAI,IAAhC;AACA,SAAKK,UAAL,GAAkB,EAAlB;;AACA,QAAIP,QAAQ,CAACQ,EAAb,EAAiB;AACb,WAAKA,EAAL,GAAUR,QAAQ,CAACQ,EAAnB;;AACA,UAAI,CAACP,QAAL,EAAe;AACX,aAAKA,QAAL,GAAiB,OAAMD,QAAQ,CAACQ,EAAG,GAAnC;AACH;AACJ;;AACD,QAAIR,QAAQ,CAACS,KAAb,EAAoB;AAChB,WAAKN,UAAL,GAAkBH,QAAQ,CAACS,KAAT,CAAeC,KAAf,CAAqB,KAArB,CAAlB;;AACA,UAAI,CAACT,QAAL,EAAe;AACX,cAAMU,GAAG,GAAI,UAAS,KAAKR,UAAL,CAAgBS,IAAhB,CAAqB,GAArB,CAA0B,GAAhD;;AACA,YAAI,KAAKX,QAAT,EAAmB;AACf,eAAKA,QAAL,IAAkB,IAAGU,GAAI,EAAzB;AACH,SAFD,MAGK;AACD,eAAKV,QAAL,GAAgBU,GAAhB;AACH;AACJ;AACJ;AACJ;AACD;AACJ;AACA;;;AACIE,EAAAA,MAAM,GAAG;AACL,QAAI,KAAKX,UAAT,EAAqB;AACjB,YAAMY,QAAQ,GAAG,KAAKZ,UAAL,CAAgBK,UAAjC;AACA,WAAKL,UAAL,CAAgBK,UAAhB,GAA6BO,QAAQ,CAACC,MAAT,CAAiBC,KAAD,IAAW;AACpD,eAAO,SAASA,KAAhB;AACH,OAF4B,CAA7B;AAGH;AACJ;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,SAAKX,UAAL,GAAkB,KAAKA,UAAL,CAAgBQ,MAAhB,CAAwBC,KAAD,IAAW;AAChD,aAAQA,KAAK,KAAKE,IAAlB;AACH,KAFiB,CAAlB;AAGH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,aAAa,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAC5B,UAAMP,QAAQ,GAAG,KAAKP,UAAtB;AACA,SAAKA,UAAL,GAAkBO,QAAQ,CAACQ,GAAT,CAAcN,KAAD,IAAW;AACtC,UAAIA,KAAK,KAAKI,OAAd,EAAuB;AACnB,eAAOC,OAAP;AACH;;AACD,aAAOL,KAAP;AACH,KALiB,CAAlB;AAMH;;AACD,MAAIjB,OAAJ,GAAc;AACV,WAAO,KAAKO,UAAL,GAAkB,KAAKA,UAAL,CAAgBiB,WAAhB,EAAlB,GAAkD,KAAKjB,UAA9D;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIkB,OAAJ,GAAc;AACV,WAAO,KAAKjB,UAAL,CAAgBkB,MAAhB,CAAuB,CAACC,GAAD,EAAMC,GAAN,KAAc;AACxC,aAAQD,GAAG,IAAIC,GAAG,CAACH,OAAnB;AACH,KAFM,EAEJ,EAFI,CAAP;AAGH;AACD;AACJ;AACA;AACA;;;AACI,MAAII,IAAJ,GAAW;AACP,WAAOzC,MAAM,CAAC,KAAKqC,OAAN,CAAb;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIK,cAAJ,GAAqB;AACjB,QAAIC,YAAY,GAAG,EAAnB;AACA,UAAMC,MAAM,GAAG,CAACD,YAAD,CAAf;;AACA,aAASE,GAAT,CAAad,IAAb,EAAmB;AACf,UAAIA,IAAI,CAACd,QAAL,KAAkBf,QAAQ,CAACgB,YAA/B,EAA6C;AACzC,YAAIX,cAAc,CAACuC,GAAf,CAAmBf,IAAI,CAACZ,UAAxB,CAAJ,EAAyC;AACrC,cAAIwB,YAAY,CAACI,MAAb,GAAsB,CAA1B,EAA6B;AACzBH,YAAAA,MAAM,CAACI,IAAP,CAAYL,YAAY,GAAG,EAA3B;AACH;;AACDZ,UAAAA,IAAI,CAACX,UAAL,CAAgB6B,OAAhB,CAAwBJ,GAAxB;;AACA,cAAIF,YAAY,CAACI,MAAb,GAAsB,CAA1B,EAA6B;AACzBH,YAAAA,MAAM,CAACI,IAAP,CAAYL,YAAY,GAAG,EAA3B;AACH;AACJ,SARD,MASK;AACDZ,UAAAA,IAAI,CAACX,UAAL,CAAgB6B,OAAhB,CAAwBJ,GAAxB;AACH;AACJ,OAbD,MAcK,IAAId,IAAI,CAACd,QAAL,KAAkBf,QAAQ,CAACgD,SAA/B,EAA0C;AAC3C,YAAInB,IAAI,CAACoB,YAAT,EAAuB;AACnB;AACAR,UAAAA,YAAY,CAACS,iBAAb,GAAiC,IAAjC;AACH,SAHD,MAIK;AACD,cAAIX,IAAI,GAAGV,IAAI,CAACU,IAAhB;;AACA,cAAIE,YAAY,CAACS,iBAAjB,EAAoC;AAChCX,YAAAA,IAAI,GAAI,IAAGA,IAAK,EAAhB;AACAE,YAAAA,YAAY,CAACS,iBAAb,GAAiC,KAAjC;AACH;;AACDT,UAAAA,YAAY,CAACK,IAAb,CAAkBP,IAAlB;AACH;AACJ;AACJ;;AACDI,IAAAA,GAAG,CAAC,IAAD,CAAH;AACA,WAAOD,MAAM,CAACT,GAAP,CAAYkB,KAAD,IAAW;AACzB;AACA,aAAOA,KAAK,CAAC5B,IAAN,CAAW,EAAX,EAAe6B,IAAf,GAAsBC,OAAtB,CAA8B,SAA9B,EAAyC,GAAzC,CAAP;AACH,KAHM,EAIF9B,IAJE,CAIG,IAJH,EAIS8B,OAJT,CAIiB,MAJjB,EAIyB,EAJzB,CAAP,CAlCiB,CAsCoB;AACxC;;AACDC,EAAAA,QAAQ,GAAG;AACP,UAAMC,GAAG,GAAG,KAAKtC,UAAjB;;AACA,QAAIsC,GAAJ,EAAS;AACL,YAAMC,OAAO,GAAG,4EAA4EC,IAA5E,CAAiFF,GAAjF,CAAhB;AACA,YAAMG,KAAK,GAAG,KAAK9C,QAAL,GAAiB,IAAG,KAAKA,QAAS,EAAlC,GAAsC,EAApD;;AACA,UAAI4C,OAAJ,EAAa;AACT,eAAQ,IAAGD,GAAI,GAAEG,KAAM,GAAvB;AACH;;AACD,aAAQ,IAAGH,GAAI,GAAEG,KAAM,IAAG,KAAKC,SAAU,KAAIJ,GAAI,GAAjD;AACH;;AACD,WAAO,KAAKI,SAAZ;AACH;;AACD,MAAIA,SAAJ,GAAgB;AACZ,WAAO,KAAKzC,UAAL,CAAgBe,GAAhB,CAAqBN,KAAD,IAAW;AAClC,aAAOA,KAAK,CAAC2B,QAAN,EAAP;AACH,KAFM,EAEJ/B,IAFI,CAEC,EAFD,CAAP;AAGH;;AACDqC,EAAAA,WAAW,CAACC,OAAD,EAAUC,OAAO,GAAG,EAApB,EAAwB;AAC/B,QAAID,OAAO,YAAY9D,IAAvB,EAA6B;AACzB8D,MAAAA,OAAO,GAAG,CAACA,OAAD,CAAV;AACH,KAFD,MAGK,IAAI,OAAOA,OAAP,IAAkB,QAAtB,EAAgC;AACjC,YAAME,CAAC,GAAGC,KAAK,CAACH,OAAD,EAAUC,OAAV,CAAf;AACAD,MAAAA,OAAO,GAAGE,CAAC,CAAC7C,UAAF,CAAa2B,MAAb,GAAsBkB,CAAC,CAAC7C,UAAxB,GAAqC,CAAC,IAAIjB,QAAJ,CAAa4D,OAAb,CAAD,CAA/C;AACH;;AACD,SAAK3C,UAAL,GAAkB2C,OAAlB;AACH;;AACD,MAAII,SAAJ,GAAgB;AACZ,WAAO,KAAKX,QAAL,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIY,EAAAA,SAAS,CAACC,OAAD,EAAU;AACf,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKlD,UAAL,CAAgB2B,MAApC,EAA4CuB,CAAC,EAA7C,EAAiD;AAC7C,YAAMC,SAAS,GAAG,KAAKnD,UAAL,CAAgBkD,CAAhB,CAAlB;;AACA,UAAIC,SAAS,CAACtD,QAAV,KAAuBf,QAAQ,CAACgB,YAApC,EAAkD;AAC9CqD,QAAAA,SAAS,CAACH,SAAV,CAAoBC,OAApB;AACH,OAFD,MAGK;AACD,cAAMG,KAAK,GAAGD,SAAS,CAAClC,OAAV,CAAkBoC,MAAlB,CAAyBJ,OAAzB,CAAd;;AACA,YAAIG,KAAK,GAAG,CAAC,CAAb,EAAgB;AACZD,UAAAA,SAAS,CAAClC,OAAV,GAAoBkC,SAAS,CAAClC,OAAV,CAAkBqC,MAAlB,CAAyB,CAAzB,EAA4BF,KAA5B,CAApB,CADY,CAEZ;;AACA,eAAKpD,UAAL,CAAgB2B,MAAhB,GAAyBuB,CAAC,GAAG,CAA7B;AACH;AACJ;AACJ;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIK,SAAJ,GAAgB;AACZ,UAAMC,GAAG,GAAG,EAAZ;AACA,QAAIC,SAAS,GAAG,CAAhB;;AACA,aAASC,KAAT,CAAeC,GAAf,EAAoB;AAChBH,MAAAA,GAAG,CAAC5B,IAAJ,CAAS,KAAKgC,MAAL,CAAYH,SAAZ,IAAyBE,GAAlC;AACH;;AACD,aAASlC,GAAT,CAAad,IAAb,EAAmB;AACf,YAAMkD,KAAK,GAAGlD,IAAI,CAACV,EAAL,GAAY,IAAGU,IAAI,CAACV,EAAG,EAAvB,GAA4B,EAA1C;AACA,YAAM6D,QAAQ,GAAGnD,IAAI,CAACf,UAAL,CAAgB+B,MAAhB,GAA2B,IAAGhB,IAAI,CAACf,UAAL,CAAgBS,IAAhB,CAAqB,GAArB,CAA0B,EAAxD,GAA6D,EAA9E;AACAqD,MAAAA,KAAK,CAAC/C,IAAI,CAACZ,UAAL,GAAkB8D,KAAlB,GAA0BC,QAA3B,CAAL;AACAL,MAAAA,SAAS;AACT9C,MAAAA,IAAI,CAACX,UAAL,CAAgB6B,OAAhB,CAAyBsB,SAAD,IAAe;AACnC,YAAIA,SAAS,CAACtD,QAAV,KAAuBf,QAAQ,CAACgB,YAApC,EAAkD;AAC9C2B,UAAAA,GAAG,CAAC0B,SAAD,CAAH;AACH,SAFD,MAGK,IAAIA,SAAS,CAACtD,QAAV,KAAuBf,QAAQ,CAACgD,SAApC,EAA+C;AAChD,cAAI,CAACqB,SAAS,CAACpB,YAAf,EAA6B;AACzB2B,YAAAA,KAAK,CAAC,OAAD,CAAL;AACH;AACJ;AACJ,OATD;AAUAD,MAAAA,SAAS;AACZ;;AACDhC,IAAAA,GAAG,CAAC,IAAD,CAAH;AACA,WAAO+B,GAAG,CAACnD,IAAJ,CAAS,IAAT,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACI0D,EAAAA,gBAAgB,GAAG;AACf,QAAIC,CAAC,GAAG,CAAR;AACA,SAAKhE,UAAL,CAAgB6B,OAAhB,CAAyBlB,IAAD,IAAU;AAC9B,UAAIA,IAAI,CAACd,QAAL,KAAkBf,QAAQ,CAACgD,SAA/B,EAA0C;AACtC,YAAInB,IAAI,CAACoB,YAAT,EAAuB;AACnB;AACH;;AACDpB,QAAAA,IAAI,CAACM,OAAL,GAAeN,IAAI,CAACM,OAAL,CAAaiB,IAAb,EAAf;AACH,OALD,MAMK,IAAIvB,IAAI,CAACd,QAAL,KAAkBf,QAAQ,CAACgB,YAA/B,EAA6C;AAC9Ca,QAAAA,IAAI,CAACoD,gBAAL;AACH;;AACD,WAAK/D,UAAL,CAAgBgE,CAAC,EAAjB,IAAuBrD,IAAvB;AACH,KAXD;AAYA,SAAKX,UAAL,CAAgB2B,MAAhB,GAAyBqC,CAAzB;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,gBAAgB,CAACC,QAAD,EAAW;AACvB,QAAIC,OAAJ;;AACA,QAAID,QAAQ,YAAYlF,OAAxB,EAAiC;AAC7BmF,MAAAA,OAAO,GAAGD,QAAV;AACAC,MAAAA,OAAO,CAACC,KAAR;AACH,KAHD,MAIK;AACD,UAAIF,QAAQ,CAACG,QAAT,CAAkB,GAAlB,CAAJ,EAA4B;AACxB,cAAMC,SAAS,GAAGJ,QAAQ,CAAC/D,KAAT,CAAe,GAAf,CAAlB;AACA,eAAOoE,KAAK,CAACC,IAAN,CAAWF,SAAS,CAACpD,MAAV,CAAiB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAC7C,gBAAMqD,MAAM,GAAG,KAAKR,gBAAL,CAAsB7C,GAAG,CAACc,IAAJ,EAAtB,CAAf;AACA,iBAAOuC,MAAM,CAACvD,MAAP,CAAc,CAACwD,CAAD,EAAIC,CAAJ,KAAU;AAC3B,mBAAOD,CAAC,CAACE,GAAF,CAAMD,CAAN,CAAP;AACH,WAFM,EAEJxD,GAFI,CAAP;AAGH,SALiB,EAKf,IAAI0D,GAAJ,EALe,CAAX,CAAP;AAMH;;AACDV,MAAAA,OAAO,GAAG,IAAInF,OAAJ,CAAYkF,QAAZ,CAAV;AACH;;AACD,UAAMY,KAAK,GAAG,EAAd;AACA,WAAO,KAAK9E,UAAL,CAAgBkB,MAAhB,CAAuB,CAACsC,GAAD,EAAMpC,GAAN,KAAc;AACxC0D,MAAAA,KAAK,CAAClD,IAAN,CAAW,CAACR,GAAD,EAAM,CAAN,EAAS,KAAT,CAAX;;AACA,aAAO0D,KAAK,CAACnD,MAAb,EAAqB;AACjB,cAAMoD,KAAK,GAAG9F,QAAQ,CAAC6F,KAAD,CAAtB,CADiB,CACc;;AAC/B,cAAME,EAAE,GAAGD,KAAK,CAAC,CAAD,CAAhB;;AACA,YAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAjB,EAAoB;AAChB;AACA,cAAIC,EAAE,CAACnF,QAAH,KAAgBf,QAAQ,CAACgB,YAA7B,EAA2C;AACvCgF,YAAAA,KAAK,CAACG,GAAN;AACA;AACH;;AACD,gBAAMC,OAAO,GAAGF,EAAhB;AACAD,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWZ,OAAO,CAACgB,OAAR,CAAgBD,OAAhB,CAAX;;AACA,cAAIH,KAAK,CAAC,CAAD,CAAT,EAAc;AACV,gBAAIZ,OAAO,CAACiB,OAAZ,EAAqB;AACjB5B,cAAAA,GAAG,CAAC5B,IAAJ,CAASsD,OAAT;AACA1B,cAAAA,GAAG,CAAC5B,IAAJ,CAAS,GAAIsD,OAAO,CAACjB,gBAAR,CAAyBC,QAAzB,CAAb,EAFiB,CAGjB;;AACAC,cAAAA,OAAO,CAACkB,MAAR;AACAP,cAAAA,KAAK,CAACG,GAAN;AACA;AACH;AACJ;AACJ;;AACD,YAAIF,KAAK,CAAC,CAAD,CAAL,GAAWC,EAAE,CAAChF,UAAH,CAAc2B,MAA7B,EAAqC;AACjCmD,UAAAA,KAAK,CAAClD,IAAN,CAAW,CAACoD,EAAE,CAAChF,UAAH,CAAc+E,KAAK,CAAC,CAAD,CAAL,EAAd,CAAD,EAA4B,CAA5B,EAA+B,KAA/B,CAAX;AACH,SAFD,MAGK;AACD,cAAIA,KAAK,CAAC,CAAD,CAAT,EAAc;AACVZ,YAAAA,OAAO,CAACkB,MAAR;AACH;;AACDP,UAAAA,KAAK,CAACG,GAAN;AACH;AACJ;;AACD,aAAOzB,GAAP;AACH,KAnCM,EAmCJ,EAnCI,CAAP;AAoCH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACI8B,EAAAA,aAAa,CAACpB,QAAD,EAAW;AACpB,QAAIC,OAAJ;;AACA,QAAID,QAAQ,YAAYlF,OAAxB,EAAiC;AAC7BmF,MAAAA,OAAO,GAAGD,QAAV;AACAC,MAAAA,OAAO,CAACC,KAAR;AACH,KAHD,MAIK;AACDD,MAAAA,OAAO,GAAG,IAAInF,OAAJ,CAAYkF,QAAZ,CAAV;AACH;;AACD,UAAMY,KAAK,GAAG,EAAd;;AACA,SAAK,MAAMnE,IAAX,IAAmB,KAAKX,UAAxB,EAAoC;AAChC8E,MAAAA,KAAK,CAAClD,IAAN,CAAW,CAACjB,IAAD,EAAO,CAAP,EAAU,KAAV,CAAX;;AACA,aAAOmE,KAAK,CAACnD,MAAb,EAAqB;AACjB,cAAMoD,KAAK,GAAG9F,QAAQ,CAAC6F,KAAD,CAAtB;AACA,cAAME,EAAE,GAAGD,KAAK,CAAC,CAAD,CAAhB;;AACA,YAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAjB,EAAoB;AAChB;AACA,cAAIC,EAAE,CAACnF,QAAH,KAAgBf,QAAQ,CAACgB,YAA7B,EAA2C;AACvCgF,YAAAA,KAAK,CAACG,GAAN;AACA;AACH;;AACDF,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWZ,OAAO,CAACgB,OAAR,CAAgBH,EAAhB,CAAX;;AACA,cAAID,KAAK,CAAC,CAAD,CAAT,EAAc;AACV,gBAAIZ,OAAO,CAACiB,OAAZ,EAAqB;AACjB,qBAAOJ,EAAP;AACH;AACJ;AACJ;;AACD,YAAID,KAAK,CAAC,CAAD,CAAL,GAAWC,EAAE,CAAChF,UAAH,CAAc2B,MAA7B,EAAqC;AACjCmD,UAAAA,KAAK,CAAClD,IAAN,CAAW,CAACoD,EAAE,CAAChF,UAAH,CAAc+E,KAAK,CAAC,CAAD,CAAL,EAAd,CAAD,EAA4B,CAA5B,EAA+B,KAA/B,CAAX;AACH,SAFD,MAGK;AACD,cAAIA,KAAK,CAAC,CAAD,CAAT,EAAc;AACVZ,YAAAA,OAAO,CAACkB,MAAR;AACH;;AACDP,UAAAA,KAAK,CAACG,GAAN;AACH;AACJ;AACJ;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIM,EAAAA,WAAW,CAAC5E,IAAD,EAAO;AACd;AACA,SAAKX,UAAL,CAAgB4B,IAAhB,CAAqBjB,IAArB;;AACA,QAAIA,IAAI,YAAYrB,WAApB,EAAiC;AAC7BqB,MAAAA,IAAI,CAAChB,UAAL,GAAkB,IAAlB;AACH;;AACD,WAAOgB,IAAP;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAI6E,UAAJ,GAAiB;AACb,WAAO,KAAKxF,UAAL,CAAgB,CAAhB,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIyF,SAAJ,GAAgB;AACZ,WAAOxG,QAAQ,CAAC,KAAKe,UAAN,CAAf;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAI0F,UAAJ,GAAiB;AACb,QAAI,KAAKC,MAAT,EAAiB;AACb,aAAO,KAAKA,MAAZ;AACH;;AACD,SAAKA,MAAL,GAAc,EAAd;AACA,UAAMnD,KAAK,GAAG,KAAKoD,aAAnB;;AACA,SAAK,MAAMC,GAAX,IAAkBrD,KAAlB,EAAyB;AACrB,YAAMsD,GAAG,GAAGtD,KAAK,CAACqD,GAAD,CAAL,IAAc,EAA1B;AACA,WAAKF,MAAL,CAAYE,GAAZ,IAAmBjH,MAAM,CAACkH,GAAD,CAAzB;AACH;;AACD,WAAO,KAAKH,MAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIC,aAAJ,GAAoB;AAChB,QAAI,KAAKG,SAAT,EAAoB;AAChB,aAAO,KAAKA,SAAZ;AACH;;AACD,UAAMvD,KAAK,GAAG,EAAd;;AACA,QAAI,KAAK9C,QAAT,EAAmB;AACf,YAAMsG,EAAE,GAAG,gEAAX;AACA,UAAIC,KAAJ;;AACA,aAAQA,KAAK,GAAGD,EAAE,CAACE,IAAH,CAAQ,KAAKxG,QAAb,CAAhB,EAAyC;AACrC8C,QAAAA,KAAK,CAACyD,KAAK,CAAC,CAAD,CAAN,CAAL,GAAkBA,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAjB,IAAwBA,KAAK,CAAC,CAAD,CAA7B,IAAoC,IAAtD;AACH;AACJ;;AACD,SAAKF,SAAL,GAAiBvD,KAAjB;AACA,WAAOA,KAAP;AACH;;AACD2D,EAAAA,eAAe,CAACN,GAAD,EAAM;AACjB,UAAMrD,KAAK,GAAG,KAAKoD,aAAnB;AACA,WAAOpD,KAAK,CAACqD,GAAD,CAAZ,CAFiB,CAGjB;;AACA,QAAI,KAAKF,MAAT,EAAiB;AACb,aAAO,KAAKA,MAAL,CAAYE,GAAZ,CAAP;AACH,KANgB,CAOjB;;;AACA,SAAKnG,QAAL,GAAgB0G,MAAM,CAACC,IAAP,CAAY7D,KAAZ,EAAmBzB,GAAnB,CAAwBuF,IAAD,IAAU;AAC7C,YAAMR,GAAG,GAAGS,IAAI,CAACC,SAAL,CAAehE,KAAK,CAAC8D,IAAD,CAApB,CAAZ;;AACA,UAAIR,GAAG,KAAKW,SAAR,IAAqBX,GAAG,KAAK,MAAjC,EAAyC;AACrC,eAAOQ,IAAP;AACH;;AACD,aAAQ,GAAEA,IAAK,IAAGR,GAAI,EAAtB;AACH,KANe,EAMbzF,IANa,CAMR,GANQ,CAAhB;AAOH;;AACDqG,EAAAA,YAAY,CAACb,GAAD,EAAM;AACd,WAAOA,GAAG,IAAI,KAAKH,UAAnB;AACH;AACD;AACJ;AACA;AACA;;;AACIiB,EAAAA,YAAY,CAACd,GAAD,EAAM;AACd,WAAO,KAAKH,UAAL,CAAgBG,GAAhB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIe,EAAAA,YAAY,CAACf,GAAD,EAAMgB,KAAN,EAAa;AACrB,QAAIC,SAAS,CAACnF,MAAV,GAAmB,CAAvB,EAA0B;AACtB,YAAM,IAAIoF,KAAJ,CAAU,mDAAV,CAAN;AACH;;AACD,UAAMvE,KAAK,GAAG,KAAKoD,aAAnB;AACApD,IAAAA,KAAK,CAACqD,GAAD,CAAL,GAAamB,MAAM,CAACH,KAAD,CAAnB;;AACA,QAAI,KAAKlB,MAAT,EAAiB;AACb,WAAKA,MAAL,CAAYE,GAAZ,IAAmBjH,MAAM,CAAC4D,KAAK,CAACqD,GAAD,CAAN,CAAzB;AACH,KARoB,CASrB;;;AACA,SAAKnG,QAAL,GAAgB0G,MAAM,CAACC,IAAP,CAAY7D,KAAZ,EAAmBzB,GAAnB,CAAwBuF,IAAD,IAAU;AAC7C,YAAMR,GAAG,GAAGS,IAAI,CAACC,SAAL,CAAehE,KAAK,CAAC8D,IAAD,CAApB,CAAZ;;AACA,UAAIR,GAAG,KAAK,MAAR,IAAkBA,GAAG,KAAK,IAA9B,EAAoC;AAChC,eAAOQ,IAAP;AACH;;AACD,aAAQ,GAAEA,IAAK,IAAGR,GAAI,EAAtB;AACH,KANe,EAMbzF,IANa,CAMR,GANQ,CAAhB;AAOH;AACD;AACJ;AACA;AACA;;;AACI4G,EAAAA,aAAa,CAACvB,UAAD,EAAa;AACtB;AACA,QAAI,KAAKC,MAAT,EAAiB;AACb,aAAO,KAAKA,MAAZ;AACH,KAJqB,CAKtB;;;AACA,QAAI,KAAKI,SAAT,EAAoB;AAChB,aAAO,KAAKA,SAAZ;AACH,KARqB,CAStB;;;AACA,SAAKrG,QAAL,GAAgB0G,MAAM,CAACC,IAAP,CAAYX,UAAZ,EAAwB3E,GAAxB,CAA6BuF,IAAD,IAAU;AAClD,YAAMR,GAAG,GAAGJ,UAAU,CAACY,IAAD,CAAtB;;AACA,UAAIR,GAAG,KAAK,MAAR,IAAkBA,GAAG,KAAK,IAA9B,EAAoC;AAChC,eAAOQ,IAAP;AACH;;AACD,aAAQ,GAAEA,IAAK,IAAGC,IAAI,CAACC,SAAL,CAAeQ,MAAM,CAAClB,GAAD,CAArB,CAA4B,EAA9C;AACH,KANe,EAMbzF,IANa,CAMR,GANQ,CAAhB;AAOH;;AACD6G,EAAAA,kBAAkB,CAACC,KAAD,EAAQC,IAAR,EAAc;AAC5B,QAAIN,SAAS,CAACnF,MAAV,GAAmB,CAAvB,EAA0B;AACtB,YAAM,IAAIoF,KAAJ,CAAU,sBAAV,CAAN;AACH;;AACD,UAAMrC,CAAC,GAAG5B,KAAK,CAACsE,IAAD,CAAf;;AACA,QAAID,KAAK,KAAK,UAAd,EAA0B;AACtB,YAAME,GAAG,GAAG,KAAK1H,UAAL,CAAgBK,UAAhB,CAA2BsH,SAA3B,CAAsC7G,KAAD,IAAW;AACxD,eAAOA,KAAK,KAAK,IAAjB;AACH,OAFW,CAAZ;AAGA,WAAKd,UAAL,CAAgBK,UAAhB,CAA2BuH,MAA3B,CAAkCF,GAAG,GAAG,CAAxC,EAA2C,CAA3C,EAA8C,GAAG3C,CAAC,CAAC1E,UAAnD;AACA0E,MAAAA,CAAC,CAAC1E,UAAF,CAAa6B,OAAb,CAAsB2F,CAAD,IAAO;AACxB,YAAIA,CAAC,YAAYlI,WAAjB,EAA8B;AAC1BkI,UAAAA,CAAC,CAAC7H,UAAF,GAAe,KAAKA,UAApB;AACH;AACJ,OAJD;AAKH,KAVD,MAWK,IAAIwH,KAAK,KAAK,YAAd,EAA4B;AAC7B,WAAKnH,UAAL,CAAgByH,OAAhB,CAAwB,GAAG/C,CAAC,CAAC1E,UAA7B;AACH,KAFI,MAGA,IAAImH,KAAK,KAAK,WAAd,EAA2B;AAC5BzC,MAAAA,CAAC,CAAC1E,UAAF,CAAa6B,OAAb,CAAsB2F,CAAD,IAAO;AACxB,aAAKjC,WAAL,CAAiBiC,CAAjB;AACH,OAFD;AAGH,KAJI,MAKA,IAAIL,KAAK,KAAK,aAAd,EAA6B;AAC9B,YAAME,GAAG,GAAG,KAAK1H,UAAL,CAAgBK,UAAhB,CAA2BsH,SAA3B,CAAsC7G,KAAD,IAAW;AACxD,eAAOA,KAAK,KAAK,IAAjB;AACH,OAFW,CAAZ;AAGA,WAAKd,UAAL,CAAgBK,UAAhB,CAA2BuH,MAA3B,CAAkCF,GAAlC,EAAuC,CAAvC,EAA0C,GAAG3C,CAAC,CAAC1E,UAA/C;AACA0E,MAAAA,CAAC,CAAC1E,UAAF,CAAa6B,OAAb,CAAsB2F,CAAD,IAAO;AACxB,YAAIA,CAAC,YAAYlI,WAAjB,EAA8B;AAC1BkI,UAAAA,CAAC,CAAC7H,UAAF,GAAe,KAAKA,UAApB;AACH;AACJ,OAJD;AAKH,KAVI,MAWA;AACD,YAAM,IAAIoH,KAAJ,CAAW,wBAAuBI,KAAM,0EAAxC,CAAN;AACH,KArC2B,CAsC5B;AACA;AACA;;AACH;;AACD,MAAIO,WAAJ,GAAkB;AACd,QAAI,KAAK/H,UAAT,EAAqB;AACjB,YAAMY,QAAQ,GAAG,KAAKZ,UAAL,CAAgBK,UAAjC;AACA,UAAIkD,CAAC,GAAG,CAAR;;AACA,aAAOA,CAAC,GAAG3C,QAAQ,CAACoB,MAApB,EAA4B;AACxB,cAAMlB,KAAK,GAAGF,QAAQ,CAAC2C,CAAC,EAAF,CAAtB;;AACA,YAAI,SAASzC,KAAb,EAAoB;AAChB,iBAAOF,QAAQ,CAAC2C,CAAD,CAAR,IAAe,IAAtB;AACH;AACJ;;AACD,aAAO,IAAP;AACH;AACJ;;AACD,MAAIyE,kBAAJ,GAAyB;AACrB,QAAI,KAAKhI,UAAT,EAAqB;AACjB,YAAMY,QAAQ,GAAG,KAAKZ,UAAL,CAAgBK,UAAjC;AACA,UAAIkD,CAAC,GAAG,CAAR;AACA,UAAI0E,IAAI,GAAG,KAAX;;AACA,aAAO1E,CAAC,GAAG3C,QAAQ,CAACoB,MAApB,EAA4B;AACxB,cAAMlB,KAAK,GAAGF,QAAQ,CAAC2C,CAAC,EAAF,CAAtB;;AACA,YAAI0E,IAAJ,EAAU;AACN,cAAInH,KAAK,YAAYnB,WAArB,EAAkC;AAC9B,mBAAOmB,KAAK,IAAI,IAAhB;AACH;AACJ,SAJD,MAKK,IAAI,SAASA,KAAb,EAAoB;AACrBmH,UAAAA,IAAI,GAAG,IAAP;AACH;AACJ;;AACD,aAAO,IAAP;AACH;AACJ;;AA3iByC,C,CA6iB9C;;AACA,MAAMC,cAAc,GAAG,mEAAvB,C,CACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAG,sDAA1B;AACA,MAAMC,oBAAoB,GAAG;AACzBC,EAAAA,IAAI,EAAE,IADmB;AAEzBC,EAAAA,IAAI,EAAE,IAFmB;AAGzBC,EAAAA,IAAI,EAAE,IAHmB;AAIzBC,EAAAA,IAAI,EAAE,IAJmB;AAKzBC,EAAAA,EAAE,EAAE,IALqB;AAMzBC,EAAAA,EAAE,EAAE,IANqB;AAOzBC,EAAAA,GAAG,EAAE,IAPoB;AAQzBC,EAAAA,GAAG,EAAE,IARoB;AASzBC,EAAAA,EAAE,EAAE,IATqB;AAUzBC,EAAAA,EAAE,EAAE,IAVqB;AAWzBC,EAAAA,GAAG,EAAE,IAXoB;AAYzBC,EAAAA,GAAG,EAAE,IAZoB;AAazBC,EAAAA,KAAK,EAAE,IAbkB;AAczBC,EAAAA,KAAK,EAAE,IAdkB;AAezBC,EAAAA,IAAI,EAAE,IAfmB;AAgBzBC,EAAAA,IAAI,EAAE,IAhBmB;AAiBzBC,EAAAA,IAAI,EAAE,IAjBmB;AAkBzBC,EAAAA,IAAI,EAAE,IAlBmB;AAmBzBC,EAAAA,MAAM,EAAE,IAnBiB;AAoBzBC,EAAAA,MAAM,EAAE,IApBiB;AAqBzBC,EAAAA,KAAK,EAAE,IArBkB;AAsBzBC,EAAAA,KAAK,EAAE,IAtBkB;AAuBzBC,EAAAA,KAAK,EAAE,IAvBkB;AAwBzBC,EAAAA,KAAK,EAAE,IAxBkB;AAyBzBC,EAAAA,KAAK,EAAE,IAzBkB;AA0BzBC,EAAAA,KAAK,EAAE,IA1BkB;AA2BzBC,EAAAA,GAAG,EAAE,IA3BoB;AA4BzBC,EAAAA,GAAG,EAAE;AA5BoB,CAA7B;AA8BA,MAAMC,wBAAwB,GAAG;AAC7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GADyB;AAE7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAFyB;AAG7BpF,EAAAA,CAAC,EAAE;AAAEA,IAAAA,CAAC,EAAE,IAAL;AAAWqF,IAAAA,GAAG,EAAE,IAAhB;AAAsBC,IAAAA,CAAC,EAAE,IAAzB;AAA+BC,IAAAA,GAAG,EAAE;AAApC,GAH0B;AAI7BD,EAAAA,CAAC,EAAE;AAAEtF,IAAAA,CAAC,EAAE,IAAL;AAAWqF,IAAAA,GAAG,EAAE,IAAhB;AAAsBC,IAAAA,CAAC,EAAE,IAAzB;AAA+BC,IAAAA,GAAG,EAAE;AAApC,GAJ0B;AAK7BC,EAAAA,CAAC,EAAE;AAAEH,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAL0B;AAM7BE,EAAAA,CAAC,EAAE;AAAEJ,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAN0B;AAO7BG,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GAPyB;AAQ7BD,EAAAA,EAAE,EAAE;AAAEF,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GARyB;AAS7BF,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GATyB;AAU7BA,EAAAA,EAAE,EAAE;AAAEH,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GAVyB;AAW7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAXyB;AAY7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAZyB;AAa7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAbyB;AAc7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAdyB;AAe7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAfyB;AAgB7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAhByB;AAiB7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAjByB;AAkB7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAlByB;AAmB7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GAnByB;AAoB7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GApByB;AAqB7BC,EAAAA,EAAE,EAAE;AAAEA,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB,GArByB;AAsB7BA,EAAAA,EAAE,EAAE;AAAED,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE;AAAhB;AAtByB,CAAjC;AAwBA,MAAMC,wBAAwB,GAAG;AAC7BvB,EAAAA,EAAE,EAAE;AAAEwB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GADyB;AAE7B1B,EAAAA,EAAE,EAAE;AAAEuB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,EAAE,EAAE,IAAhB;AAAsBC,IAAAA,EAAE,EAAE,IAA1B;AAAgCC,IAAAA,EAAE,EAAE;AAApC,GAFyB;AAG7BC,EAAAA,CAAC,EAAE;AAAE1B,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAH0B;AAI7ByB,EAAAA,CAAC,EAAE;AAAE3B,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAJ0B;AAK7BC,EAAAA,CAAC,EAAE;AAAEH,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAL0B;AAM7BE,EAAAA,CAAC,EAAE;AAAEJ,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAN0B;AAO7B/G,EAAAA,CAAC,EAAE;AAAE6G,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAP0B;AAQ7B0B,EAAAA,CAAC,EAAE;AAAE5B,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAR0B;AAS7BvF,EAAAA,CAAC,EAAE;AAAEqF,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAT0B;AAU7BD,EAAAA,CAAC,EAAE;AAAED,IAAAA,GAAG,EAAE,IAAP;AAAaE,IAAAA,GAAG,EAAE;AAAlB,GAV0B;AAW7BG,EAAAA,EAAE,EAAE;AAAEwB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,KAAK,EAAE,IAAnB;AAAyBC,IAAAA,EAAE,EAAE,IAA7B;AAAmCC,IAAAA,KAAK,EAAE;AAA1C,GAXyB;AAY7BzB,EAAAA,EAAE,EAAE;AAAEsB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,KAAK,EAAE,IAAnB;AAAyBC,IAAAA,EAAE,EAAE,IAA7B;AAAmCC,IAAAA,KAAK,EAAE;AAA1C,GAZyB;AAa7B1B,EAAAA,EAAE,EAAE;AAAEuB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,KAAK,EAAE,IAAnB;AAAyBC,IAAAA,EAAE,EAAE,IAA7B;AAAmCC,IAAAA,KAAK,EAAE;AAA1C,GAbyB;AAc7BxB,EAAAA,EAAE,EAAE;AAAEqB,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,KAAK,EAAE,IAAnB;AAAyBC,IAAAA,EAAE,EAAE,IAA7B;AAAmCC,IAAAA,KAAK,EAAE;AAA1C;AAdyB,CAAjC;AAgBA,MAAMC,SAAS,GAAG,2BAAlB;AACA,OAAO,SAASlJ,KAAT,CAAemJ,IAAf,EAAqBrJ,OAAO,GAAG;AAAEsJ,EAAAA,gBAAgB,EAAE,KAApB;AAA2BC,EAAAA,OAAO,EAAE;AAApC,CAA/B,EAA4E;AAC/E,QAAMC,QAAQ,GAAGxJ,OAAO,CAACyJ,iBAAR,IAA6B;AAC1CC,IAAAA,MAAM,EAAE,IADkC;AAE1CC,IAAAA,QAAQ,EAAE,IAFgC;AAG1CC,IAAAA,KAAK,EAAE,IAHmC;AAI1CrL,IAAAA,GAAG,EAAE;AAJqC,GAA9C;AAMA,QAAMsL,aAAa,GAAGrG,MAAM,CAACC,IAAP,CAAY+F,QAAZ,CAAtB;AACA,QAAMM,kBAAkB,GAAGD,aAAa,CAAC1L,GAAd,CAAmB4L,EAAD,IAAQ;AACjD,WAAO,IAAIC,MAAJ,CAAWD,EAAX,EAAe,GAAf,CAAP;AACH,GAF0B,CAA3B;AAGA,QAAME,eAAe,GAAGJ,aAAa,CAACjM,MAAd,CAAsBmM,EAAD,IAAQ;AACjD,WAAOP,QAAQ,CAACO,EAAD,CAAf;AACH,GAFuB,EAErB5L,GAFqB,CAEhB4L,EAAD,IAAQ;AACX,WAAO,IAAIC,MAAJ,CAAWD,EAAX,EAAe,GAAf,CAAP;AACH,GAJuB,CAAxB;;AAKA,WAASG,wBAAT,CAAkCzK,GAAlC,EAAuC;AACnC,WAAOwK,eAAe,CAACE,IAAhB,CAAsBJ,EAAD,IAAQ;AAChC,aAAOA,EAAE,CAACpK,IAAH,CAAQF,GAAR,CAAP;AACH,KAFM,CAAP;AAGH;;AACD,WAAS2K,qBAAT,CAA+B3K,GAA/B,EAAoC;AAChC,WAAOqK,kBAAkB,CAACK,IAAnB,CAAyBJ,EAAD,IAAQ;AACnC,aAAOA,EAAE,CAACpK,IAAH,CAAQF,GAAR,CAAP;AACH,KAFM,CAAP;AAGH;;AACD,QAAM4K,IAAI,GAAG,IAAI3N,WAAJ,CAAgB,IAAhB,EAAsB,EAAtB,CAAb;AACA,MAAI4N,aAAa,GAAGD,IAApB;AACA,QAAMnI,KAAK,GAAG,CAACmI,IAAD,CAAd;AACA,MAAIE,WAAW,GAAG,CAAC,CAAnB;AACA,MAAIlH,KAAJ,CA9B+E,CA+B/E;;AACAgG,EAAAA,IAAI,GAAI,IAAGD,SAAU,IAAGC,IAAK,KAAID,SAAU,GAA3C;;AACA,SAAQ/F,KAAK,GAAG4B,cAAc,CAAC3B,IAAf,CAAoB+F,IAApB,CAAhB,EAA4C;AACxC,QAAIkB,WAAW,GAAG,CAAC,CAAnB,EAAsB;AAClB,UAAIA,WAAW,GAAGlH,KAAK,CAAC,CAAD,CAAL,CAAStE,MAAvB,GAAgCkG,cAAc,CAACuF,SAAnD,EAA8D;AAC1D;AACA,cAAM/L,IAAI,GAAG4K,IAAI,CAACoB,SAAL,CAAeF,WAAf,EAA4BtF,cAAc,CAACuF,SAAf,GAA2BnH,KAAK,CAAC,CAAD,CAAL,CAAStE,MAAhE,CAAb;AACAuL,QAAAA,aAAa,CAAC3H,WAAd,CAA0B,IAAIxG,QAAJ,CAAasC,IAAb,CAA1B;AACH;AACJ;;AACD8L,IAAAA,WAAW,GAAGtF,cAAc,CAACuF,SAA7B;;AACA,QAAInH,KAAK,CAAC,CAAD,CAAL,KAAa+F,SAAjB,EAA4B;AACxB;AACH;;AACD,QAAI/F,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,MAAgB,GAApB,EAAyB;AACrB;AACA,UAAIrD,OAAO,CAACuJ,OAAZ,EAAqB;AACjB;AACA,cAAM9K,IAAI,GAAG4K,IAAI,CAACoB,SAAL,CAAeF,WAAW,GAAG,CAA7B,EAAgCA,WAAW,GAAGlH,KAAK,CAAC,CAAD,CAAL,CAAStE,MAAvB,GAAgC,CAAhE,CAAb;AACAuL,QAAAA,aAAa,CAAC3H,WAAd,CAA0B,IAAIrG,WAAJ,CAAgBmC,IAAhB,CAA1B;AACH;;AACD;AACH;;AACD,QAAIuB,OAAO,CAACsJ,gBAAZ,EAA8B;AAC1BjG,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,CAASqH,WAAT,EAAX;AACH;;AACD,QAAI,CAACrH,KAAK,CAAC,CAAD,CAAV,EAAe;AACX;AACA,YAAMzD,KAAK,GAAG,EAAd;;AACA,WAAK,IAAI+K,QAAT,EAAoBA,QAAQ,GAAGzF,iBAAiB,CAAC5B,IAAlB,CAAuBD,KAAK,CAAC,CAAD,CAA5B,CAA/B,GAAmE;AAC/DzD,QAAAA,KAAK,CAAC+K,QAAQ,CAAC,CAAD,CAAR,CAAYD,WAAZ,EAAD,CAAL,GAAmCC,QAAQ,CAAC,CAAD,CAAR,IAAeA,QAAQ,CAAC,CAAD,CAAvB,IAA8BA,QAAQ,CAAC,CAAD,CAAzE;AACH;;AACD,YAAM/N,OAAO,GAAG0N,aAAa,CAACnN,UAA9B;;AACA,UAAI,CAACkG,KAAK,CAAC,CAAD,CAAN,IAAa2D,wBAAwB,CAACpK,OAAD,CAAzC,EAAoD;AAChD,YAAIoK,wBAAwB,CAACpK,OAAD,CAAxB,CAAkCyG,KAAK,CAAC,CAAD,CAAvC,CAAJ,EAAiD;AAC7CnB,UAAAA,KAAK,CAACG,GAAN;AACAiI,UAAAA,aAAa,GAAGjO,QAAQ,CAAC6F,KAAD,CAAxB;AACH;AACJ,OAZU,CAaX;AACA;;;AACAoI,MAAAA,aAAa,GAAGA,aAAa,CAAC3H,WAAd,CAA0B,IAAIjG,WAAJ,CAAgB2G,KAAK,CAAC,CAAD,CAArB,EAA0BzD,KAA1B,EAAiCyD,KAAK,CAAC,CAAD,CAAtC,CAA1B,CAAhB;AACAnB,MAAAA,KAAK,CAAClD,IAAN,CAAWsL,aAAX;;AACA,UAAIF,qBAAqB,CAAC/G,KAAK,CAAC,CAAD,CAAN,CAAzB,EAAqC;AACjC;AACA,cAAMuH,WAAW,GAAI,KAAIvH,KAAK,CAAC,CAAD,CAAI,GAAlC;;AACA,cAAM7C,KAAK,GAAG,CAAC,MAAM;AACjB,cAAIR,OAAO,CAACsJ,gBAAZ,EAA8B;AAC1B,mBAAOD,IAAI,CAACwB,iBAAL,GAAyBC,OAAzB,CAAiCF,WAAjC,EAA8C3F,cAAc,CAACuF,SAA7D,CAAP;AACH;;AACD,iBAAOnB,IAAI,CAACyB,OAAL,CAAaF,WAAb,EAA0B3F,cAAc,CAACuF,SAAzC,CAAP;AACH,SALa,GAAd;;AAMA,YAAIN,wBAAwB,CAAC7G,KAAK,CAAC,CAAD,CAAN,CAA5B,EAAwC;AACpC,cAAI5E,IAAJ;;AACA,cAAI+B,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd;AACA/B,YAAAA,IAAI,GAAG4K,IAAI,CAAC3I,MAAL,CAAYuE,cAAc,CAACuF,SAA3B,CAAP;AACH,WAHD,MAIK;AACD/L,YAAAA,IAAI,GAAG4K,IAAI,CAACoB,SAAL,CAAexF,cAAc,CAACuF,SAA9B,EAAyChK,KAAzC,CAAP;AACH;;AACD,cAAI/B,IAAI,CAACM,MAAL,GAAc,CAAlB,EAAqB;AACjBuL,YAAAA,aAAa,CAAC3H,WAAd,CAA0B,IAAIxG,QAAJ,CAAasC,IAAb,CAA1B;AACH;AACJ;;AACD,YAAI+B,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd+J,UAAAA,WAAW,GAAGtF,cAAc,CAACuF,SAAf,GAA2BnB,IAAI,CAACtK,MAAL,GAAc,CAAvD;AACH,SAFD,MAGK;AACDwL,UAAAA,WAAW,GAAGtF,cAAc,CAACuF,SAAf,GAA2BhK,KAAK,GAAGoK,WAAW,CAAC7L,MAA7D;AACAsE,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAW,MAAX;AACH;AACJ;AACJ;;AACD,QAAIA,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAjB,IAAwB8B,oBAAoB,CAAC9B,KAAK,CAAC,CAAD,CAAN,CAAhD,EAA4D;AACxD;AACA,aAAO,IAAP,EAAa;AACT,YAAIiH,aAAa,CAACnN,UAAd,KAA6BkG,KAAK,CAAC,CAAD,CAAtC,EAA2C;AACvCnB,UAAAA,KAAK,CAACG,GAAN;AACAiI,UAAAA,aAAa,GAAGjO,QAAQ,CAAC6F,KAAD,CAAxB;AACA;AACH,SAJD,MAKK;AACD,gBAAMtF,OAAO,GAAG0N,aAAa,CAAC1N,OAA9B,CADC,CAED;;AACA,cAAI4L,wBAAwB,CAAC5L,OAAD,CAA5B,EAAuC;AACnC,gBAAI4L,wBAAwB,CAAC5L,OAAD,CAAxB,CAAkCyG,KAAK,CAAC,CAAD,CAAvC,CAAJ,EAAiD;AAC7CnB,cAAAA,KAAK,CAACG,GAAN;AACAiI,cAAAA,aAAa,GAAGjO,QAAQ,CAAC6F,KAAD,CAAxB;AACA;AACH;AACJ,WATA,CAUD;;;AACA;AACH;AACJ;AACJ;AACJ;;AACD,QAAM6I,KAAK,GAAGC,OAAO,CAAC9I,KAAK,CAACnD,MAAN,KAAiB,CAAlB,CAArB;;AACA,MAAI,CAACiB,OAAO,CAACiL,KAAb,EAAoB;AAChB,UAAMC,QAAQ,GAAGb,IAAjB;AACAa,IAAAA,QAAQ,CAACH,KAAT,GAAiBA,KAAjB;;AACA,WAAO7I,KAAK,CAACnD,MAAN,GAAe,CAAtB,EAAyB;AACrB;AACA,YAAMoM,IAAI,GAAGjJ,KAAK,CAACG,GAAN,EAAb;AACA,YAAM+I,SAAS,GAAG/O,QAAQ,CAAC6F,KAAD,CAA1B;;AACA,UAAIiJ,IAAI,CAACpO,UAAL,IAAmBoO,IAAI,CAACpO,UAAL,CAAgBA,UAAvC,EAAmD;AAC/C,YAAIoO,IAAI,CAACpO,UAAL,KAAoBqO,SAApB,IAAiCD,IAAI,CAACvO,OAAL,KAAiBwO,SAAS,CAACxO,OAAhE,EAAyE;AACrE;AACAwO,UAAAA,SAAS,CAACtN,WAAV,CAAsBqN,IAAtB;AACAA,UAAAA,IAAI,CAAC/N,UAAL,CAAgB6B,OAAhB,CAAyBpB,KAAD,IAAW;AAC/BuN,YAAAA,SAAS,CAACrO,UAAV,CAAqB4F,WAArB,CAAiC9E,KAAjC;AACH,WAFD;AAGAqE,UAAAA,KAAK,CAACG,GAAN;AACH,SAPD,MAQK;AACD;AACA+I,UAAAA,SAAS,CAACtN,WAAV,CAAsBqN,IAAtB;AACAA,UAAAA,IAAI,CAAC/N,UAAL,CAAgB6B,OAAhB,CAAyBpB,KAAD,IAAW;AAC/BuN,YAAAA,SAAS,CAACzI,WAAV,CAAsB9E,KAAtB;AACH,WAFD;AAGH;AACJ,OAhBD,MAiBK,CACD;AACH;AACJ;;AACDqN,IAAAA,QAAQ,CAAC9N,UAAT,CAAoB6B,OAApB,CAA6BlB,IAAD,IAAU;AAClC,UAAIA,IAAI,YAAYrB,WAApB,EAAiC;AAC7BqB,QAAAA,IAAI,CAAChB,UAAL,GAAkB,IAAlB;AACH;AACJ,KAJD;AAKA,WAAOmO,QAAP;AACH;;AACD,QAAMA,QAAQ,GAAG,IAAI/O,QAAJ,CAAakN,IAAb,CAAjB;AACA6B,EAAAA,QAAQ,CAACH,KAAT,GAAiBA,KAAjB;AACA,SAAOG,QAAP;AACH","sourcesContent":["import { decode } from 'he';\nimport Node from './node';\nimport NodeType from './type';\nimport TextNode from './text';\nimport Matcher from '../matcher';\nimport arr_back from '../back';\nimport CommentNode from './comment';\nconst kBlockElements = new Map();\nkBlockElements.set('DIV', true);\nkBlockElements.set('div', true);\nkBlockElements.set('P', true);\nkBlockElements.set('p', true);\n// ul: true,\n// ol: true,\nkBlockElements.set('LI', true);\nkBlockElements.set('li', true);\n// table: true,\n// tr: true,\nkBlockElements.set('TD', true);\nkBlockElements.set('td', true);\nkBlockElements.set('SECTION', true);\nkBlockElements.set('section', true);\nkBlockElements.set('BR', true);\nkBlockElements.set('br', true);\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\nexport default class HTMLElement extends Node {\n    /**\n     * Creates an instance of HTMLElement.\n     * @param keyAttrs\tid and class attribute\n     * @param [rawAttrs]\tattributes in string\n     *\n     * @memberof HTMLElement\n     */\n    constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n        super();\n        this.rawAttrs = rawAttrs;\n        this.parentNode = parentNode;\n        this.classNames = [];\n        /**\n         * Node Type declaration.\n         */\n        this.nodeType = NodeType.ELEMENT_NODE;\n        this.rawTagName = tagName;\n        this.rawAttrs = rawAttrs || '';\n        this.parentNode = parentNode || null;\n        this.childNodes = [];\n        if (keyAttrs.id) {\n            this.id = keyAttrs.id;\n            if (!rawAttrs) {\n                this.rawAttrs = `id=\"${keyAttrs.id}\"`;\n            }\n        }\n        if (keyAttrs.class) {\n            this.classNames = keyAttrs.class.split(/\\s+/);\n            if (!rawAttrs) {\n                const cls = `class=\"${this.classNames.join(' ')}\"`;\n                if (this.rawAttrs) {\n                    this.rawAttrs += ` ${cls}`;\n                }\n                else {\n                    this.rawAttrs = cls;\n                }\n            }\n        }\n    }\n    /**\n     * Remove current element\n     */\n    remove() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            this.parentNode.childNodes = children.filter((child) => {\n                return this !== child;\n            });\n        }\n    }\n    /**\n     * Remove Child element from childNodes array\n     * @param {HTMLElement} node     node to remove\n     */\n    removeChild(node) {\n        this.childNodes = this.childNodes.filter((child) => {\n            return (child !== node);\n        });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n    exchangeChild(oldNode, newNode) {\n        const children = this.childNodes;\n        this.childNodes = children.map((child) => {\n            if (child === oldNode) {\n                return newNode;\n            }\n            return child;\n        });\n    }\n    get tagName() {\n        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n    get rawText() {\n        return this.childNodes.reduce((pre, cur) => {\n            return (pre += cur.rawText);\n        }, '');\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n    get text() {\n        return decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n    get structuredText() {\n        let currentBlock = [];\n        const blocks = [currentBlock];\n        function dfs(node) {\n            if (node.nodeType === NodeType.ELEMENT_NODE) {\n                if (kBlockElements.get(node.rawTagName)) {\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                    node.childNodes.forEach(dfs);\n                    if (currentBlock.length > 0) {\n                        blocks.push(currentBlock = []);\n                    }\n                }\n                else {\n                    node.childNodes.forEach(dfs);\n                }\n            }\n            else if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    // Whitespace node, postponed output\n                    currentBlock.prependWhitespace = true;\n                }\n                else {\n                    let text = node.text;\n                    if (currentBlock.prependWhitespace) {\n                        text = ` ${text}`;\n                        currentBlock.prependWhitespace = false;\n                    }\n                    currentBlock.push(text);\n                }\n            }\n        }\n        dfs(this);\n        return blocks.map((block) => {\n            // Normalize each line's whitespace\n            return block.join('').trim().replace(/\\s{2,}/g, ' ');\n        })\n            .join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n    toString() {\n        const tag = this.rawTagName;\n        if (tag) {\n            const is_void = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(tag);\n            const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : '';\n            if (is_void) {\n                return `<${tag}${attrs}>`;\n            }\n            return `<${tag}${attrs}>${this.innerHTML}</${tag}>`;\n        }\n        return this.innerHTML;\n    }\n    get innerHTML() {\n        return this.childNodes.map((child) => {\n            return child.toString();\n        }).join('');\n    }\n    set_content(content, options = {}) {\n        if (content instanceof Node) {\n            content = [content];\n        }\n        else if (typeof content == 'string') {\n            const r = parse(content, options);\n            content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n        }\n        this.childNodes = content;\n    }\n    get outerHTML() {\n        return this.toString();\n    }\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    trimRight(pattern) {\n        for (let i = 0; i < this.childNodes.length; i++) {\n            const childNode = this.childNodes[i];\n            if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                childNode.trimRight(pattern);\n            }\n            else {\n                const index = childNode.rawText.search(pattern);\n                if (index > -1) {\n                    childNode.rawText = childNode.rawText.substr(0, index);\n                    // trim all following nodes.\n                    this.childNodes.length = i + 1;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n    get structure() {\n        const res = [];\n        let indention = 0;\n        function write(str) {\n            res.push('  '.repeat(indention) + str);\n        }\n        function dfs(node) {\n            const idStr = node.id ? (`#${node.id}`) : '';\n            const classStr = node.classNames.length ? (`.${node.classNames.join('.')}`) : '';\n            write(node.rawTagName + idStr + classStr);\n            indention++;\n            node.childNodes.forEach((childNode) => {\n                if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n                    dfs(childNode);\n                }\n                else if (childNode.nodeType === NodeType.TEXT_NODE) {\n                    if (!childNode.isWhitespace) {\n                        write('#text');\n                    }\n                }\n            });\n            indention--;\n        }\n        dfs(this);\n        return res.join('\\n');\n    }\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    removeWhitespace() {\n        let o = 0;\n        this.childNodes.forEach((node) => {\n            if (node.nodeType === NodeType.TEXT_NODE) {\n                if (node.isWhitespace) {\n                    return;\n                }\n                node.rawText = node.rawText.trim();\n            }\n            else if (node.nodeType === NodeType.ELEMENT_NODE) {\n                node.removeWhitespace();\n            }\n            this.childNodes[o++] = node;\n        });\n        this.childNodes.length = o;\n        return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n    querySelectorAll(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            if (selector.includes(',')) {\n                const selectors = selector.split(',');\n                return Array.from(selectors.reduce((pre, cur) => {\n                    const result = this.querySelectorAll(cur.trim());\n                    return result.reduce((p, c) => {\n                        return p.add(c);\n                    }, pre);\n                }, new Set()));\n            }\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        return this.childNodes.reduce((res, cur) => {\n            stack.push([cur, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack); // get last element\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    const html_el = el;\n                    state[2] = matcher.advance(html_el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            res.push(html_el);\n                            res.push(...(html_el.querySelectorAll(selector)));\n                            // no need to go further.\n                            matcher.rewind();\n                            stack.pop();\n                            continue;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n            return res;\n        }, []);\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n    querySelector(selector) {\n        let matcher;\n        if (selector instanceof Matcher) {\n            matcher = selector;\n            matcher.reset();\n        }\n        else {\n            matcher = new Matcher(selector);\n        }\n        const stack = [];\n        for (const node of this.childNodes) {\n            stack.push([node, 0, false]);\n            while (stack.length) {\n                const state = arr_back(stack);\n                const el = state[0];\n                if (state[1] === 0) {\n                    // Seen for first time.\n                    if (el.nodeType !== NodeType.ELEMENT_NODE) {\n                        stack.pop();\n                        continue;\n                    }\n                    state[2] = matcher.advance(el);\n                    if (state[2]) {\n                        if (matcher.matched) {\n                            return el;\n                        }\n                    }\n                }\n                if (state[1] < el.childNodes.length) {\n                    stack.push([el.childNodes[state[1]++], 0, false]);\n                }\n                else {\n                    if (state[2]) {\n                        matcher.rewind();\n                    }\n                    stack.pop();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n    appendChild(node) {\n        // node.parentNode = this;\n        this.childNodes.push(node);\n        if (node instanceof HTMLElement) {\n            node.parentNode = this;\n        }\n        return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n    get firstChild() {\n        return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n    get lastChild() {\n        return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n    get attributes() {\n        if (this._attrs) {\n            return this._attrs;\n        }\n        this._attrs = {};\n        const attrs = this.rawAttributes;\n        for (const key in attrs) {\n            const val = attrs[key] || '';\n            this._attrs[key] = decode(val);\n        }\n        return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n    get rawAttributes() {\n        if (this._rawAttrs) {\n            return this._rawAttrs;\n        }\n        const attrs = {};\n        if (this.rawAttrs) {\n            const re = /\\b([a-z][a-z0-9-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n            let match;\n            while ((match = re.exec(this.rawAttrs))) {\n                attrs[match[1]] = match[2] || match[3] || match[4] || null;\n            }\n        }\n        this._rawAttrs = attrs;\n        return attrs;\n    }\n    removeAttribute(key) {\n        const attrs = this.rawAttributes;\n        delete attrs[key];\n        // Update this.attribute\n        if (this._attrs) {\n            delete this._attrs[key];\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === undefined || val === 'null') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    hasAttribute(key) {\n        return key in this.attributes;\n    }\n    /**\n     * Get an attribute\n     * @return {string} value of the attribute\n     */\n    getAttribute(key) {\n        return this.attributes[key];\n    }\n    /**\n     * Set an attribute value to the HTMLElement\n     * @param {string} key The attribute name\n     * @param {string} value The value to set, or null / undefined to remove an attribute\n     */\n    setAttribute(key, value) {\n        if (arguments.length < 2) {\n            throw new Error('Failed to execute \\'setAttribute\\' on \\'Element\\'');\n        }\n        const attrs = this.rawAttributes;\n        attrs[key] = String(value);\n        if (this._attrs) {\n            this._attrs[key] = decode(attrs[key]);\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attrs).map((name) => {\n            const val = JSON.stringify(attrs[name]);\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${val}`;\n        }).join(' ');\n    }\n    /**\n     * Replace all the attributes of the HTMLElement by the provided attributes\n     * @param {Attributes} attributes the new attribute set\n     */\n    setAttributes(attributes) {\n        // Invalidate current this.attributes\n        if (this._attrs) {\n            delete this._attrs;\n        }\n        // Invalidate current this.rawAttributes\n        if (this._rawAttrs) {\n            delete this._rawAttrs;\n        }\n        // Update rawString\n        this.rawAttrs = Object.keys(attributes).map((name) => {\n            const val = attributes[name];\n            if (val === 'null' || val === '\"\"') {\n                return name;\n            }\n            return `${name}=${JSON.stringify(String(val))}`;\n        }).join(' ');\n    }\n    insertAdjacentHTML(where, html) {\n        if (arguments.length < 2) {\n            throw new Error('2 arguments required');\n        }\n        const p = parse(html);\n        if (where === 'afterend') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx + 1, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else if (where === 'afterbegin') {\n            this.childNodes.unshift(...p.childNodes);\n        }\n        else if (where === 'beforeend') {\n            p.childNodes.forEach((n) => {\n                this.appendChild(n);\n            });\n        }\n        else if (where === 'beforebegin') {\n            const idx = this.parentNode.childNodes.findIndex((child) => {\n                return child === this;\n            });\n            this.parentNode.childNodes.splice(idx, 0, ...p.childNodes);\n            p.childNodes.forEach((n) => {\n                if (n instanceof HTMLElement) {\n                    n.parentNode = this.parentNode;\n                }\n            });\n        }\n        else {\n            throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);\n        }\n        // if (!where || html === undefined || html === null) {\n        // \treturn;\n        // }\n    }\n    get nextSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            while (i < children.length) {\n                const child = children[i++];\n                if (this === child) {\n                    return children[i] || null;\n                }\n            }\n            return null;\n        }\n    }\n    get nextElementSibling() {\n        if (this.parentNode) {\n            const children = this.parentNode.childNodes;\n            let i = 0;\n            let find = false;\n            while (i < children.length) {\n                const child = children[i++];\n                if (find) {\n                    if (child instanceof HTMLElement) {\n                        return child || null;\n                    }\n                }\n                else if (this === child) {\n                    find = true;\n                }\n            }\n            return null;\n        }\n    }\n}\n// https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.:0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\n// <(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\n// <([a-z][-.:0-9_a-z]*)\\s*\\/>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>\n// <(area|base|br|col|hr|img|input|link|meta|source)\\s*(.*)\\/?>|<(?<tag>[^\\s]*)(.*)>(.*)</\\k<tag>>\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n    area: true,\n    AREA: true,\n    base: true,\n    BASE: true,\n    br: true,\n    BR: true,\n    col: true,\n    COL: true,\n    hr: true,\n    HR: true,\n    img: true,\n    IMG: true,\n    input: true,\n    INPUT: true,\n    link: true,\n    LINK: true,\n    meta: true,\n    META: true,\n    source: true,\n    SOURCE: true,\n    embed: true,\n    EMBED: true,\n    param: true,\n    PARAM: true,\n    track: true,\n    TRACK: true,\n    wbr: true,\n    WBR: true\n};\nconst kElementsClosedByOpening = {\n    li: { li: true, LI: true },\n    LI: { li: true, LI: true },\n    p: { p: true, div: true, P: true, DIV: true },\n    P: { p: true, div: true, P: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    td: { td: true, th: true, TD: true, TH: true },\n    TD: { td: true, th: true, TD: true, TH: true },\n    th: { td: true, th: true, TD: true, TH: true },\n    TH: { td: true, th: true, TD: true, TH: true },\n    h1: { h1: true, H1: true },\n    H1: { h1: true, H1: true },\n    h2: { h2: true, H2: true },\n    H2: { h2: true, H2: true },\n    h3: { h3: true, H3: true },\n    H3: { h3: true, H3: true },\n    h4: { h4: true, H4: true },\n    H4: { h4: true, H4: true },\n    h5: { h5: true, H5: true },\n    H5: { h5: true, H5: true },\n    h6: { h6: true, H6: true },\n    H6: { h6: true, H6: true }\n};\nconst kElementsClosedByClosing = {\n    li: { ul: true, ol: true, UL: true, OL: true },\n    LI: { ul: true, ol: true, UL: true, OL: true },\n    a: { div: true, DIV: true },\n    A: { div: true, DIV: true },\n    b: { div: true, DIV: true },\n    B: { div: true, DIV: true },\n    i: { div: true, DIV: true },\n    I: { div: true, DIV: true },\n    p: { div: true, DIV: true },\n    P: { div: true, DIV: true },\n    td: { tr: true, table: true, TR: true, TABLE: true },\n    TD: { tr: true, table: true, TR: true, TABLE: true },\n    th: { tr: true, table: true, TR: true, TABLE: true },\n    TH: { tr: true, table: true, TR: true, TABLE: true }\n};\nconst frameflag = 'documentfragmentcontainer';\nexport function parse(data, options = { lowerCaseTagName: false, comment: false }) {\n    const elements = options.blockTextElements || {\n        script: true,\n        noscript: true,\n        style: true,\n        pre: true\n    };\n    const element_names = Object.keys(elements);\n    const kBlockTextElements = element_names.map((it) => {\n        return new RegExp(it, 'i');\n    });\n    const kIgnoreElements = element_names.filter((it) => {\n        return elements[it];\n    }).map((it) => {\n        return new RegExp(it, 'i');\n    });\n    function element_should_be_ignore(tag) {\n        return kIgnoreElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    function is_block_text_element(tag) {\n        return kBlockTextElements.some((it) => {\n            return it.test(tag);\n        });\n    }\n    const root = new HTMLElement(null, {});\n    let currentParent = root;\n    const stack = [root];\n    let lastTextPos = -1;\n    let match;\n    // https://github.com/taoqf/node-html-parser/issues/38\n    data = `<${frameflag}>${data}</${frameflag}>`;\n    while ((match = kMarkupPattern.exec(data))) {\n        if (lastTextPos > -1) {\n            if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n                // if has content\n                const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n                currentParent.appendChild(new TextNode(text));\n            }\n        }\n        lastTextPos = kMarkupPattern.lastIndex;\n        if (match[2] === frameflag) {\n            continue;\n        }\n        if (match[0][1] === '!') {\n            // this is a comment\n            if (options.comment) {\n                // Only keep what is in between <!-- and -->\n                const text = data.substring(lastTextPos - 3, lastTextPos - match[0].length + 4);\n                currentParent.appendChild(new CommentNode(text));\n            }\n            continue;\n        }\n        if (options.lowerCaseTagName) {\n            match[2] = match[2].toLowerCase();\n        }\n        if (!match[1]) {\n            // not </ tags\n            const attrs = {};\n            for (let attMatch; (attMatch = kAttributePattern.exec(match[3]));) {\n                attrs[attMatch[2].toLowerCase()] = attMatch[4] || attMatch[5] || attMatch[6];\n            }\n            const tagName = currentParent.rawTagName;\n            if (!match[4] && kElementsClosedByOpening[tagName]) {\n                if (kElementsClosedByOpening[tagName][match[2]]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                }\n            }\n            // ignore container tag we add above\n            // https://github.com/taoqf/node-html-parser/issues/38\n            currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n            stack.push(currentParent);\n            if (is_block_text_element(match[2])) {\n                // a little test to find next </script> or </style> ...\n                const closeMarkup = `</${match[2]}>`;\n                const index = (() => {\n                    if (options.lowerCaseTagName) {\n                        return data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                    }\n                    return data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n                })();\n                if (element_should_be_ignore(match[2])) {\n                    let text;\n                    if (index === -1) {\n                        // there is no matching ending for the text element.\n                        text = data.substr(kMarkupPattern.lastIndex);\n                    }\n                    else {\n                        text = data.substring(kMarkupPattern.lastIndex, index);\n                    }\n                    if (text.length > 0) {\n                        currentParent.appendChild(new TextNode(text));\n                    }\n                }\n                if (index === -1) {\n                    lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n                }\n                else {\n                    lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n                    match[1] = 'true';\n                }\n            }\n        }\n        if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n            // </ or /> or <br> etc.\n            while (true) {\n                if (currentParent.rawTagName === match[2]) {\n                    stack.pop();\n                    currentParent = arr_back(stack);\n                    break;\n                }\n                else {\n                    const tagName = currentParent.tagName;\n                    // Trying to close current tag, and move on\n                    if (kElementsClosedByClosing[tagName]) {\n                        if (kElementsClosedByClosing[tagName][match[2]]) {\n                            stack.pop();\n                            currentParent = arr_back(stack);\n                            continue;\n                        }\n                    }\n                    // Use aggressive strategy to handle unmatching markups.\n                    break;\n                }\n            }\n        }\n    }\n    const valid = Boolean(stack.length === 1);\n    if (!options.noFix) {\n        const response = root;\n        response.valid = valid;\n        while (stack.length > 1) {\n            // Handle each error elements.\n            const last = stack.pop();\n            const oneBefore = arr_back(stack);\n            if (last.parentNode && last.parentNode.parentNode) {\n                if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n                    // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.parentNode.appendChild(child);\n                    });\n                    stack.pop();\n                }\n                else {\n                    // Single error  <div> <h3> </div> handle: Just removes <h3>\n                    oneBefore.removeChild(last);\n                    last.childNodes.forEach((child) => {\n                        oneBefore.appendChild(child);\n                    });\n                }\n            }\n            else {\n                // If it's final element just skip.\n            }\n        }\n        response.childNodes.forEach((node) => {\n            if (node instanceof HTMLElement) {\n                node.parentNode = null;\n            }\n        });\n        return response;\n    }\n    const response = new TextNode(data);\n    response.valid = valid;\n    return response;\n}\n"]},"metadata":{},"sourceType":"module"}