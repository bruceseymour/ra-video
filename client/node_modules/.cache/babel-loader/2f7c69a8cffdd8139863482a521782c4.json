{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.recursiveReadDir = recursiveReadDir;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n/**\n* Recursively read directory\n* @param  {string} dir Directory to read\n* @param  {RegExp} filter Filter for the file name, only the name part is considered, not the full path\n* @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n* @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n* @returns Promise array holding all relative paths\n*/\n\n\nasync function recursiveReadDir(dir, filter, ignore, arr = [], rootDir = dir) {\n  const result = await _fs.promises.readdir(dir);\n  await Promise.all(result.map(async part => {\n    const absolutePath = (0, _path.join)(dir, part);\n    if (ignore && ignore.test(part)) return;\n    const pathStat = await _fs.promises.stat(absolutePath);\n\n    if (pathStat.isDirectory()) {\n      await recursiveReadDir(absolutePath, filter, ignore, arr, rootDir);\n      return;\n    }\n\n    if (!filter.test(part)) {\n      return;\n    }\n\n    arr.push(absolutePath.replace(rootDir, ''));\n  }));\n  return arr.sort();\n}","map":{"version":3,"sources":["../../lib/recursive-readdir.ts"],"names":["arr","rootDir","result","promises","Promise","absolutePath","ignore","pathStat","recursiveReadDir","filter"],"mappings":";;;;;AAAA,IAAA,GAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAA,gBAAA,CAAA,GAAA,EAAA,MAAA,EAAA,MAAA,EAILA,GAAa,GAJR,EAAA,EAKLC,OAAe,GALV,GAAA,EAMc;AACnB,QAAMC,MAAM,GAAG,MAAMC,GAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAArB,GAAqBA,CAArB;AAEA,QAAMC,OAAO,CAAPA,GAAAA,CACJF,MAAM,CAANA,GAAAA,CAAW,MAAA,IAAA,IAAwB;AACjC,UAAMG,YAAY,GAAG,CAAA,GAAA,KAAA,CAAA,IAAA,EAAA,GAAA,EAArB,IAAqB,CAArB;AACA,QAAIC,MAAM,IAAIA,MAAM,CAANA,IAAAA,CAAd,IAAcA,CAAd,EAAiC;AAEjC,UAAMC,QAAQ,GAAG,MAAMJ,GAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAvB,YAAuBA,CAAvB;;AAEA,QAAII,QAAQ,CAAZ,WAAIA,EAAJ,EAA4B;AAC1B,YAAMC,gBAAgB,CAAA,YAAA,EAAA,MAAA,EAAA,MAAA,EAAA,GAAA,EAAtB,OAAsB,CAAtB;AACA;AAGF;;AAAA,QAAI,CAACC,MAAM,CAANA,IAAAA,CAAL,IAAKA,CAAL,EAAwB;AACtB;AAGFT;;AAAAA,IAAAA,GAAG,CAAHA,IAAAA,CAASK,YAAY,CAAZA,OAAAA,CAAAA,OAAAA,EAATL,EAASK,CAATL;AAhBJ,GACEE,CADIE,CAAN;AAoBA,SAAOJ,GAAG,CAAV,IAAOA,EAAP;AACD","sourcesContent":["import { promises } from 'fs'\nimport { join } from 'path'\n\n/**\n * Recursively read directory\n * @param  {string} dir Directory to read\n * @param  {RegExp} filter Filter for the file name, only the name part is considered, not the full path\n * @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n * @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n * @returns Promise array holding all relative paths\n */\nexport async function recursiveReadDir(\n  dir: string,\n  filter: RegExp,\n  ignore?: RegExp,\n  arr: string[] = [],\n  rootDir: string = dir\n): Promise<string[]> {\n  const result = await promises.readdir(dir)\n\n  await Promise.all(\n    result.map(async (part: string) => {\n      const absolutePath = join(dir, part)\n      if (ignore && ignore.test(part)) return\n\n      const pathStat = await promises.stat(absolutePath)\n\n      if (pathStat.isDirectory()) {\n        await recursiveReadDir(absolutePath, filter, ignore, arr, rootDir)\n        return\n      }\n\n      if (!filter.test(part)) {\n        return\n      }\n\n      arr.push(absolutePath.replace(rootDir, ''))\n    })\n  )\n\n  return arr.sort()\n}\n"]},"metadata":{},"sourceType":"script"}