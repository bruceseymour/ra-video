{"ast":null,"code":"/**\n * line-column - Convert efficiently index to/from line-column in a string\n * @module  lineColumn\n * @license MIT\n */\n\"use strict\";\n\nvar isArray = require(\"isarray\");\n\nvar isObject = require(\"isobject\");\n\nvar slice = Array.prototype.slice;\nmodule.exports = LineColumnFinder;\n/**\n * Finder for index and line-column from given string.\n *\n * You can call this without `new` operator as it returns an instance anyway.\n *\n * @class\n * @param {string} str - A string to be parsed.\n * @param {Object|number} [options] - Options.\n *     This can be an index in the string for shorthand of `lineColumn(str, index)`.\n * @param {number} [options.origin=1] - The origin value of line and column.\n */\n\nfunction LineColumnFinder(str, options) {\n  if (!(this instanceof LineColumnFinder)) {\n    if (typeof options === \"number\") {\n      return new LineColumnFinder(str).fromIndex(options);\n    }\n\n    return new LineColumnFinder(str, options);\n  }\n\n  this.str = str || \"\";\n  this.lineToIndex = buildLineToIndex(this.str);\n  options = options || {};\n  this.origin = typeof options.origin === \"undefined\" ? 1 : options.origin;\n}\n/**\n * Find line and column from index in the string.\n *\n * @param  {number} index - Index in the string. (0-origin)\n * @return {Object|null}\n *     Found line number and column number in object `{ line: X, col: Y }`.\n *     If the given index is out of range, it returns `null`.\n */\n\n\nLineColumnFinder.prototype.fromIndex = function (index) {\n  if (index < 0 || index >= this.str.length || isNaN(index)) {\n    return null;\n  }\n\n  var line = findLowerIndexInRangeArray(index, this.lineToIndex);\n  return {\n    line: line + this.origin,\n    col: index - this.lineToIndex[line] + this.origin\n  };\n};\n/**\n * Find index from line and column in the string.\n *\n * @param  {number|Object|Array} line - Line number in the string.\n *     This can be an Object of `{ line: X, col: Y }`, or\n *     an Array of `[line, col]`.\n * @param  {number} [column] - Column number in the string.\n *     This must be omitted or undefined when Object or Array is given\n *     to the first argument.\n * @return {number}\n *     Found index in the string. (always 0-origin)\n *     If the given line or column is out of range, it returns `-1`.\n */\n\n\nLineColumnFinder.prototype.toIndex = function (line, column) {\n  if (typeof column === \"undefined\") {\n    if (isArray(line) && line.length >= 2) {\n      return this.toIndex(line[0], line[1]);\n    }\n\n    if (isObject(line) && \"line\" in line && (\"col\" in line || \"column\" in line)) {\n      return this.toIndex(line.line, \"col\" in line ? line.col : line.column);\n    }\n\n    return -1;\n  }\n\n  if (isNaN(line) || isNaN(column)) {\n    return -1;\n  }\n\n  line -= this.origin;\n  column -= this.origin;\n\n  if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {\n    var lineIndex = this.lineToIndex[line];\n    var nextIndex = line === this.lineToIndex.length - 1 ? this.str.length : this.lineToIndex[line + 1];\n\n    if (column < nextIndex - lineIndex) {\n      return lineIndex + column;\n    }\n  }\n\n  return -1;\n};\n/**\n * Build an array of indexes of each line from a string.\n *\n * @private\n * @param   str {string}  An input string.\n * @return  {number[]}    Built array of indexes. The key is line number.\n */\n\n\nfunction buildLineToIndex(str) {\n  var lines = str.split(\"\\n\"),\n      lineToIndex = new Array(lines.length),\n      index = 0;\n\n  for (var i = 0, l = lines.length; i < l; i++) {\n    lineToIndex[i] = index;\n    index += lines[i].length +\n    /* \"\\n\".length */\n    1;\n  }\n\n  return lineToIndex;\n}\n/**\n * Find a lower-bound index of a value in a sorted array of ranges.\n *\n * Assume `arr = [0, 5, 10, 15, 20]` and\n * this returns `1` for `value = 7` (5 <= value < 10),\n * and returns `3` for `value = 18` (15 <= value < 20).\n *\n * @private\n * @param  arr   {number[]} An array of values representing ranges.\n * @param  value {number}   A value to be searched.\n * @return {number} Found index. If not found `-1`.\n */\n\n\nfunction findLowerIndexInRangeArray(value, arr) {\n  if (value >= arr[arr.length - 1]) {\n    return arr.length - 1;\n  }\n\n  var min = 0,\n      max = arr.length - 2,\n      mid;\n\n  while (min < max) {\n    mid = min + (max - min >> 1);\n\n    if (value < arr[mid]) {\n      max = mid - 1;\n    } else if (value >= arr[mid + 1]) {\n      min = mid + 1;\n    } else {\n      // value >= arr[mid] && value < arr[mid + 1]\n      min = mid;\n      break;\n    }\n  }\n\n  return min;\n}","map":{"version":3,"sources":["/Users/bruceseymour/ra-video/client/node_modules/line-column/lib/line-column.js"],"names":["isArray","require","isObject","slice","Array","prototype","module","exports","LineColumnFinder","str","options","fromIndex","lineToIndex","buildLineToIndex","origin","index","length","isNaN","line","findLowerIndexInRangeArray","col","toIndex","column","lineIndex","nextIndex","lines","split","i","l","value","arr","min","max","mid"],"mappings":"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","sourcesContent":["/**\n * line-column - Convert efficiently index to/from line-column in a string\n * @module  lineColumn\n * @license MIT\n */\n\"use strict\";\n\nvar isArray  = require(\"isarray\");\nvar isObject = require(\"isobject\");\nvar slice = Array.prototype.slice;\n\nmodule.exports = LineColumnFinder;\n\n/**\n * Finder for index and line-column from given string.\n *\n * You can call this without `new` operator as it returns an instance anyway.\n *\n * @class\n * @param {string} str - A string to be parsed.\n * @param {Object|number} [options] - Options.\n *     This can be an index in the string for shorthand of `lineColumn(str, index)`.\n * @param {number} [options.origin=1] - The origin value of line and column.\n */\nfunction LineColumnFinder(str, options) {\n  if (!(this instanceof LineColumnFinder)) {\n    if (typeof options === \"number\") {\n      return (new LineColumnFinder(str)).fromIndex(options);\n    }\n    return new LineColumnFinder(str, options);\n  }\n\n  this.str = str || \"\";\n  this.lineToIndex = buildLineToIndex(this.str);\n\n  options = options || {};\n  this.origin = typeof options.origin === \"undefined\" ? 1 : options.origin;\n}\n\n/**\n * Find line and column from index in the string.\n *\n * @param  {number} index - Index in the string. (0-origin)\n * @return {Object|null}\n *     Found line number and column number in object `{ line: X, col: Y }`.\n *     If the given index is out of range, it returns `null`.\n */\nLineColumnFinder.prototype.fromIndex = function (index) {\n  if (index < 0 || index >= this.str.length || isNaN(index)) {\n    return null;\n  }\n\n  var line = findLowerIndexInRangeArray(index, this.lineToIndex);\n  return {\n    line: line + this.origin,\n    col:  index - this.lineToIndex[line] + this.origin\n  };\n}\n\n/**\n * Find index from line and column in the string.\n *\n * @param  {number|Object|Array} line - Line number in the string.\n *     This can be an Object of `{ line: X, col: Y }`, or\n *     an Array of `[line, col]`.\n * @param  {number} [column] - Column number in the string.\n *     This must be omitted or undefined when Object or Array is given\n *     to the first argument.\n * @return {number}\n *     Found index in the string. (always 0-origin)\n *     If the given line or column is out of range, it returns `-1`.\n */\nLineColumnFinder.prototype.toIndex = function (line, column) {\n  if (typeof column === \"undefined\") {\n    if (isArray(line) && line.length >= 2) {\n      return this.toIndex(line[0], line[1]);\n    }\n    if (isObject(line) && \"line\" in line && (\"col\" in line || \"column\" in line)) {\n      return this.toIndex(line.line, (\"col\" in line ? line.col : line.column));\n    }\n    return -1;\n  }\n  if (isNaN(line) || isNaN(column)) {\n    return -1;\n  }\n\n  line -= this.origin;\n  column -= this.origin;\n\n  if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {\n    var lineIndex = this.lineToIndex[line];\n    var nextIndex = (\n      line === this.lineToIndex.length - 1\n        ? this.str.length\n        : this.lineToIndex[line + 1]\n    );\n\n    if (column < nextIndex - lineIndex) {\n      return lineIndex + column;\n    }\n  }\n  return -1;\n}\n\n/**\n * Build an array of indexes of each line from a string.\n *\n * @private\n * @param   str {string}  An input string.\n * @return  {number[]}    Built array of indexes. The key is line number.\n */\nfunction buildLineToIndex(str) {\n  var lines = str.split(\"\\n\"),\n      lineToIndex = new Array(lines.length),\n      index = 0;\n\n  for (var i = 0, l = lines.length; i < l; i++) {\n    lineToIndex[i] = index;\n    index += lines[i].length + /* \"\\n\".length */ 1;\n  }\n  return lineToIndex;\n}\n\n/**\n * Find a lower-bound index of a value in a sorted array of ranges.\n *\n * Assume `arr = [0, 5, 10, 15, 20]` and\n * this returns `1` for `value = 7` (5 <= value < 10),\n * and returns `3` for `value = 18` (15 <= value < 20).\n *\n * @private\n * @param  arr   {number[]} An array of values representing ranges.\n * @param  value {number}   A value to be searched.\n * @return {number} Found index. If not found `-1`.\n */\nfunction findLowerIndexInRangeArray(value, arr) {\n  if (value >= arr[arr.length - 1]) {\n    return arr.length - 1;\n  }\n\n  var min = 0, max = arr.length - 2, mid;\n  while (min < max) {\n    mid = min + ((max - min) >> 1);\n\n    if (value < arr[mid]) {\n      max = mid - 1;\n    } else if (value >= arr[mid + 1]) {\n      min = mid + 1;\n    } else { // value >= arr[mid] && value < arr[mid + 1]\n      min = mid;\n      break;\n    }\n  }\n  return min;\n}\n"]},"metadata":{},"sourceType":"script"}