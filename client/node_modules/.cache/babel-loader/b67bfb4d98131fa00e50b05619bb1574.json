{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.FontStylesheetGatheringPlugin = void 0;\n\nvar _webpack = _interopRequireDefault(require(\"webpack\"));\n\nvar _webpackSources = _interopRequireDefault(require(\"webpack-sources\"));\n\nvar _fontUtils = require(\"../../../next-server/server/font-utils\");\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _cssnanoSimple = _interopRequireDefault(require(\"cssnano-simple\"));\n\nvar _constants = require(\"../../../next-server/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // @ts-ignore: TODO: remove ignore when webpack 5 is stable\n\n\nconst {\n  RawSource\n} = _webpack.default.sources || _webpackSources.default;\nconst isWebpack5 = parseInt(_webpack.default.version) === 5;\nlet BasicEvaluatedExpression;\n\nif (isWebpack5) {\n  BasicEvaluatedExpression = require('webpack/lib/javascript/BasicEvaluatedExpression');\n} else {\n  BasicEvaluatedExpression = require('webpack/lib/BasicEvaluatedExpression');\n}\n\nasync function minifyCss(css) {\n  return new Promise(resolve => (0, _postcss.default)([(0, _cssnanoSimple.default)({\n    excludeAll: true,\n    discardComments: true,\n    normalizeWhitespace: {\n      exclude: false\n    }\n  })]).process(css, {\n    from: undefined\n  }).then(res => {\n    resolve(res.css);\n  }));\n}\n\nclass FontStylesheetGatheringPlugin {\n  constructor() {\n    this.compiler = void 0;\n    this.gatheredStylesheets = [];\n    this.manifestContent = [];\n\n    this.parserHandler = factory => {\n      const JS_TYPES = ['auto', 'esm', 'dynamic']; // Do an extra walk per module and add interested visitors to the walk.\n\n      for (const type of JS_TYPES) {\n        factory.hooks.parser.for('javascript/' + type).tap(this.constructor.name, parser => {\n          /**\n          * Webpack fun facts:\n          * `parser.hooks.call.for` cannot catch calls for user defined identifiers like `__jsx`\n          * it can only detect calls for native objects like `window`, `this`, `eval` etc.\n          * In order to be able to catch calls of variables like `__jsx`, first we need to catch them as\n          * Identifier and then return `BasicEvaluatedExpression` whose `id` and `type` webpack matches to\n          * invoke hook for call.\n          * See: https://github.com/webpack/webpack/blob/webpack-4/lib/Parser.js#L1931-L1932.\n          */\n          parser.hooks.evaluate.for('Identifier').tap(this.constructor.name, node => {\n            var _parser$state, _parser$state$module; // We will only optimize fonts from first party code.\n\n\n            if (parser != null && (_parser$state = parser.state) != null && (_parser$state$module = _parser$state.module) != null && _parser$state$module.resource.includes('node_modules')) {\n              return;\n            }\n\n            let result;\n\n            if (node.name === '_jsx' || node.name === '__jsx') {\n              result = new BasicEvaluatedExpression(); // @ts-ignore\n\n              result.setRange(node.range);\n              result.setExpression(node);\n              result.setIdentifier(node.name); // This was added webpack 5.\n\n              if (isWebpack5) {\n                result.getMembers = () => [];\n              }\n            }\n\n            return result;\n          });\n\n          const jsxNodeHandler = node => {\n            if (node.arguments.length !== 2) {\n              // A font link tag has only two arguments rel=stylesheet and href='...'\n              return;\n            }\n\n            if (!isNodeCreatingLinkElement(node)) {\n              return;\n            } // node.arguments[0] is the name of the tag and [1] are the props.\n\n\n            const propsNode = node.arguments[1];\n            const props = {};\n            propsNode.properties.forEach(prop => {\n              if (prop.type !== 'Property') {\n                return;\n              }\n\n              if (prop.key.type === 'Identifier' && prop.value.type === 'Literal') {\n                props[prop.key.name] = prop.value.value;\n              }\n            });\n\n            if (!props.rel || props.rel !== 'stylesheet' || !props.href || !_constants.OPTIMIZED_FONT_PROVIDERS.some(url => props.href.startsWith(url))) {\n              return false;\n            }\n\n            this.gatheredStylesheets.push(props.href);\n          }; // React JSX transform:\n\n\n          parser.hooks.call.for('_jsx').tap(this.constructor.name, jsxNodeHandler); // Next.js JSX transform:\n\n          parser.hooks.call.for('__jsx').tap(this.constructor.name, jsxNodeHandler);\n        });\n      }\n    };\n  }\n\n  apply(compiler) {\n    this.compiler = compiler;\n    compiler.hooks.normalModuleFactory.tap(this.constructor.name, this.parserHandler);\n    compiler.hooks.make.tapAsync(this.constructor.name, (compilation, cb) => {\n      // @ts-ignore\n      if (compilation.options.output.path.endsWith('serverless')) {\n        /**\n        * Inline font manifest for serverless case only.\n        * For target: server drive the manifest through physical file and less of webpack magic.\n        */\n        const mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.requireExtensions.tap(this.constructor.name, source => {\n          return `${source}\n                // Font manifest declaration\n                ${isWebpack5 ? '__webpack_require__' : mainTemplate.requireFn}.__NEXT_FONT_MANIFEST__ = ${JSON.stringify(this.manifestContent)};\n            // Enable feature:\n            process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);`;\n        });\n      }\n\n      compilation.hooks.finishModules.tapAsync(this.constructor.name, async (_, modulesFinished) => {\n        const fontDefinitionPromises = this.gatheredStylesheets.map(url => (0, _fontUtils.getFontDefinitionFromNetwork)(url));\n        this.manifestContent = [];\n\n        for (let promiseIndex in fontDefinitionPromises) {\n          const css = await fontDefinitionPromises[promiseIndex];\n          const content = await minifyCss(css);\n          this.manifestContent.push({\n            url: this.gatheredStylesheets[promiseIndex],\n            content\n          });\n        }\n\n        if (!isWebpack5) {\n          compilation.assets[_constants.FONT_MANIFEST] = new RawSource(JSON.stringify(this.manifestContent, null, '  '));\n        }\n\n        modulesFinished();\n      });\n      cb();\n    });\n\n    if (isWebpack5) {\n      compiler.hooks.make.tap(this.constructor.name, compilation => {\n        // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n        compilation.hooks.processAssets.tap({\n          name: this.constructor.name,\n          // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n          stage: _webpack.default.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n        }, assets => {\n          assets[_constants.FONT_MANIFEST] = new RawSource(JSON.stringify(this.manifestContent, null, '  '));\n        });\n      });\n    }\n  }\n\n}\n\nexports.FontStylesheetGatheringPlugin = FontStylesheetGatheringPlugin;\n\nfunction isNodeCreatingLinkElement(node) {\n  const callee = node.callee;\n\n  if (callee.type !== 'Identifier') {\n    return false;\n  }\n\n  const componentNode = node.arguments[0];\n\n  if (componentNode.type !== 'Literal') {\n    return false;\n  } // React has pragma: _jsx.\n  // Next has pragma: __jsx.\n\n\n  return (callee.name === '_jsx' || callee.name === '__jsx') && componentNode.value === 'link';\n}","map":{"version":3,"sources":["../../../../build/webpack/plugins/font-stylesheet-gathering-plugin.ts"],"names":["webpack","sources","isWebpack5","parseInt","BasicEvaluatedExpression","require","resolve","excludeAll","discardComments","normalizeWhitespace","exclude","from","res","FontStylesheetGatheringPlugin","factory","JS_TYPES","parser","node","result","jsxNodeHandler","isNodeCreatingLinkElement","propsNode","props","prop","OPTIMIZED_FONT_PROVIDERS","url","apply","compiler","compilation","mainTemplate","source","requireFn","JSON","fontDefinitionPromises","css","content","minifyCss","FONT_MANIFEST","modulesFinished","cb","name","stage","assets","callee","componentNode"],"mappings":"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","sourcesContent":["import webpack, { compilation as CompilationType, Compiler } from 'webpack'\nimport { namedTypes } from 'ast-types'\nimport sources from 'webpack-sources'\nimport {\n  getFontDefinitionFromNetwork,\n  FontManifest,\n} from '../../../next-server/server/font-utils'\nimport postcss from 'postcss'\nimport minifier from 'cssnano-simple'\nimport {\n  FONT_MANIFEST,\n  OPTIMIZED_FONT_PROVIDERS,\n} from '../../../next-server/lib/constants'\n\n// @ts-ignore: TODO: remove ignore when webpack 5 is stable\nconst { RawSource } = webpack.sources || sources\n\nconst isWebpack5 = parseInt(webpack.version!) === 5\n\nlet BasicEvaluatedExpression: any\nif (isWebpack5) {\n  BasicEvaluatedExpression = require('webpack/lib/javascript/BasicEvaluatedExpression')\n} else {\n  BasicEvaluatedExpression = require('webpack/lib/BasicEvaluatedExpression')\n}\n\nasync function minifyCss(css: string): Promise<string> {\n  return new Promise((resolve) =>\n    postcss([\n      minifier({\n        excludeAll: true,\n        discardComments: true,\n        normalizeWhitespace: { exclude: false },\n      }),\n    ])\n      .process(css, { from: undefined })\n      .then((res) => {\n        resolve(res.css)\n      })\n  )\n}\n\nexport class FontStylesheetGatheringPlugin {\n  compiler?: Compiler\n  gatheredStylesheets: Array<string> = []\n  manifestContent: FontManifest = []\n\n  private parserHandler = (\n    factory: CompilationType.NormalModuleFactory\n  ): void => {\n    const JS_TYPES = ['auto', 'esm', 'dynamic']\n    // Do an extra walk per module and add interested visitors to the walk.\n    for (const type of JS_TYPES) {\n      factory.hooks.parser\n        .for('javascript/' + type)\n        .tap(this.constructor.name, (parser: any) => {\n          /**\n           * Webpack fun facts:\n           * `parser.hooks.call.for` cannot catch calls for user defined identifiers like `__jsx`\n           * it can only detect calls for native objects like `window`, `this`, `eval` etc.\n           * In order to be able to catch calls of variables like `__jsx`, first we need to catch them as\n           * Identifier and then return `BasicEvaluatedExpression` whose `id` and `type` webpack matches to\n           * invoke hook for call.\n           * See: https://github.com/webpack/webpack/blob/webpack-4/lib/Parser.js#L1931-L1932.\n           */\n          parser.hooks.evaluate\n            .for('Identifier')\n            .tap(this.constructor.name, (node: namedTypes.Identifier) => {\n              // We will only optimize fonts from first party code.\n              if (parser?.state?.module?.resource.includes('node_modules')) {\n                return\n              }\n              let result\n              if (node.name === '_jsx' || node.name === '__jsx') {\n                result = new BasicEvaluatedExpression()\n                // @ts-ignore\n                result.setRange(node.range)\n                result.setExpression(node)\n                result.setIdentifier(node.name)\n\n                // This was added webpack 5.\n                if (isWebpack5) {\n                  result.getMembers = () => []\n                }\n              }\n              return result\n            })\n\n          const jsxNodeHandler = (node: namedTypes.CallExpression) => {\n            if (node.arguments.length !== 2) {\n              // A font link tag has only two arguments rel=stylesheet and href='...'\n              return\n            }\n            if (!isNodeCreatingLinkElement(node)) {\n              return\n            }\n\n            // node.arguments[0] is the name of the tag and [1] are the props.\n            const propsNode = node.arguments[1] as namedTypes.ObjectExpression\n            const props: { [key: string]: string } = {}\n            propsNode.properties.forEach((prop) => {\n              if (prop.type !== 'Property') {\n                return\n              }\n              if (\n                prop.key.type === 'Identifier' &&\n                prop.value.type === 'Literal'\n              ) {\n                props[prop.key.name] = prop.value.value as string\n              }\n            })\n            if (\n              !props.rel ||\n              props.rel !== 'stylesheet' ||\n              !props.href ||\n              !OPTIMIZED_FONT_PROVIDERS.some((url) =>\n                props.href.startsWith(url)\n              )\n            ) {\n              return false\n            }\n\n            this.gatheredStylesheets.push(props.href)\n          }\n          // React JSX transform:\n          parser.hooks.call\n            .for('_jsx')\n            .tap(this.constructor.name, jsxNodeHandler)\n          // Next.js JSX transform:\n          parser.hooks.call\n            .for('__jsx')\n            .tap(this.constructor.name, jsxNodeHandler)\n        })\n    }\n  }\n\n  public apply(compiler: Compiler) {\n    this.compiler = compiler\n    compiler.hooks.normalModuleFactory.tap(\n      this.constructor.name,\n      this.parserHandler\n    )\n    compiler.hooks.make.tapAsync(this.constructor.name, (compilation, cb) => {\n      // @ts-ignore\n      if (compilation.options.output.path.endsWith('serverless')) {\n        /**\n         * Inline font manifest for serverless case only.\n         * For target: server drive the manifest through physical file and less of webpack magic.\n         */\n        const mainTemplate = compilation.mainTemplate\n        mainTemplate.hooks.requireExtensions.tap(\n          this.constructor.name,\n          (source: string) => {\n            return `${source}\n                // Font manifest declaration\n                ${\n                  isWebpack5 ? '__webpack_require__' : mainTemplate.requireFn\n                }.__NEXT_FONT_MANIFEST__ = ${JSON.stringify(\n              this.manifestContent\n            )};\n            // Enable feature:\n            process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);`\n          }\n        )\n      }\n      compilation.hooks.finishModules.tapAsync(\n        this.constructor.name,\n        async (_: any, modulesFinished: Function) => {\n          const fontDefinitionPromises = this.gatheredStylesheets.map((url) =>\n            getFontDefinitionFromNetwork(url)\n          )\n\n          this.manifestContent = []\n          for (let promiseIndex in fontDefinitionPromises) {\n            const css = await fontDefinitionPromises[promiseIndex]\n            const content = await minifyCss(css)\n            this.manifestContent.push({\n              url: this.gatheredStylesheets[promiseIndex],\n              content,\n            })\n          }\n          if (!isWebpack5) {\n            compilation.assets[FONT_MANIFEST] = new RawSource(\n              JSON.stringify(this.manifestContent, null, '  ')\n            )\n          }\n          modulesFinished()\n        }\n      )\n      cb()\n    })\n\n    if (isWebpack5) {\n      compiler.hooks.make.tap(this.constructor.name, (compilation) => {\n        // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n        compilation.hooks.processAssets.tap(\n          {\n            name: this.constructor.name,\n            // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS,\n          },\n          (assets: any) => {\n            assets[FONT_MANIFEST] = new RawSource(\n              JSON.stringify(this.manifestContent, null, '  ')\n            )\n          }\n        )\n      })\n    }\n  }\n}\n\nfunction isNodeCreatingLinkElement(node: namedTypes.CallExpression) {\n  const callee = node.callee as namedTypes.Identifier\n  if (callee.type !== 'Identifier') {\n    return false\n  }\n  const componentNode = node.arguments[0] as namedTypes.Literal\n  if (componentNode.type !== 'Literal') {\n    return false\n  }\n  // React has pragma: _jsx.\n  // Next has pragma: __jsx.\n  return (\n    (callee.name === '_jsx' || callee.name === '__jsx') &&\n    componentNode.value === 'link'\n  )\n}\n"]},"metadata":{},"sourceType":"script"}