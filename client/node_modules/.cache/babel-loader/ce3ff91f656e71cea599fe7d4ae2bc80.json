{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.hasZeroOrOneAsteriskCharacter = hasZeroOrOneAsteriskCharacter;\nexports.pathIsRelative = pathIsRelative;\nexports.tryParsePattern = tryParsePattern;\nexports.findBestPatternMatch = findBestPatternMatch;\nexports.matchPatternOrExact = matchPatternOrExact;\nexports.isString = isString;\nexports.matchedText = matchedText;\nexports.patternText = patternText;\nexports.JsConfigPathsPlugin = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _debug = require(\"next/dist/compiled/debug\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n* This webpack resolver is largely based on TypeScript's \"paths\" handling\n* The TypeScript license can be found here:\n* https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n*/\n\n\nconst log = (0, _debug.debug)('next:jsconfig-paths-plugin');\nconst asterisk = 0x2a;\n\nfunction hasZeroOrOneAsteriskCharacter(str) {\n  let seenAsterisk = false;\n\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true;\n      } else {\n        // have already seen asterisk\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n* Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n*/\n\n\nfunction pathIsRelative(testPath) {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath);\n}\n\nfunction tryParsePattern(pattern) {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*');\n  return indexOfStar === -1 ? undefined : {\n    prefix: pattern.substr(0, indexOfStar),\n    suffix: pattern.substr(indexOfStar + 1)\n  };\n}\n\nfunction isPatternMatch({\n  prefix,\n  suffix\n}, candidate) {\n  return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);\n}\n/** Return the object corresponding to the best pattern to match `candidate`. */\n\n\nfunction findBestPatternMatch(values, getPattern, candidate) {\n  let matchedValue; // use length of prefix as betterness criteria\n\n  let longestMatchPrefixLength = -1;\n\n  for (const v of values) {\n    const pattern = getPattern(v);\n\n    if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\n      longestMatchPrefixLength = pattern.prefix.length;\n      matchedValue = v;\n    }\n  }\n\n  return matchedValue;\n}\n/**\n* patternStrings contains both pattern strings (containing \"*\") and regular strings.\n* Return an exact match if possible, or a pattern match, or undefined.\n* (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n*/\n\n\nfunction matchPatternOrExact(patternStrings, candidate) {\n  const patterns = [];\n\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;\n    const pattern = tryParsePattern(patternString);\n\n    if (pattern) {\n      patterns.push(pattern);\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString;\n    }\n  }\n\n  return findBestPatternMatch(patterns, _ => _, candidate);\n}\n/**\n* Tests whether a value is string\n*/\n\n\nfunction isString(text) {\n  return typeof text === 'string';\n}\n/**\n* Given that candidate matches pattern, returns the text matching the '*'.\n* E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n*/\n\n\nfunction matchedText(pattern, candidate) {\n  return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\n\nfunction patternText({\n  prefix,\n  suffix\n}) {\n  return `${prefix}*${suffix}`;\n}\n\nconst NODE_MODULES_REGEX = /node_modules/;\n/**\n* Handles tsconfig.json or jsconfig.js \"paths\" option for webpack\n* Largely based on how the TypeScript compiler handles it:\n* https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362\n*/\n\nclass JsConfigPathsPlugin {\n  constructor(paths, resolvedBaseUrl) {\n    this.paths = void 0;\n    this.resolvedBaseUrl = void 0;\n    this.paths = paths;\n    this.resolvedBaseUrl = resolvedBaseUrl;\n    log('tsconfig.json or jsconfig.json paths: %O', paths);\n    log('resolved baseUrl: %s', resolvedBaseUrl);\n  }\n\n  apply(resolver) {\n    const paths = this.paths;\n    const pathsKeys = Object.keys(paths); // If no aliases are added bail out\n\n    if (pathsKeys.length === 0) {\n      log('paths are empty, bailing out');\n      return;\n    }\n\n    const baseDirectory = this.resolvedBaseUrl;\n    const target = resolver.ensureHook('resolve');\n    resolver.getHook('described-resolve').tapPromise('JsConfigPathsPlugin', async (request, resolveContext) => {\n      const moduleName = request.request; // Exclude node_modules from paths support (speeds up resolving)\n\n      if (request.path.match(NODE_MODULES_REGEX)) {\n        log('skipping request as it is inside node_modules %s', moduleName);\n        return;\n      }\n\n      if (_path.default.posix.isAbsolute(moduleName) || process.platform === 'win32' && _path.default.win32.isAbsolute(moduleName)) {\n        log('skipping request as it is an absolute path %s', moduleName);\n        return;\n      }\n\n      if (pathIsRelative(moduleName)) {\n        log('skipping request as it is a relative path %s', moduleName);\n        return;\n      } // log('starting to resolve request %s', moduleName)\n      // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n\n\n      const matchedPattern = matchPatternOrExact(pathsKeys, moduleName);\n\n      if (!matchedPattern) {\n        log('moduleName did not match any paths pattern %s', moduleName);\n        return;\n      }\n\n      const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);\n      const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);\n      let triedPaths = [];\n\n      for (const subst of paths[matchedPatternText]) {\n        const curPath = matchedStar ? subst.replace('*', matchedStar) : subst; // Ensure .d.ts is not matched\n\n        if (curPath.endsWith('.d.ts')) {\n          continue;\n        }\n\n        const candidate = _path.default.join(baseDirectory, curPath);\n\n        const [err, result] = await new Promise(resolve => {\n          const obj = Object.assign({}, request, {\n            request: candidate\n          });\n          resolver.doResolve(target, obj, `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`, resolveContext, (resolverErr, resolverResult) => {\n            resolve([resolverErr, resolverResult]);\n          });\n        }); // There's multiple paths values possible, so we first have to iterate them all first before throwing an error\n\n        if (err || result === undefined) {\n          triedPaths.push(candidate);\n          continue;\n        }\n\n        return result;\n      }\n    });\n  }\n\n}\n\nexports.JsConfigPathsPlugin = JsConfigPathsPlugin;","map":{"version":3,"sources":["../../../../build/webpack/plugins/jsconfig-paths-plugin.ts"],"names":["log","asterisk","seenAsterisk","i","str","indexOfStar","pattern","prefix","suffix","candidate","longestMatchPrefixLength","getPattern","isPatternMatch","matchedValue","patterns","hasZeroOrOneAsteriskCharacter","tryParsePattern","patternString","findBestPatternMatch","_","NODE_MODULES_REGEX","JsConfigPathsPlugin","paths","resolvedBaseUrl","constructor","apply","pathsKeys","Object","baseDirectory","target","resolver","moduleName","request","path","process","pathIsRelative","matchedPattern","matchPatternOrExact","matchedStar","isString","matchedText","matchedPatternText","patternText","triedPaths","curPath","subst","resolve","obj","err","result"],"mappings":"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","sourcesContent":["/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */\nimport path from 'path'\nimport { ResolvePlugin } from 'webpack'\nimport { debug } from 'next/dist/compiled/debug'\n\nconst log = debug('next:jsconfig-paths-plugin')\n\nexport interface Pattern {\n  prefix: string\n  suffix: string\n}\n\nconst asterisk = 0x2a\n\nexport function hasZeroOrOneAsteriskCharacter(str: string): boolean {\n  let seenAsterisk = false\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true\n      } else {\n        // have already seen asterisk\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n */\nexport function pathIsRelative(testPath: string): boolean {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath)\n}\n\nexport function tryParsePattern(pattern: string): Pattern | undefined {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*')\n  return indexOfStar === -1\n    ? undefined\n    : {\n        prefix: pattern.substr(0, indexOfStar),\n        suffix: pattern.substr(indexOfStar + 1),\n      }\n}\n\nfunction isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\n  return (\n    candidate.length >= prefix.length + suffix.length &&\n    candidate.startsWith(prefix) &&\n    candidate.endsWith(suffix)\n  )\n}\n\n/** Return the object corresponding to the best pattern to match `candidate`. */\nexport function findBestPatternMatch<T>(\n  values: readonly T[],\n  getPattern: (value: T) => Pattern,\n  candidate: string\n): T | undefined {\n  let matchedValue: T | undefined\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1\n\n  for (const v of values) {\n    const pattern = getPattern(v)\n    if (\n      isPatternMatch(pattern, candidate) &&\n      pattern.prefix.length > longestMatchPrefixLength\n    ) {\n      longestMatchPrefixLength = pattern.prefix.length\n      matchedValue = v\n    }\n  }\n\n  return matchedValue\n}\n\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */\nexport function matchPatternOrExact(\n  patternStrings: readonly string[],\n  candidate: string\n): string | Pattern | undefined {\n  const patterns: Pattern[] = []\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue\n    const pattern = tryParsePattern(patternString)\n    if (pattern) {\n      patterns.push(pattern)\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString\n    }\n  }\n\n  return findBestPatternMatch(patterns, (_) => _, candidate)\n}\n\n/**\n * Tests whether a value is string\n */\nexport function isString(text: unknown): text is string {\n  return typeof text === 'string'\n}\n\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */\nexport function matchedText(pattern: Pattern, candidate: string): string {\n  return candidate.substring(\n    pattern.prefix.length,\n    candidate.length - pattern.suffix.length\n  )\n}\n\nexport function patternText({ prefix, suffix }: Pattern): string {\n  return `${prefix}*${suffix}`\n}\n\nconst NODE_MODULES_REGEX = /node_modules/\n\ntype Paths = { [match: string]: string[] }\n\n/**\n * Handles tsconfig.json or jsconfig.js \"paths\" option for webpack\n * Largely based on how the TypeScript compiler handles it:\n * https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362\n */\nexport class JsConfigPathsPlugin implements ResolvePlugin {\n  paths: Paths\n  resolvedBaseUrl: string\n  constructor(paths: Paths, resolvedBaseUrl: string) {\n    this.paths = paths\n    this.resolvedBaseUrl = resolvedBaseUrl\n    log('tsconfig.json or jsconfig.json paths: %O', paths)\n    log('resolved baseUrl: %s', resolvedBaseUrl)\n  }\n  apply(resolver: any) {\n    const paths = this.paths\n    const pathsKeys = Object.keys(paths)\n\n    // If no aliases are added bail out\n    if (pathsKeys.length === 0) {\n      log('paths are empty, bailing out')\n      return\n    }\n\n    const baseDirectory = this.resolvedBaseUrl\n    const target = resolver.ensureHook('resolve')\n    resolver\n      .getHook('described-resolve')\n      .tapPromise(\n        'JsConfigPathsPlugin',\n        async (request: any, resolveContext: any) => {\n          const moduleName = request.request\n\n          // Exclude node_modules from paths support (speeds up resolving)\n          if (request.path.match(NODE_MODULES_REGEX)) {\n            log('skipping request as it is inside node_modules %s', moduleName)\n            return\n          }\n\n          if (\n            path.posix.isAbsolute(moduleName) ||\n            (process.platform === 'win32' && path.win32.isAbsolute(moduleName))\n          ) {\n            log('skipping request as it is an absolute path %s', moduleName)\n            return\n          }\n\n          if (pathIsRelative(moduleName)) {\n            log('skipping request as it is a relative path %s', moduleName)\n            return\n          }\n\n          // log('starting to resolve request %s', moduleName)\n\n          // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n          const matchedPattern = matchPatternOrExact(pathsKeys, moduleName)\n          if (!matchedPattern) {\n            log('moduleName did not match any paths pattern %s', moduleName)\n            return\n          }\n\n          const matchedStar = isString(matchedPattern)\n            ? undefined\n            : matchedText(matchedPattern, moduleName)\n          const matchedPatternText = isString(matchedPattern)\n            ? matchedPattern\n            : patternText(matchedPattern)\n\n          let triedPaths = []\n\n          for (const subst of paths[matchedPatternText]) {\n            const curPath = matchedStar\n              ? subst.replace('*', matchedStar)\n              : subst\n\n            // Ensure .d.ts is not matched\n            if (curPath.endsWith('.d.ts')) {\n              continue\n            }\n\n            const candidate = path.join(baseDirectory, curPath)\n            const [err, result] = await new Promise((resolve) => {\n              const obj = Object.assign({}, request, {\n                request: candidate,\n              })\n              resolver.doResolve(\n                target,\n                obj,\n                `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`,\n                resolveContext,\n                (resolverErr: any, resolverResult: any | undefined) => {\n                  resolve([resolverErr, resolverResult])\n                }\n              )\n            })\n\n            // There's multiple paths values possible, so we first have to iterate them all first before throwing an error\n            if (err || result === undefined) {\n              triedPaths.push(candidate)\n              continue\n            }\n\n            return result\n          }\n        }\n      )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}